rgb(0, 123, 118, maxColorValue = 255),
rgb(255, 147, 0, maxColorValue = 255),
rgb(181, 23, 0, maxColorValue = 255)),
k = 4)
# Graficador base de R:
plot(dend)
ggd1 <- as.ggdend(dend)
ggd1.plot <- ggplot(ggd1, offset_labels = -1, theme = blank_theme()) +
ylim(-2.4, max(get_branches_heights(dend))) +
scale_x_continuous(breaks = NULL) +
labs(title = "Dendrograma de especies de cetáceos",
subtitle = "Agrupamientos por longitud (método: promedio)",
x = element_blank(),
y = "Distancia euclidiana",
caption = "Datos de bit.ly/clust_medium")
ggd1.plot
clust.df <- read.table("cluster.txt", header = T, row.names = 1) # ¡OJO con row.names!
summary(clust.df)
mask <- colnames(clust.df)[colnames(clust.df) != "SST"]
clust.filt <- clust.df[,mask]
colnames(clust.filt)
clust.scale <- scale(clust.filt)
#clust.scale <- log(clust.filt +1) # Si de todos modos deseas aplicar una transformación para "normalizar" los datos.
summary(clust.scale)
dist.mv1 <- vegdist(clust.scale, method = "mahalanobis")
hc.mv1 <- hclust(dist.mv1, method ="ward.D2")
# Transformemos nuestro objeto a un dendrograma:
dend.mv1 <- as.dendrogram(hc.mv1)
# Cambiemos el color a las ramas:
dend.mv1 <- set(dend.mv1, "branches_k_color",
value = "deepskyblue4",
k = 1)
dend.mv1 <- set(dend.mv1, "branches_lwd", 0.7)
ggd1 <- as.ggdend(dend.mv1)
ggd1.plot <- ggplot(ggd1, offset_labels = -1, theme = blank_theme()) +
expand_limits(y = -2.4) +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = seq(0,max(get_branches_heights(dend.mv1)),2)) +
labs(title = "Dendrograma de sitios de muestreo",
subtitle = "Método de agrupamiento: Ward.D2)",
x = element_blank(),
y = "Distancia Mahalanobis",
caption = "Datos: clust.txt")
ggd1.plot
dist.mv2 <- vegdist(clust.scale, method = "euclidean")
hc.mv2 <- hclust(dist.mv2, method ="ward.D2")
# Transformemos nuestro objeto a un dendrograma:
dend.mv2 <- as.dendrogram(hc.mv2)
# Cambiemos el color a las ramas:
dend.mv2 <- set(dend.mv2, "branches_k_color",
value = "deepskyblue4",
k = 1)
dend.mv2 <- set(dend.mv2, "branches_lwd", 0.7)
ggd2 <- as.ggdend(dend.mv2)
ggd2.plot <- ggplot(ggd2, offset_labels = -1, theme = blank_theme()) +
expand_limits(y = -2.4) +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = seq(0,max(get_branches_heights(dend.mv2)),2)) +
labs(title = "Dendrograma de sitios de muestreo",
subtitle = "Método de agrupamiento: Ward.D2)",
x = element_blank(),
y = "Distancia Euclidiana",
caption = "Datos: clust.txt")
ggd2.plot
dist.mv3 <- vegdist(clust.scale, method = "manhattan")
hc.mv3 <- hclust(dist.mv3, method ="ward.D2")
# Transformemos nuestro objeto a un dendrograma:
dend.mv3 <- as.dendrogram(hc.mv3)
# Cambiemos el color a las ramas:
dend.mv3 <- set(dend.mv3, "branches_k_color",
value = "deepskyblue4",
k = 1)
dend.mv3 <- set(dend.mv3, "branches_lwd", 0.7)
ggd3 <- as.ggdend(dend.mv3)
ggd3.plot <- ggplot(ggd3, offset_labels = -1, theme = blank_theme()) +
expand_limits(y = -3.5) +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = seq(0,max(get_branches_heights(dend.mv3)),5)) +
labs(title = "Dendrograma de sitios de muestreo",
subtitle = "Método de agrupamiento: Ward.D2)",
x = element_blank(),
y = "Distancia Manhattan",
caption = "Datos: clust.txt")
ggd3.plot
library(NbClust)
res <- NbClust(clust.scale, diss = NULL, distance = "euclidean", method = "ward.D2", index = "all", max.nc = 8)
res$Best.partition
hc.e <- cluster::agnes(dist.mv2, diss = T, method = "ward")
ccc <- cophenetic(hc.e)
ccofen <- cor(dist.mv2, ccc)
ccofen
# Cambiamos el color de nuestr
dend.mv2 <- set(dend.mv2, "labels_col",
value = 1:3,
k = 3)
dend.mv2 <- set(dend.mv2, "branches_k_color",
value = 1:3,
k = 3)
dend.mv2 <- set(dend.mv2, "branches_lwd", 0.7)
ggd2 <- as.ggdend(dend.mv2)
ggd2.plot <- ggplot(ggd2, offset_labels = -1, theme = blank_theme()) +
expand_limits(y = -2.4) +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = seq(0,max(get_branches_heights(dend.mv2)),2)) +
labs(title = "Dendrograma de sitios de muestreo",
subtitle = "Método de agrupamiento: Ward.D2)",
x = element_blank(),
y = "Distancia Euclidiana",
caption = "Datos: clust.txt")
ggd2.plot
library(factoextra, quietly = T)
library(FactoMineR, quietly = T)
#Base de datos completa
x1n <- read.table('Medidas.txt', header = TRUE)
#Base de datos sin nombres de especies
x1 <- x1n[ ,2:length(x1n) ]
summary(x1)
res.pca <- FactoMineR::PCA(x1, graph = F, ncp = length(x1), scale.unit = T) #Aplicamos el ACP con los datos escalados y centrados
var <- get_pca_var(res.pca) # Extraemos las correlaciones de cada variable con cada componente principal
cors <- (round(abs(var$coord),2))
fviz_pca_var(res.pca, col.var = "coord",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
library(corrplot)
corrplot(var$coord, is.corr = T)
sort(cors[,1], decreasing = T)[1:4]
sort(cors[,2], decreasing = T)[1:4]
fviz_pca_ind(res.pca,
geom.ind = "point", # Mostrar solo puntos (sin textos)
col.ind = x1n[,1], # Número de colores (grupos)
palette = c("#00AFBB", "#E7B800", "#FC4E07"), # Colores a utilizar
addEllipses = TRUE, # Elipses de concentración
legend.title = "Especies")
fviz_pca_biplot(res.pca,
col.ind = x1n$especie, palette = "jco",
addEllipses = TRUE, label = "var",
col.var = "black", repel = TRUE,
legend.title = "Especies")
eig.val <- get_eigenvalue(res.pca)
eig.val
fviz_eig(res.pca, addlabels = T)
#Kaisser-Guttman y Broken Stick
PCAs <- vegan::rda (x1, scale = T)
# Seleccionamos el marco de datos con los eigenvalores y corremos ambos análisis
ev <- PCAs$CA$eig
evplot(ev)
mnv <- manova(as.matrix(x1n[,-1]) ~ x1n$especie)
summary.manova(mnv,test="Wilks")
library(caTools)
library(caret)
sample <- sample.split(x1n$especie, SplitRatio = .75)
train <- subset(x1n, sample == TRUE)
test <- subset(x1n, sample == FALSE)
pre.pars <- preProcess(train, method = c("center", "scale"))
train.t <- predict(pre.pars, train)
test.t <- predict(pre.pars, test)
mod <- lm(cbind(as.matrix(train.t[,2:32])) ~ train.t$especie)
library(candisc, quietly = T)
can <- candisc(mod)
summary(can)
correlacion <- cor(cbind(as.matrix(train.t[,2:32])),
can$scores[,2:3])
correlacion
plot(can)
points(can$scores[,2], can$scores[,3], col = train.t$especie)
text(can$scores[,2], can$scores[,3], labels = rownames(paste(x1n[,1], sep = '')), cex=0.9, pos=3)
library(MASS, quietly = T)
lda <- lda(especie ~ ., data = train.t)
plot(lda)
plot(lda, dimen = 1, type = "both")
pred.clase <- predict(lda, test.t)$class
p<-predict(lda)$posterior
p.acom <- data.frame(especie = test.t$especie, id = rownames(test.t), p = p)
p.acom
jicuad <- chisq.test(test$especie, pred.clase, simulate.p.value = T)
jicuad
confusionMatrix(pred.clase, test.t$especie)
# Instalación de paqueterías:
librerias <- c("ggdendro", "dendextend", "factoextra", "cluster", "NbClust", "FactoMineR", "MASS", "vegan", "caTools", "caret")
if(!require(librerias)) install.packages(librerias, dependencies = T)
?require
lda.data <- cbind(train.t, predict(lda.mod)$x)
library(MASS)
lda.mod <- lda(especie ~ ., data = train.t)
plot(lda.mod)
plot(lda.mod, dimen = 1, type = "both")
pred.clase <- predict(lda.mod, test.t)$class
p<-predict(lda.mod)$posterior
p.acom <- data.frame(especie = test.t$especie, id = rownames(test.t), p = p)
p.acom
jicuad <- chisq.test(test$especie, pred.clase, simulate.p.value = T)
jicuad
confusionMatrix(pred.clase, test.t$especie)
lda.data <- cbind(train.t, predict(lda.mod)$x)
ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie))
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt") +
blank_theme()
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt") +
blank_theme()
lda.plot
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt") +
blank_theme() +
scale_color_discrete()
lda.plot
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt") +
blank_theme() +
theme(legend.position = "right")
lda.plot
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt") +
blank_theme() +
theme(legend.position = "right",
legend.background = "white")
lda.plot
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt") +
blank_theme() +
theme(legend.position = "right",
legend.background = element_blank())
lda.plot
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt") +
blank_theme() +
theme(legend.position = "right",
legend.background = element_blank(),
legend.box = element_blank())
lda.plot
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt") +
blank_theme() +
theme(legend.position = "right",
legend.background = element_blank())
lda.plot
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt") +
blank_theme() +
theme(legend.position = "right",
legend.background = element_blank())
lda.plot
lda.mod
lda.mod$svd
lda.mod$terms
lda.mod$lev
lda.mod$scaling
?lda
plot(can)
points(can$scores[,2], can$scores[,3], col = train.t$especie)
text(can$scores[,2], can$scores[,3], labels = rownames(paste(x1n[,1], sep = '')), cex=0.9, pos=3)
can$canrsq
can$eigenvalues
can
can$pct
can$term
can$structure
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt",
x = "LD1",
y = "LD2") +
blank_theme() +
theme(legend.position = "right",
legend.background = element_blank())
lda.plot
library(vegan)
df1 <- data.frame(long = c(3, 3.6, 6.5, 7.5, 15, 20), row.names = c("Tt", "Gg", "Gm", "Oo", "Mn", "Bp"))
dist.mat <- dist(df1, method = "euclidean")
hc.av <- hclust(dist.mat, method ="average")
library(ggplot2)
library(ggdendro)
ggdendrogram(hc.av, labels = T)
library(dendextend)
# Primero transformemos nuestro objeto a un dendrograma:
dend <- as.dendrogram(hc.av)
# Cambiemos el color a las ramas:
dend <- set(dend, "branches_k_color",
value = "deepskyblue4",
k = 1)
#dend <- set(dend, "branches_k_color",
#            value = c(rgb(0,118, 186, maxColorValue = 255),
#                      rgb(0, 123, 118, maxColorValue = 255),
#                      rgb(255, 147, 0, maxColorValue = 255),
#                      rgb(181, 23, 0, maxColorValue = 255)),
#            k = 4)
dend <- set(dend, "branches_lwd", 1)
# Cambiemos el color de las etiquetas:
dend <- set(dend, "labels_col",
value = c(rgb(0,118, 186, maxColorValue = 255),
rgb(0, 123, 118, maxColorValue = 255),
rgb(255, 147, 0, maxColorValue = 255),
rgb(181, 23, 0, maxColorValue = 255)),
k = 4)
# Graficador base de R:
plot(dend)
ggd1 <- as.ggdend(dend)
ggd1.plot <- ggplot(ggd1, offset_labels = -1, theme = blank_theme()) +
ylim(-2.4, max(get_branches_heights(dend))) +
scale_x_continuous(breaks = NULL) +
labs(title = "Dendrograma de especies de cetáceos",
subtitle = "Agrupamientos por longitud (método: promedio)",
x = element_blank(),
y = "Distancia euclidiana",
caption = "Datos de bit.ly/clust_medium")
ggd1.plot
clust.df <- read.table("cluster.txt", header = T, row.names = 1) # ¡OJO con row.names!
summary(clust.df)
mask <- colnames(clust.df)[colnames(clust.df) != "SST"]
clust.filt <- clust.df[,mask]
colnames(clust.filt)
clust.scale <- scale(clust.filt)
#clust.scale <- log(clust.filt +1) # Si de todos modos deseas aplicar una transformación para "normalizar" los datos.
summary(clust.scale)
dist.mv1 <- vegdist(clust.scale, method = "mahalanobis")
hc.mv1 <- hclust(dist.mv1, method ="ward.D2")
# Transformemos nuestro objeto a un dendrograma:
dend.mv1 <- as.dendrogram(hc.mv1)
# Cambiemos el color a las ramas:
dend.mv1 <- set(dend.mv1, "branches_k_color",
value = "deepskyblue4",
k = 1)
dend.mv1 <- set(dend.mv1, "branches_lwd", 0.7)
ggd1 <- as.ggdend(dend.mv1)
ggd1.plot <- ggplot(ggd1, offset_labels = -1, theme = blank_theme()) +
expand_limits(y = -2.4) +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = seq(0,max(get_branches_heights(dend.mv1)),2)) +
labs(title = "Dendrograma de sitios de muestreo",
subtitle = "Método de agrupamiento: Ward.D2)",
x = element_blank(),
y = "Distancia Mahalanobis",
caption = "Datos: clust.txt")
ggd1.plot
dist.mv2 <- vegdist(clust.scale, method = "euclidean")
hc.mv2 <- hclust(dist.mv2, method ="ward.D2")
# Transformemos nuestro objeto a un dendrograma:
dend.mv2 <- as.dendrogram(hc.mv2)
# Cambiemos el color a las ramas:
dend.mv2 <- set(dend.mv2, "branches_k_color",
value = "deepskyblue4",
k = 1)
dend.mv2 <- set(dend.mv2, "branches_lwd", 0.7)
ggd2 <- as.ggdend(dend.mv2)
ggd2.plot <- ggplot(ggd2, offset_labels = -1, theme = blank_theme()) +
expand_limits(y = -2.4) +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = seq(0,max(get_branches_heights(dend.mv2)),2)) +
labs(title = "Dendrograma de sitios de muestreo",
subtitle = "Método de agrupamiento: Ward.D2)",
x = element_blank(),
y = "Distancia Euclidiana",
caption = "Datos: clust.txt")
ggd2.plot
dist.mv3 <- vegdist(clust.scale, method = "manhattan")
hc.mv3 <- hclust(dist.mv3, method ="ward.D2")
# Transformemos nuestro objeto a un dendrograma:
dend.mv3 <- as.dendrogram(hc.mv3)
# Cambiemos el color a las ramas:
dend.mv3 <- set(dend.mv3, "branches_k_color",
value = "deepskyblue4",
k = 1)
dend.mv3 <- set(dend.mv3, "branches_lwd", 0.7)
ggd3 <- as.ggdend(dend.mv3)
ggd3.plot <- ggplot(ggd3, offset_labels = -1, theme = blank_theme()) +
expand_limits(y = -3.5) +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = seq(0,max(get_branches_heights(dend.mv3)),5)) +
labs(title = "Dendrograma de sitios de muestreo",
subtitle = "Método de agrupamiento: Ward.D2)",
x = element_blank(),
y = "Distancia Manhattan",
caption = "Datos: clust.txt")
ggd3.plot
library(NbClust)
res <- NbClust(clust.scale, diss = NULL, distance = "euclidean", method = "ward.D2", index = "all", max.nc = 8)
res$Best.partition
hc.e <- cluster::agnes(dist.mv2, diss = T, method = "ward")
ccc <- cophenetic(hc.e)
ccofen <- cor(dist.mv2, ccc)
ccofen
# Cambiamos el color de nuestr
dend.mv2 <- set(dend.mv2, "labels_col",
value = 1:3,
k = 3)
dend.mv2 <- set(dend.mv2, "branches_k_color",
value = 1:3,
k = 3)
dend.mv2 <- set(dend.mv2, "branches_lwd", 0.7)
ggd2 <- as.ggdend(dend.mv2)
ggd2.plot <- ggplot(ggd2, offset_labels = -1, theme = blank_theme()) +
expand_limits(y = -2.4) +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = seq(0,max(get_branches_heights(dend.mv2)),2)) +
labs(title = "Dendrograma de sitios de muestreo",
subtitle = "Método de agrupamiento: Ward.D2)",
x = element_blank(),
y = "Distancia Euclidiana",
caption = "Datos: clust.txt")
ggd2.plot
library(NbClust)
res <- NbClust(clust.scale, diss = NULL, distance = "euclidean", method = "ward.D2", index = "all", max.nc = 12)
library(NbClust)
res <- NbClust(clust.scale, diss = NULL, distance = "euclidean", method = "ward.D2", index = "all", max.nc = 8)
library(factoextra)
library(FactoMineR)
#Base de datos completa
x1n <- read.table('Medidas.txt', header = TRUE)
#Base de datos sin nombres de especies
x1 <- x1n[ ,2:length(x1n) ]
summary(x1)
res.pca <- FactoMineR::PCA(x1, graph = F, ncp = length(x1), scale.unit = T) #Aplicamos el ACP con los datos escalados y centrados
var <- get_pca_var(res.pca) # Extraemos las correlaciones de cada variable con cada componente principal
cors <- (round(abs(var$coord),2))
cors
fviz_pca_var(res.pca, col.var = "coord",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
library(corrplot)
corrplot(var$coord, is.corr = T)
sort(cors[,1], decreasing = T)[1:4]
sort(cors[,2], decreasing = T)[1:4]
fviz_pca_ind(res.pca,
geom.ind = "point", # Mostrar solo puntos (sin textos)
col.ind = x1n[,1], # Número de colores (grupos)
palette = c("#00AFBB", "#E7B800", "#FC4E07"), # Colores a utilizar
addEllipses = TRUE, # Elipses de concentración
legend.title = "Especies")
fviz_pca_biplot(res.pca,
col.ind = x1n$especie, palette = "jco",
addEllipses = TRUE, label = "var",
col.var = "black", repel = TRUE,
legend.title = "Especies")
eig.val <- get_eigenvalue(res.pca)
eig.val
fviz_eig(res.pca, addlabels = T)
#Kaisser-Guttman y Broken Stick
PCAs <- vegan::rda (x1, scale = T)
# Seleccionamos el marco de datos con los eigenvalores y corremos ambos análisis
ev <- PCAs$CA$eig
evplot(ev)
mnv <- manova(as.matrix(x1n[,-1]) ~ x1n$especie)
summary.manova(mnv,test="Wilks")
library(caTools)
library(caret)
set.seed(1111)
sample <- sample.split(x1n$especie, SplitRatio = .75)
train <- subset(x1n, sample == TRUE)
test <- subset(x1n, sample == FALSE)
pre.pars <- preProcess(train, method = c("center", "scale"))
train.t <- predict(pre.pars, train)
test.t <- predict(pre.pars, test)
mod <- lm(cbind(as.matrix(train.t[,2:32])) ~ train.t$especie)
library(candisc)
can <- candisc(mod)
summary(can)
correlacion <- cor(cbind(as.matrix(train.t[,2:32])),
can$scores[,2:3])
correlacion
plot(can)
points(can$scores[,2], can$scores[,3], col = train.t$especie)
text(can$scores[,2], can$scores[,3], labels = rownames(paste(x1n[,1], sep = '')), cex=0.9, pos=3)
library(MASS)
lda.mod <- lda(especie ~ ., data = train.t)
plot(lda.mod)
plot(lda.mod, dimen = 1, type = "both")
pred.clase <- predict(lda.mod, test.t)$class
p <- predict(lda.mod)$posterior
p.acom <- data.frame(especie = test.t$especie, id = rownames(test.t), p = p)
p.acom
jicuad <- chisq.test(test$especie, pred.clase, simulate.p.value = T)
jicuad
lda.data <- cbind(train.t, predict(lda.mod)$x)
lda.plot <- ggplot(lda.data, aes(LD1, LD2)) +
geom_point(aes(color = especie)) +
labs(title = "Gráfico de funciones discriminantes",
caption = "Datos: medidas.txt",
x = "LD1",
y = "LD2") +
blank_theme() +
theme(legend.position = "right",
legend.background = element_blank())
lda.plot
