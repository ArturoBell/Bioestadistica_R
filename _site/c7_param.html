<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="M. en C. Arturo Bell Enríquez García" />


<title>Técnicas Paramétricas</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Bioestadística con R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Temas
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Biología como Ciencia de Datos</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c1_Intro_R.html">Introducción a R</a>
        </li>
        <li>
          <a href="c2_ggplot2.html">ggplot2</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Herramientas Básicas</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c3_probabilidad.html">Probabilidad</a>
        </li>
        <li>
          <a href="c4_muestreo.html">Teoría del Muestreo</a>
        </li>
        <li>
          <a href="c5_descriptiva.html">Estadística Descriptiva</a>
        </li>
        <li>
          <a href="c6_ph0.html">Pruebas de hipótesis</a>
        </li>
        <li>
          <a href="c7_param.html">Técnicas Paramétricas</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Relaciones Lineales</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c8_rls.html">Modelo Lineal Simple</a>
        </li>
        <li>
          <a href="c9_glm.html">Modelos Lineales Generalizados</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">No Paramétrico y No Lineal</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c10_no_par.html">Técnicas No Paramétricas</a>
        </li>
        <li>
          <a href="c11_no_lineal.html">Modelos No Lineales</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Técnicas Multivariadas</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c11_intro_mv.html">Introducción</a>
        </li>
        <li>
          <a href="c12_no_sup.html">No supervisadas</a>
        </li>
        <li>
          <a href="c13_comps_mv.html">Comparaciones Multivariadas</a>
        </li>
        <li>
          <a href="c14_clasificacion.html">Clasificaciones</a>
        </li>
        <li>
          <a href="c15_regs_mv.html">Regresiones Múltiples</a>
        </li>
      </ul>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Técnicas Paramétricas</h1>
<h4 class="author">M. en C. Arturo Bell Enríquez García</h4>

</div>


<p><strong><a href="https://youtu.be/48BXaIKavBU">VIDEO</a></strong></p>
<div id="librerías" class="section level2">
<h2>Librerías</h2>
<pre class="r"><code>library(ggplot2)
library(corrplot)
library(gridExtra)
library(rstatix)
#library(car)
library(dplyr)
library(ggpubr)</code></pre>
</div>
<div id="teorema-del-límite-central" class="section level2">
<h2>Teorema del Límite Central</h2>
<p>“Dadas muestras aleatorias e independientes con N observaciones cada una, la distribución de sus medias se aproxima a una distribución normal conforme N incrementa, INDEPENDIENTEMENTE de la distribución poblacional”; es decir, mientras N sea grande, <span class="math inline">\(\bar{x} \sim Normal\)</span>. Para probar esto podemos hacer un ejercicio en el cual simulemos una población con distribución Gamma, cuya zona de mayor densidad se encuentra desplazada a la izquierda:</p>
<pre class="r"><code>set.seed(0)
datos &lt;- data.frame(x = 1:1000, y = rgamma(1000, 1))
gamma &lt;- ggplot(data = datos, aes(y)) + 
         geom_density(fill = rgb(118,78,144, maxColorValue = 255), alpha = 0.5, colour = &quot;white&quot;) +
         theme_bw() +
         labs(title = &quot;Distribución Gamma&quot;,
              x = element_blank(),
              y = element_blank()) +
         theme(text = element_text(colour = &quot;gray40&quot;))

#cairo_pdf(&quot;gamma.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
gamma</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>Con nuestra población definida, podemos seleccionar algunos tamaños de muestra, realizar 1000 muestreos aleatorios, obtener la media de cada muestreo y graficar su distribución. Primero para N = 3</p>
<pre class="r"><code>N = 3
medias &lt;- data.frame(x = 1:1000, y = replicate(1000, mean(sample(datos$y, N))))


dist_n3 &lt;- ggplot(data = medias, aes(y)) +
           geom_density(fill = &quot;dodgerblue4&quot;, alpha = 0.5, colour = &quot;white&quot;) +
           theme_bw() +
           labs(title = sprintf(&quot;Distribución muestreal con N = %d&quot;, N),
                x = element_blank(),
                y = element_blank()) +
           theme(text = element_text(colour = &quot;gray40&quot;))

#cairo_pdf(&quot;n_3.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
dist_n3</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>Ahora para N = 10. La distribución se aproxima más a una distribución normal.</p>
<pre class="r"><code>N = 10
medias &lt;- data.frame(x = 1:1000, y = replicate(1000, mean(sample(datos$y, N))))

dist_n10 &lt;- ggplot(data = medias, aes(y)) +
            geom_density(fill = &quot;dodgerblue4&quot;, alpha = 0.5, colour = &quot;white&quot;) +
            theme_bw() +
            labs(title = sprintf(&quot;Distribución muestreal con N = %d&quot;, N),
                 x = element_blank(),
                 y = element_blank()) +
            theme(text = element_text(colour = &quot;gray40&quot;))

#cairo_pdf(&quot;n_10.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
dist_n10</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>Con N = 30 la distribución es más cercana a una normal que a la gamma, por lo que usualmente se acepta que: con N≥30 la distribución muestreal de la media DEBERÁ ser normal:</p>
<pre class="r"><code>N = 30
medias &lt;- data.frame(x = 1:1000, y = replicate(1000, mean(sample(datos$y, N))))


dist_n30 &lt;- ggplot(data = medias, aes(y)) +
            geom_density(fill = &quot;dodgerblue4&quot;, alpha = 0.5, colour = &quot;white&quot;) +
            theme_bw() +
            labs(title = sprintf(&quot;Distribución muestreal con N = %d&quot;, N),
                 x = element_blank(),
                 y = element_blank()) +
            theme(text = element_text(colour = &quot;gray40&quot;))

#cairo_pdf(&quot;n_30.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
dist_n30</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>Para comprobar, hagámos el ejercicio con una distribución uniforme; es decir, en la cual todos los valores tienen la misma probabilidad de ser obtenidos (desviaciones debido al generador de números “aleatorios”):</p>
<pre class="r"><code>N = 30
datos &lt;- data.frame(x = 1:1000, y = runif(1000))
unif &lt;- ggplot(data = datos, aes(y)) + 
        geom_density(fill = rgb(118,78,144, maxColorValue = 255), alpha = 0.5, colour = &quot;white&quot;) +
        theme_bw() +
        labs(title = &quot;Distribución \&quot;uniforme\&quot;&quot;,
             x = element_blank(),
             y = element_blank()) +
        theme(text = element_text(colour = &quot;gray40&quot;))

#cairo_pdf(&quot;unif.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
unif</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<pre class="r"><code>medias &lt;- data.frame(x = 1:1000, y = replicate(1000, mean(sample(datos$y, N))))

dist_n30 &lt;- ggplot(data = medias, aes(y)) +
            geom_density(fill = &quot;dodgerblue4&quot;, alpha = 0.5, colour = &quot;white&quot;) +
            theme_bw() +
            labs(title = sprintf(&quot;Distribución muestreal con N = %d&quot;, N),
                 x = element_blank(),
                 y = element_blank()) +
            theme(text = element_text(colour = &quot;gray40&quot;))

#cairo_pdf(&quot;n_30u.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
dist_n30</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>Un aspecto importante a considerar es la “Primera Propiedad Conocida” de la distribución normal: <em>dadas muestras aleatorias e independientes con N observaciones cada una (tomadas de una distribución normal), la distribución de medias muestreales es normal e insesgada (i.e., centrada en la media poblacional), independientemente del tamaño de N</em>. Por lo tanto, aún un N de 1 debería dar una distribución parecida a la normal. Comprobemos:</p>
<pre class="r"><code>N = 1
datos &lt;- data.frame(x = 1:1000, y = rnorm(1000))
norm &lt;- ggplot(data = datos, aes(y)) + 
        geom_density(fill = rgb(118,78,144, maxColorValue = 255), alpha = 0.5, colour = &quot;white&quot;) +
        theme_bw() +
        labs(title = &quot;Distribución Normal&quot;,
             x = element_blank(),
             y = element_blank()) +
        theme(text = element_text(colour = &quot;gray40&quot;))

#cairo_pdf(&quot;norm.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
norm</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<pre class="r"><code>medias &lt;- data.frame(x = 1:1000, y = replicate(1000, mean(sample(datos$y, N))))

dist_n1 &lt;- ggplot(data = medias, aes(y)) +
           geom_density(fill = &quot;dodgerblue4&quot;, alpha = 0.5, colour = &quot;white&quot;) +
           theme_bw() +
           labs(title = sprintf(&quot;Distribución muestreal con N = %d&quot;, N),
                x = element_blank(),
                y = element_blank()) +
           theme(text = element_text(colour = &quot;gray40&quot;))

#cairo_pdf(&quot;n_1.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
dist_n1</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>La implicación de esta propiedad es que entre menos “normal” (en términos de su distribución estadística) sea nuestra población de estudio, necesitaremos un mayor tamaño de muestra para que nuestra distribución muestral de la media sea normal. El problema surge cuando nos debemos de enfrentar a tamaños de muestra pequeños (n &lt; 30). Aunque siempre podemos asumir (literalmente) que nuestra población se encuentra normalmente distribuida y “capitalizar en la robustez del modelo estadístico subyacente”, abusando del TLC, o reconocer que tamaños de muestra más pequeños nos pueden acercar lo suficiente (n &gt; 30 es para casos extremos). La tercera opción es la evaluación formal, la cual consiste en hacer una prueba de bondad de ajuste para conocer si nuestros datos se desvían o no de una distribución normal teórica. Antes de entrar a esos métodos, analicemos la prueba de bondad de ajuste más conocida: la prueba <span class="math inline">\(\chi^2\)</span> de independencia.</p>
</div>
<div id="pruebas-de-bondad-de-ajuste-chi2" class="section level2">
<h2>Pruebas de bondad de ajuste: <span class="math inline">\(\chi^2\)</span></h2>
<p>Esta prueba nos permite probar si la distribución de nuestros datos (frecuencias de variables nominales) son iguales a una distribución teórica. El ejemplo más sencillo lo tenemos al evaluar si la distribución de sexos en una población es diferente de 1:1. En este caso, la distribución de nuestros datos es binomial (dos categorías, verdadero/falso, éxito/fracaso, macho/hembra, etc.). En nuestro muestreo contamos 142 machos y 190 hembras. Coloquemos esos datos en un objeto y realicemos la prueba:</p>
<pre class="r"><code>sexos &lt;- c(machos = 142, hembras = 190)
sex_chi &lt;- chisq.test(sexos)
sex_chi</code></pre>
<pre><code>## 
##  Chi-squared test for given probabilities
## 
## data:  sexos
## X-squared = 6.9398, df = 1, p-value = 0.00843</code></pre>
<p>Veamos la distribución teórica gráficamente y veamos la ubicación del estadístico de prueba:</p>
<pre class="r"><code>chi_data &lt;- data.frame(x = rchisq(1000, 1))

chisq_plot &lt;- ggplot(data = chi_data, aes(x)) +
              geom_density(fill = rgb(118,78,144, maxColorValue = 255), alpha = 0.5, colour = &quot;white&quot;) +
              geom_vline(xintercept = sex_chi$statistic, color = &quot;firebrick&quot;) +
              annotate(geom = &quot;text&quot;, x = sex_chi$statistic+1.1, y = 1, label = sprintf(&quot;X^2 = %.2f&quot;, round(sex_chi$statistic, 2))) +
              theme_bw() +
              labs(title = sprintf(&quot;Distribución X^2 teórica (g.l = %d)&quot;, sex_chi$parameter),
                   x = element_blank(),
                   y = element_blank()) +
             theme(text = element_text(colour = &quot;gray40&quot;))
#cairo_pdf(&quot;chi_plot.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
chisq_plot</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>Partiendo del valor de p podemos concluir que la proporción fue diferente de nuestro modelo teórico 1:1, pero ¿qué pasa si nos interesara comprobar si es diferente a otra proporción, por ejemplo 40% machos y 60% hembras? En ese caso únicamente debemos de proporcionar un vector <code>p</code> en el cual establezcamos la probabilidad correspondiente a cada grupo:</p>
<pre class="r"><code>chisq.test(sexos, p = c(0.4, 0.6))</code></pre>
<pre><code>## 
##  Chi-squared test for given probabilities
## 
## data:  sexos
## X-squared = 1.0622, df = 1, p-value = 0.3027</code></pre>
<p>Aquí nuestros datos no ridiculizan a nuestra hipótesis de nulidad, por lo que no podemos rechazarla. Un ejemplo más complejo es el de la presentación, en donde tratamos de probar si el proceso de vacunación hizo alguna diferencia en el estado de salud de los empleados o, en otras palabras, ¿la incidencia de pneumonía fue la misma, INDEPENDIENTEMENTE de si los empleados se vacunaron o no? Al igual que en el caso anterior, coloquemos los datos en un objeto:</p>
<pre class="r"><code>vacunas &lt;- data.frame(no_vacuna = c(23, 8, 61), vacuna = c(5, 10, 77), row.names = c(&quot;neumococo&quot;, &quot;otra_neumonia&quot;, &quot;sin_neumonia&quot;))
vacunas</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["no_vacuna"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["vacuna"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"23","2":"5","_rn_":"neumococo"},{"1":"8","2":"10","_rn_":"otra_neumonia"},{"1":"61","2":"77","_rn_":"sin_neumonia"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Ahora apliquemos la prueba:</p>
<pre class="r"><code>vacs &lt;- chisq.test(vacunas)
vacs</code></pre>
<pre><code>## 
##  Pearson&#39;s Chi-squared test
## 
## data:  vacunas
## X-squared = 13.649, df = 2, p-value = 0.001087</code></pre>
<p>Como era de esperarse al ver las frecuencias, la incidencia de pneumonía aparentemente no fue la misma entre los empleados vacunados y los que no se vacunaron. En este caso, podemos extraer aún más información, tal y como la dependencia entre las variables. Para ello accederemos al atributo residuals de la salida de chisq.test, el cual representa los residuales de Pearson para cada celda:</p>
<pre class="r"><code>vacs$residuals</code></pre>
<pre><code>##                no_vacuna     vacuna
## neumococo      2.4053512 -2.4053512
## otra_neumonia -0.3333333  0.3333333
## sin_neumonia  -0.9630868  0.9630868</code></pre>
<p>Valores positivos muestran una asociación positiva entre las variables correspondientes; es decir, la incidencia de neumonía por neumococo aumentó (signo positivo) en aquellos empleados que no fueron vacunados y viceversa, valores negativos muestran una asociación negativa; es decir, la incidencia disminuyó en aquellos que sí fueron vacunados. Si nuestro interés fuera saber qué tanto contribuyó cada celda al valor de <span class="math inline">\(\chi^2\)</span> podemos elevar cada residual al cuadrado y dividirlo entre el valor de <span class="math inline">\(\chi^2\)</span> observado, tal que:</p>
<pre class="r"><code>contrib &lt;- 100*((vacs$residuals^2)/vacs$statistic)
contrib</code></pre>
<pre><code>##               no_vacuna    vacuna
## neumococo     42.390150 42.390150
## otra_neumonia  0.814077  0.814077
## sin_neumonia   6.795773  6.795773</code></pre>
<p>Evidentemente, los residuales más grandes tuvieron la mayor contribución que, en este caso, estuvo dada por la incidencia de neumonía por neumococo en ambos grupos. Podemos ver estos resultados de manera gráfica utilizando la librería corrplot:</p>
<pre class="r"><code>corrplot::corrplot(contrib, is.corr = F)</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>Ahora que tenemos una idea sobre cómo funcionan las pruebas de bondad de ajuste, podemos regresar a hablar sobre las pruebas de normalidad.</p>
<div id="supuesto-de-normalidad" class="section level3">
<h3>Supuesto de Normalidad</h3>
<p>Como imaginarás, las pruebas de normalidad son pruebas de bondad de ajuste en donde la distribución teórica es una distribución normal, aunque el modo en el cual se evalúan las desviaciones de la normalidad (<em>i.e.</em>, las diferencias) es diferente para cada prueba. Para aplicarlas, utilizaremos la base de datos de muestras independientes del archivo <code>datos_t</code>, particularmente la columna DC:</p>
<pre class="r"><code>dc &lt;- openxlsx::read.xlsx(&quot;data/datos_t.xlsx&quot;, sheet = 1)
dc</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["DC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["CH"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"48.2","2":"52.3","_rn_":"1"},{"1":"54.6","2":"57.4","_rn_":"2"},{"1":"58.3","2":"55.6","_rn_":"3"},{"1":"47.8","2":"53.2","_rn_":"4"},{"1":"51.4","2":"61.3","_rn_":"5"},{"1":"52.0","2":"58.0","_rn_":"6"},{"1":"55.2","2":"59.8","_rn_":"7"},{"1":"49.1","2":"54.8","_rn_":"8"},{"1":"49.9","2":"NA","_rn_":"9"},{"1":"52.6","2":"NA","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Podemos hacer una primera valoración utilizando un gráfico de densidad con un gráfico de densidad normal teórico superpuesto:</p>
<pre class="r"><code>set.seed(0)
norm_plot &lt;- ggplot(data = dc, aes(DC)) +
             geom_density(fill = rgb(118,78,144, maxColorValue = 255), colour = &quot;white&quot;, alpha = 0.5) +
             stat_function(fun = dnorm, n = 100, args = list(mean = mean(dc$DC), sd = sd(dc$DC))) +
             # Límites expandidos para visualizar el kde normal &quot;completo&quot;.
             #El kde observado se encuentra extendido más allá de los límites de los datos:
             xlim(c(40, 65)) + 
             theme_bw() +
             labs(title = &quot;Gráfico de densidad de DC (morado) vs. normal teórica (línea negra)&quot;,
                  x = element_blank(),
                  y = element_blank()) +
             theme(text = element_text(colour = &quot;gray40&quot;))

#cairo_pdf(&quot;norm_plot.pdf&quot;, height = 5, width = 5*1.6, pointsize = 20)
norm_plot</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>¿Qué opinas? Apliquemos ahora las pruebas de normalidad:</p>
<div id="prueba-de-shapiro-wilk" class="section level4">
<h4>Prueba de Shapiro-Wilk</h4>
<p>La prueba más conocida para evaluar la normalidad de un conjunto de datos es la prueba de Shapiro-Wilk. Su estadístico de prueba (W) se calcula de una manera poco amigable, pero conceptualmente implica ordenar los valores de la muestra y evaluar las desviaciones (diferencias) con respecto a la media, la varianza y su covarianza (este concepto se retoma más adelante) esperadas. En pocas palabras, la covarianza indica cuánto cambia una variable (la media) con respecto a otra (la varianza).</p>
<p>¿Qué tiene que ver la covarianza con el Supuesto de Normalidad? Tiene que ver con la Segunda Propiedad Conocida de la Distribución Normal, la cual establece que <em>Dadas observaciones aleatorias e independientes (de una distribución normal), la media muestral y la varianza muestral son independientes</em>. En otras palabras, cuando tomas una muestra y la usas para estimar tanto la media como la varianza de la población, qué tanto puedes equivocarte sobre la media es independiente de qué tanto puedes equivocarte sobre la varianza. Esta es una característica <strong>única</strong> de la distribución normal y es una de las razones por la que la prueba de S-W es de las más (por no decir la más) utilizada y recomendada, especialmente para muestras pequeñas. En algunos estudios de simulación como <a href="http://www.ukm.my/jsm/pdf_files/SM-PDF-40-6-2011/15%20NorAishah.pdf">este</a> ha demostrado ser más sensible a las desviaciones de la normalidad que la prueba de Kolmogorov-Smirnov, aunque antes de explicarla apliquemos la prueba de S-W:</p>
<pre class="r"><code>shapiro.test(dc$DC)</code></pre>
<pre><code>## 
##  Shapiro-Wilk normality test
## 
## data:  dc$DC
## W = 0.95125, p-value = 0.6833</code></pre>
<p>El valor de p no nos permite rechazar nuestra hipótesis de nulidad a un <span class="math inline">\(\alpha = 0.05\)</span>, por lo que podemos concluir que los datos se ajustan a una distribución normal. Vuelve al gráfico de densidad normal, ¿qué opinas?</p>
<p>Como añadido, visualicemos la segunda propiedad conocida de la distribución normal:</p>
<pre class="r"><code>means &lt;- NA
sds &lt;- NA

for (i in 1:1000) {
  norm_data &lt;- rnorm(10)
  means[i] &lt;- mean(norm_data)
  sds[i] &lt;- sd(norm_data)
}

mean_sd &lt;- data.frame(mean = means, sd = sds)

prop_2 &lt;- ggplot(data = mean_sd, aes(x = mean, y = sd)) +
          geom_point(color = &quot;dodgerblue4&quot;, size = 2, alpha = 0.5) +
          theme_bw() +
          labs(title = &quot;Segunda Propiedad Conocida de la Distribución Normal&quot;,
               subtitle = &quot;1000 muestreos de una población normal&quot;,
               x = &quot;Media&quot;,
               y = &quot;Desviación Estándar&quot;) +
          theme(text = element_text(colour = &quot;gray40&quot;))
#cairo_pdf(&quot;prop_2.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
prop_2</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>Con una distribución Gamma:</p>
<pre class="r"><code>means &lt;- NA
sds &lt;- NA

for (i in 1:1000) {
  gamma_data &lt;- rgamma(10, shape = 1)
  means[i] &lt;- mean(gamma_data)
  sds[i] &lt;- sd(gamma_data)
}

mean_sd &lt;- data.frame(mean = means, sd = sds)

prop_g &lt;- ggplot(data = mean_sd, aes(x = mean, y = sd)) +
          geom_point(color = &quot;dodgerblue4&quot;, size = 2, alpha = 0.5) +
          theme_bw() +
          labs(title = &quot;Segunda Propiedad Conocida de la Distribución Normal&quot;,
               subtitle = &quot;1000 muestreos de una población gamma&quot;,
               x = &quot;Media&quot;,
               y = &quot;Desviación Estándar&quot;) +
          theme(text = element_text(colour = &quot;gray40&quot;))

#cairo_pdf(&quot;prop_g.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
prop_g</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>Ejericio opcional: Realiza el mismo gráfico para la columna DC y para la columna CH.</p>
</div>
<div id="prueba-kolmogorov-smirnov" class="section level4">
<h4>Prueba Kolmogorov-Smirnov</h4>
<p>A diferencia de la prueba S-W, la prueba K-S compara las función de densidad acumulada empírica (observada) vs. una función de densidad acumulada teórica (no necesariamente normal), lo cual causa que sea sensible a desviaciones en el centro de la distribución pero no en las colas; sin embargo, es importante mencionar, que la prueba K-S es convergente; es decir, que conforme <span class="math inline">\(N \rightarrow \infty\)</span> la prueba converge a la “respuesta verdadera” en términos de probabilidad. Esta razón hace que esta prueba no se recomiende para tamaños de muestra pequeños. Para aplicarla:</p>
<pre class="r"><code>ks.test(dc$DC, &quot;pnorm&quot;)</code></pre>
<pre><code>## 
##  One-sample Kolmogorov-Smirnov test
## 
## data:  dc$DC
## D = 1, p-value &lt; 2.2e-16
## alternative hypothesis: two-sided</code></pre>
<p>A diferencia del caso anterior, esta prueba si tuvo evidencia suficiente para ridiculizar nuestra hipótesis nula, por lo que podemos concluir que nuestros datos no se ajustan a una distribución normal. Vuelve nuevamente al gráfico KDE. ¿Qué opinas?</p>
<p>Veamos las densidades acumuladas:</p>
<pre class="r"><code># Generamos una cdf normal teórica:
cdf &lt;- data.frame(norm = rnorm(1000, mean = mean(dc$DC), sd = sd(dc$DC)))
# Graficamos una vs. la otra:
cdfplot &lt;- ggplot(data = dc, aes(DC)) +
           stat_ecdf(geom = &quot;step&quot;, colour = rgb(118,78,144, maxColorValue = 255), alpha = 1) +
           stat_ecdf(data = cdf, aes(norm), geom = &quot;line&quot;, colour = &quot;black&quot;) +
           theme_bw() +
           labs(title = &quot;Densidades empírica (morado) y teórica (negro) Acumuladas para DC&quot;,
                x = element_blank(),
                y = element_blank())

#cairo_pdf(&quot;cdf.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
cdfplot</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>Conjuntando con el gráfico kde original podemos ver por qué la prueba K-S arrojó un resultado significativo, ya que hubo desviaciones importantes en la zona central. Interpretar correctamente un gráfico CDF NO es sencillo y requiere de experiencia, por lo que únicamente lo incluí para acompañar a la prueba que se basa en la densidad acumulada.</p>
<p>Habiendo explicado dos de las pruebas de normalidad más comunes, pasemos a los análisis paramétricos. El primero de ellos lo revisamos durante la clase de pruebas de hipótesis: la prueba t de Student, por lo que pasaremos directamente al Análisis de la Varianza.</p>
</div>
</div>
</div>
<div id="análisis-de-la-varianza" class="section level2">
<h2>Análisis de la Varianza</h2>
<p>En términos simples, podemos pensar en el ANOVA como una extensión de la prueba t-Student a más de dos grupos a comparar. Durante la clase de Comparaciones Multivariadas abordamos el riesgo que conlleva realizar múltiples pruebas de hipótesis (comparaciones) en nuestros datos; es decir, el problema de realizar dos o más comparaciones entre grupos como si se tratara de pruebas independientes. Por el momento, solo ten en mente que se incrementa la posibilidad de obtener un falso positivo únicamente por azar, por lo que hay que utilizar una técnica adecuada y es ahí donde entra el ANOVA o, mejor dicho, los ANOVAs. Como te imaginarás, estas pruebas nos permiten comparar medias entre más de dos grupos, aunque aquí la comparación se realiza de manera global y la hipótesis alternativa se expresa como “Al menos una de las medias es diferente”. Esto quiere decir que el ANOVA no nos dirá entre qué par(es) de grupos se encontraron las diferencias, sino que habrá que acompañarlo de una prueba post-hoc. Esta prueba es la prueba de diferencias honestas (HSD) de Tukey, la cual se encuentra basada en la distribución de los rangos estudentizados y fue diseñada para no incrementar la probabilidad de falsos positivos al realizar múltiples comparaciones. En esta sesión revisaremos tres modaliades de ANOVA: de una vía, de dos vías y factorial, de menor a mayor complejidad, aunque estos no son los únicos. Entre los demás diseños de ANOVA se encuentran el ANOVA de medidas repetidas (estudios de crecimiento en laboratorio con medidas intermedias entre el inicio y el final, por ejemplo) o el ANOVA anidado, en el cual el diseño es similar a una muñeca rusa.</p>
<p>Antes de aplicar y explicar los modelos de ANOVA, es necesario desarrollar una intuición sobre el procedimiento. El nombre “Análisis de Varianza” viene de que, literalmente, se utilizan las varianzas para comparar las medias. Aunque el proceso matemático implica calcular promedios de promedios, varias sumas de cuadrados y cuadrados medios del error, podemos resumirlo para fines prácticos en que la comparación se realiza mediante una razón/cociente, tal que:</p>
<p><span class="math display">\[F = \frac{\sigma^2_{entre}}{\sigma^2_{dentro}}\]</span></p>
<p>Sé que esto puede sonar muy poco intuitivo, pero si nos detenemos un poco a analizar la ecuación podemos darle mucho sentido. La varianza dentro de los grupos podemos considerarla como la varianza “promedio” de cada grupo (razón por la que es importante que estas sean homogéneas entre todos nuestros grupos), mientras que la varianza entre los grupos representa la “separación” (dispersión) entre los grupos (sin considerar el error). Partiendo de esto, es evidente que si la varianza entre grupos es muy grande en relación a la varianza dentro de los grupos podemos inferir que existe un efecto del factor de agrupamiento pues “no hay” (ojo a las comillas y los supuestos) otra forma de que las distribuciones de los grupos se desplacen.</p>
<p>Gráficamente la varianza dentro de los grupos se representaría de la siguiente manera:</p>
<pre class="r"><code>anov_sim &lt;- data.frame(grupo = as.factor(c(rep(&quot;A&quot;, 1000), rep(&quot;B&quot;, 1000))),
                       y = c(rnorm(1000, mean = 10, sd = 1), rnorm(1000, mean = 20, sd = 1)))

dentro_plot &lt;- ggplot(data = anov_sim, aes(y, fill = grupo, alpha = 0.5)) +
               geom_density(trim = T, show.legend = F, colour = &quot;white&quot;) +
               theme_minimal() +
               labs(title = &quot;Varianza dentro de los grupos&quot;,
                    x = element_blank(),
                    y = element_blank()) +
               scale_y_continuous(labels = NULL) +
               xlim(c(5, 25))
dentro_plot</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<p>Mientras que la varianza entre los grupos podemos, para fines de interpretación, visualizarla como la varianza dada por ambos grupos. En realidad esto representaría la varianza total y la varianza entre los grupos es el resultado de eliminar la varianza dada por el error, pero sigamos con el ejemplo:</p>
<pre class="r"><code>anov_sim$tot &lt;- rnorm(200, mean = 15, sd = sd(anov_sim$y))
entre_plot &lt;- ggplot(data = anov_sim, aes(tot)) + 
              geom_density(fill = &quot;dodgerblue4&quot;, alpha = 0.5, colour = &quot;white&quot;) +
              theme_minimal() +
              labs(title = &quot;Varianza entre los grupos&quot;,
                   x = element_blank(),
                   y = element_blank()) +
              scale_y_continuous(labels = NULL) +
              xlim(c(5, 25))
entre_plot</code></pre>
<pre><code>## Warning: Removed 90 rows containing non-finite values (stat_density).</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>Visualizándolas como si de un cociente se tratara es posible darse cuenta cómo la varianza “entre” los grupos es mucho mayor que la varianza dentro de los grupos, lo cual daría un valor de la razón de varianzas muy alto, sugiriendo un efecto del factor de agrupamiento.</p>
<pre class="r"><code>#cairo_pdf(&quot;anova_plot.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
gridExtra::grid.arrange(entre_plot, dentro_plot)</code></pre>
<pre><code>## Warning: Removed 90 rows containing non-finite values (stat_density).</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<p>Veamos qué pasa cuando las medias son más cercanas entre sí:</p>
<pre class="r"><code>anov_sim2 &lt;- data.frame(grupo = as.factor(c(rep(&quot;A&quot;, 1000), rep(&quot;B&quot;, 1000))),
                        y = c(rnorm(1000, mean = 10, sd = 1), rnorm(1000, mean = 11, sd = 1)))
anov_sim2$tot &lt;- rnorm(2000, mean(10.5), sd(anov_sim2$y))
dentro_plot2 &lt;- ggplot(data = anov_sim2, aes(y, fill = grupo, alpha = 0.5)) +
               geom_density(trim = T, show.legend = F, colour = &quot;white&quot;) +
               theme_minimal() +
               labs(title = &quot;Varianza dentro de los grupos&quot;,
                    x = element_blank(),
                    y = element_blank()) +
               scale_y_continuous(labels = NULL) +
               xlim(c(5, 15))
entre_plot2 &lt;- ggplot(data = anov_sim2, aes(tot)) + 
              geom_density(fill = &quot;dodgerblue4&quot;, alpha = 0.5, colour = &quot;white&quot;) +
              theme_minimal() +
              labs(title = &quot;Varianza entre los grupos&quot;,
                   x = element_blank(),
                   y = element_blank()) +
              scale_y_continuous(labels = NULL) +
              xlim(c(5, 15))
#cairo_pdf(&quot;anova_plot2.pdf&quot;, family = &quot;Montserrat&quot;, height = 5, width = 5*1.6, pointsize = 20)
gridExtra::grid.arrange(entre_plot2, dentro_plot2)</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<pre class="r"><code>#dev.off()</code></pre>
<div id="supuesto-de-homogeneidad-de-varianzas" class="section level3">
<h3>Supuesto de homogeneidad de Varianzas</h3>
<p>Como podrás imaginar, el que las varianzas de los grupos no sean homogéneas generará un sesgo al momento de calcular el cociente y, en consecuencia, el nivel de significancia de la prueba. Esto es lo que da origen al Supuesto de Homogeneidad de Varianzas. Existe una gran diversidad de pruebas, cada una con sus consideraciones, fortalezas y desventajas, pero analizaremos únicamente las (posiblemente) más conocidas.</p>
<div id="prueba-de-bartlett" class="section level4">
<h4>Prueba de Bartlett</h4>
<p>La prueba de Bartlett se considera como la prueba Uniformemente Más Poderosa; es decir, la que es menos propensa a cometer un falso negativo para cualquier valor de <span class="math inline">\(\alpha\)</span>. Este poder, sin embargo, tiene sus bemoles o su bemol, mejor dicho. Esta prueba se apoya TOTALMENTE en que la variable de interés en cada factor se encuentra normalmente distribuída (¡Hola de nuevo, Supuesto de Normalidad!). De violarse este supuesto el valor de <span class="math inline">\(\alpha_v\)</span> (verdadero) para la prueba puede ser mayor o menor al definido por nosotros (<span class="math inline">\(\alpha_n\)</span>, nominal). De manera particular, si la distribución de la variable analizada presenta una curtosis negativa el <span class="math inline">\(\alpha_v\)</span> será menor al nominal, mientras que con una curtosis positiva será el caso contrario. Esto lleva a que hagamos una prueba más o menos estricta de lo que habíamos planeado originalmente y que nuestros resultados no sean confiables. De cualquier manera, veamos cómo aplicarla:</p>
<pre class="r"><code>bartlett.test(y~grupo, data = anov_sim)</code></pre>
<pre><code>## 
##  Bartlett test of homogeneity of variances
## 
## data:  y by grupo
## Bartlett&#39;s K-squared = 0.4309, df = 1, p-value = 0.5115</code></pre>
<p>En este caso, no podemos ridiculizar nuestra hipótesis de nulidad, por lo que podemos concluir que las varianzas entre nuestros grupos son homogéneas (y deben serlo, pues así las especificamos).</p>
</div>
<div id="prueba-de-levene" class="section level4">
<h4>Prueba de Levene</h4>
<p>Es la alternativa recomendada por muchos a la prueba de Bartlett. Aunque no es tan poderosa, sí es robusta a las violaciones al supuesto de normalidad, de modo que el <span class="math inline">\(\alpha\)</span> verdadero es muy similar al nominal para una gran cantidad de distribuciones, aunque es insensible a distribuciones simétricas con colas altas como la t de Student o doble exponencial (también conocida como distribución de Laplace). Aplicarla también es sumamente sencillo:</p>
<pre class="r"><code>car::leveneTest(y~grupo, data = anov_sim)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Df"],"name":[1],"type":["int"],"align":["right"]},{"label":["F value"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Pr(>F)"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1.109031","3":"0.2924199","_rn_":"group"},{"1":"1998","2":"NA","3":"NA","_rn_":""}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Como era de esperarse, el resultado es consistente con la prueba de Bartlett para este caso.</p>
</div>
</div>
<div id="anova-de-una-sola-vía" class="section level3">
<h3>ANOVA de una sola vía</h3>
<p>Habiendo revisado los conceptos básicos detrás del ANOVA, podemos pasar a aplicar algunos modelos. El más sencillo es el ANOVA de una sola vía, el cual es el caso más sencillo; es decir, comparamos una sola variable numérica entre los niveles de un solo factor (pesos finales para tres alimentos distintos, por ejemplo). Para ejemplificarlo utilizaremos la base <code>datos1</code> que se trabajó para la tarea de Intervalos de confianza, con una columna extra: id, el cual es un identificador para cada individuo. Esta columna fue añadida únicamente para ejemplificar un caso de ANOVA posterior. En este ejemplo, compararemos los pesos totales entre los tres periodos (OJO: este es un diseño para un ANOVA factorial, únicamente lo utilizaremos como ejemplo).</p>
<p>El primer paso es, evidentemente, cargar la base de datos:</p>
<pre class="r"><code>df &lt;- read.table(&quot;data/Datos1.csv&quot;, header = F, skip = 1, sep = &quot;,&quot;)
colnames(df) &lt;- c(&quot;Dieta&quot;, &quot;Periodo&quot;, &quot;Rep&quot;, &quot;LT&quot;, &quot;PT&quot;, &quot;id&quot;)
df$Periodo &lt;- factor(df$Periodo, levels = c(&quot;I&quot;, &quot;M&quot;, &quot;F&quot;))
head(df)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Dieta"],"name":[1],"type":["chr"],"align":["left"]},{"label":["Periodo"],"name":[2],"type":["fct"],"align":["left"]},{"label":["Rep"],"name":[3],"type":["chr"],"align":["left"]},{"label":["LT"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["PT"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["id"],"name":[6],"type":["int"],"align":["right"]}],"data":[{"1":"A","2":"I","3":"A","4":"0.883","5":"0.50","6":"1","_rn_":"1"},{"1":"A","2":"I","3":"A","4":"0.909","5":"0.52","6":"2","_rn_":"2"},{"1":"A","2":"I","3":"A","4":"1.018","5":"0.58","6":"3","_rn_":"3"},{"1":"A","2":"I","3":"A","4":"0.909","5":"0.52","6":"4","_rn_":"4"},{"1":"A","2":"I","3":"A","4":"1.200","5":"0.68","6":"5","_rn_":"5"},{"1":"A","2":"I","3":"A","4":"0.891","5":"0.51","6":"6","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="comprobación-de-supuestos" class="section level4">
<h4>Comprobación de supuestos</h4>
<p>El segundo paso es la comprobación de supuestos. Primero el de Normalidad:</p>
<pre class="r"><code>#Normalidad
## Data.frame a llenar
norm &lt;- data.frame(grupo = NA, W = NA, p = NA)

## Niveles a probar:
lvls &lt;- levels(df$Periodo)

for (i in seq_along(lvls)) {
  temp &lt;- shapiro.test(df$PT[df$Periodo == lvls[i]])
  norm[i,] &lt;- c(lvls[i], temp$statistic, temp$p.value)
}
norm</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["grupo"],"name":[1],"type":["chr"],"align":["left"]},{"label":["W"],"name":[2],"type":["chr"],"align":["left"]},{"label":["p"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"I","2":"0.982542554966552","3":"0.54497164092451","_rn_":"1"},{"1":"M","2":"0.969626501609841","3":"0.203731304462396","_rn_":"2"},{"1":"F","2":"0.979597150613742","3":"0.589565206853954","_rn_":"3"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>La prueba de S-W sugiere que no hay desviaciones significativas de la normalidad. Corroboremos con un gráfico de violín. Al parecer, los resultados son coherentes con la distribución de los datos.</p>
<pre class="r"><code>ggplot(data = df, aes(x = Periodo, y = PT, fill = Periodo)) +
  geom_violin(alpha = 0.5, show.legend = F) +
  labs(title = &quot;Distribución de PT en los tres momentos de medición&quot;,
       x = element_blank(),
       y = element_blank()) +
  theme_bw()</code></pre>
<pre><code>## Warning: Removed 22 rows containing non-finite values (stat_ydensity).</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<p>Ahora el supuesto de igualdad de varianzas, utilizando la prueba de Levene. Podemos concluir que las varianzas no son homogéneas, por lo que la recomendación sería recurrir a una prueba no paramétrica; sin embargo, sigamos con el ejercicio y escalando la complejidad del análisis antes de saltar apresuradamente a conclusiones.</p>
<pre class="r"><code>car::leveneTest(PT~Periodo, data = df)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Df"],"name":[1],"type":["int"],"align":["right"]},{"label":["F value"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Pr(>F)"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"2","2":"14.53569","3":"1.637836e-06","_rn_":"group"},{"1":"155","2":"NA","3":"NA","_rn_":""}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="aplicación-del-anova" class="section level4">
<h4>Aplicación del ANOVA</h4>
<p>El siguiente paso es aplicar el ANOVA. El valor de p es bastante bajo, lo cual ridiculiza nuestra hipótesis de nulidad y concluimos que al menos un par de medias son significativamente diferentes entre sí (F(2, 155) = 574.3; p &lt; 0.0001).</p>
<pre class="r"><code>una_via &lt;- aov(PT~Periodo, data = df)
summary(una_via)</code></pre>
<pre><code>##              Df Sum Sq Mean Sq F value Pr(&gt;F)    
## Periodo       2 10.600   5.300   574.3 &lt;2e-16 ***
## Residuals   155  1.431   0.009                   
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 22 observations deleted due to missingness</code></pre>
</div>
<div id="prueba-post-hoc" class="section level4">
<h4>Prueba post-hoc</h4>
<p>El último paso es aplicar la prueba post-hoc. Esta prueba se construye a partir de la distribución de rangos estudentizados, y fue diseñada para evitar el conflicto entre el <span class="math inline">\(\alpha\)</span> y el número de comparaciones, por lo que la interpretación del valor de p es directa. En este caso, el valor de p fue muy pequeño para las tres comparaciones, por lo que rechazamos nuestra hipótesis de nulidad en los tres casos. El resto de la tabla es también informativo, pues nos indica la magnitud de las diferencias y sus intervalos de confianza (tal y como en la prueba t de Student):</p>
<pre class="r"><code>TukeyHSD(una_via)</code></pre>
<pre><code>##   Tukey multiple comparisons of means
##     95% family-wise confidence level
## 
## Fit: aov(formula = PT ~ Periodo, data = df)
## 
## $Periodo
##          diff       lwr       upr p adj
## M-I 0.2949615 0.2518882 0.3380349     0
## F-I 0.6376957 0.5931429 0.6822484     0
## F-M 0.3427341 0.2967181 0.3887501     0</code></pre>
<p>Con esos 4 pasos terminamos nuestro ANOVA de una vía. Pasemos entonces al ANOVA de dos vías.</p>
</div>
</div>
<div id="anova-de-dos-vías" class="section level3">
<h3>ANOVA de dos vías</h3>
<p>Si una vía es a un factor, dos vías es a dos factores. En este análisis compararemos el efecto de ambos factores simultáneamente, pero de manera independiente; es decir, aunque se hará la comparación para ambos, no se considerará la interacción entre ellos. Nuestro segundo factor será la Dieta. Los pasos son exactamente los mismos que en el anterior:</p>
<div id="comprobación-de-supuestos-1" class="section level4">
<h4>Comprobación de Supuestos</h4>
<p>Dado que ya comprobamos los supuestos para el factor Periodo, solo habrá que hacerlo para el factor Dieta:</p>
<pre class="r"><code>#Normalidad
df$Dieta &lt;- factor(df$Dieta, levels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;))
## Data.frame a llenar
norm &lt;- data.frame(grupo = NA, W = NA, p = NA)

## Niveles a probar:
lvls &lt;- levels(df$Dieta)

for (i in seq_along(lvls)) {
  temp &lt;- shapiro.test(df$PT[df$Dieta == lvls[i]])
  norm[i,] &lt;- c(lvls[i], temp$statistic, temp$p.value)
}
norm</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["grupo"],"name":[1],"type":["chr"],"align":["left"]},{"label":["W"],"name":[2],"type":["chr"],"align":["left"]},{"label":["p"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"A","2":"0.924872954092129","3":"0.00149640934002103","_rn_":"1"},{"1":"B","2":"0.959693445283575","3":"0.058721841724151","_rn_":"2"},{"1":"C","2":"0.928647969386013","3":"0.00937090708077498","_rn_":"3"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Debido a que el factor dieta incluye el efecto del periodo de medición y detectamos diferencias entre ellos, es esperable que no se cumpla el supuesto de normalidad. En este caso, el diseño sería mejor analizado utilizando un ANOVA factorial que uno de dos vías pero, al igual que en el caso anterior, seguiremos únicamente para fines ilustrativos.</p>
<p>Para la homogeneidad de varianzas la interpretación es la misma, aunque la consecuencia es la contraria. No violamos el supuesto de homogeneidad de varianzas debido a que tampoco se violó entre los periodos. Esto da un poco más de respaldo a seguir con el análisis, pues es más robusto a la violación del supuesto de normalidad que al de homogeneidad de varianzas.</p>
<pre class="r"><code>car::leveneTest(PT~Dieta, data = df)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Df"],"name":[1],"type":["int"],"align":["right"]},{"label":["F value"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Pr(>F)"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"2","2":"1.016406","3":"0.3642923","_rn_":"group"},{"1":"155","2":"NA","3":"NA","_rn_":""}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="aplicación-del-anova." class="section level4">
<h4>Aplicación del ANOVA.</h4>
<p>El ANOVA de dos vías es un caso especial del ANOVA factorial, en el cuál únicamente hay dos factores y NO se considera su interacción, por lo que el modo de declararlo es una fórmula en la cuál los factores se consideran de manera aditiva. La forma tradicional de reportar los resultados de este ANOVA sería: hubo un efecto significativo de las dietas (F(2, 153) = 11.45; p &lt; 0.0001) y de los periodos (F(2, 153) = 560.42; p &lt; 0.0001).</p>
<pre class="r"><code>dos_vias &lt;- aov(PT~Dieta+Periodo, data = df)
summary(dos_vias)</code></pre>
<pre><code>##              Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## Dieta         2  0.212   0.106   11.45 2.33e-05 ***
## Periodo       2 10.399   5.199  560.42  &lt; 2e-16 ***
## Residuals   153  1.419   0.009                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 22 observations deleted due to missingness</code></pre>
</div>
<div id="prueba-post-hoc." class="section level4">
<h4>Prueba post-hoc.</h4>
<p>En este caso tuvimos valores de p muy pequeños para ambos factores, realicemos la prueba HSD de Tukey. Al ver la salida puedes interpretar que esta es una lista, y que podríamos acceder a los resultados de cualquier factor utilizando el operador <code>$</code> (<code>TukeyHSD(aov_obj)$factor</code>). Aquí, las diferencias se encontraron entre la dieta C y las otras dos, pero no entre A y B.</p>
<pre class="r"><code>TukeyHSD(dos_vias)</code></pre>
<pre><code>##   Tukey multiple comparisons of means
##     95% family-wise confidence level
## 
## Fit: aov(formula = PT ~ Dieta + Periodo, data = df)
## 
## $Dieta
##            diff         lwr         upr     p adj
## B-A -0.02402094 -0.06672932  0.01868745 0.3801380
## C-A -0.09036834 -0.13594353 -0.04479315 0.0000176
## C-B -0.06634740 -0.11227232 -0.02042249 0.0023101
## 
## $Periodo
##          diff       lwr       upr p adj
## M-I 0.2912145 0.2480228 0.3344062     0
## F-I 0.6266462 0.5819709 0.6713214     0
## F-M 0.3354316 0.2892891 0.3815741     0</code></pre>
<p>Considerando el diseño factorial de la base de datos, ¿cómo interpretarías estos resultados? ¿podemos confiar en ellos? La respuesta que yo esperaría es que no, pues si el experimento fue bien diseñado al inicio todos los animales debían tener aproximadamente las mismas características y vimos tanto gráficamente como en ambos ANOVAs que hubo un crecimiento. Veamos qué pasa con las distribuciones utilizando un gráfico de interacción.</p>
<pre class="r"><code>ggplot(data = df, aes(x = Dieta, y = PT, fill = Periodo)) +
  geom_violin(alpha = 0.5, show.legend = T) +
  labs(title = &quot;Distribución de PT en los tres momentos de medición&quot;,
       x = element_blank(),
       y = element_blank()) +
  theme_bw()</code></pre>
<pre><code>## Warning: Removed 22 rows containing non-finite values (stat_ydensity).</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-41-1.png" width="672" /></p>
<p>Es evidente que en los tres tratamientos hubo un crecimiento, el cual además parece haber sido bastante similar. Este es un ejemplo del error de tipo III que mencionaba en la clase de pruebas de hipótesis: utilizar la matemática correcta para responder la pregunta equivocada. Veamos qué pasa si realizamos un ANOVA factorial.</p>
</div>
</div>
<div id="anova-factorial" class="section level3">
<h3>ANOVA factorial</h3>
<p>Como te podrás imaginar a partir de lo mencionado sobre el ANOVA de dos vías, este ANOVA es la versión más generalizada en la cual podemos utilzar más de dos factores y además analizar su interacción. Sigamos con la base anterior, en este caso considerando también el factor réplica:</p>
<pre class="r"><code>df$Rep &lt;- factor(df$Rep, levels = c(&quot;A&quot;, &quot;B&quot;))</code></pre>
<div id="comprobación-de-supuestos-2" class="section level4">
<h4>Comprobación de supuestos</h4>
<p>No hay sorpresas en ninguno de los dos casos, las interpretaciones de los resultados son las mismas que en el caso anterior; es decir, este NO es el modo correcto de comprobar la normalidad. Cuando hablemos del ANOVA de medidas repetidas veremos un ejemplo de cómo hacerlo de manera correcta (normalidad de un factor dados los niveles del otro factor).</p>
<pre class="r"><code>## Data.frame a llenar
norm &lt;- data.frame(grupo = NA, W = NA, p = NA)

## Niveles a probar:
lvls &lt;- levels(df$Rep)

for (i in seq_along(lvls)) {
  temp &lt;- shapiro.test(df$PT[df$Rep == lvls[i]])
  norm[i,] &lt;- c(lvls[i], temp$statistic, temp$p.value)
}
norm</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["grupo"],"name":[1],"type":["chr"],"align":["left"]},{"label":["W"],"name":[2],"type":["chr"],"align":["left"]},{"label":["p"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"A","2":"0.941613188003489","3":"0.0012766184500003","_rn_":"1"},{"1":"B","2":"0.931198033759898","3":"0.000367262220957672","_rn_":"2"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>car::leveneTest(PT~Rep, data = df)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Df"],"name":[1],"type":["int"],"align":["right"]},{"label":["F value"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Pr(>F)"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"0.1280073","3":"0.7209908","_rn_":"group"},{"1":"156","2":"NA","3":"NA","_rn_":""}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="aplicación-del-anova-1" class="section level4">
<h4>Aplicación del ANOVA</h4>
<p>La única diferencia con el caso anterior es que esta vez utilizaremos el operador <code>*</code> para añadir los nuevos términos, en vez de hacerlo de forma aditiva. Haciendo esto la tabla del ANOVA cambia, en donde primero aparece el efecto de cada factor analizado de manera independiete (como si hubieramos hecho un ANOVA de “tres vías”) y después los términos de interacción. La interacción entre dos factores representa un efecto combinado de los factores involucrados en la variable analizada; es decir, cuando hay interacción entre dos factores el efecto de uno “depende” del el nivel del otro.</p>
<pre class="r"><code>fact &lt;- aov(PT~Dieta*Periodo*Rep, data = df)
summary(fact)</code></pre>
<pre><code>##                    Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## Dieta               2  0.212   0.106  12.185 1.32e-05 ***
## Periodo             2 10.399   5.199 596.509  &lt; 2e-16 ***
## Rep                 1  0.060   0.060   6.874  0.00971 ** 
## Dieta:Periodo       4  0.053   0.013   1.522  0.19912    
## Dieta:Rep           2  0.001   0.000   0.038  0.96240    
## Periodo:Rep         2  0.048   0.024   2.755  0.06703 .  
## Dieta:Periodo:Rep   4  0.038   0.009   1.076  0.37066    
## Residuals         140  1.220   0.009                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 22 observations deleted due to missingness</code></pre>
</div>
<div id="prueba-post-hoc-1" class="section level4">
<h4>Prueba post-hoc</h4>
<p>En este caso el único término de interacción con resultados significativos es la interacción entre Periodo y Réplica (<code>Periodo:Rep</code>), lo cual indica que el comportamiento de los periodos fue diferente entre réplicas. Realicemos las pruebas post-hoc correspondientes. Aunque encontramos un efecto significativo de las réplicas, este factor únicamente tiene dos niveles, por lo que realizar la prueba post-hoc es ocioso y, por tanto, la realizaremos únicamente para Periodo:Rep. Nota que debido a la presencia del operador <code>:</code> en el nombre del término es necesario utilizar comillas para poder acceder a ese atributo:</p>
<pre class="r"><code>TukeyHSD(fact)$&quot;Periodo:Rep&quot;</code></pre>
<pre><code>##                diff         lwr         upr        p adj
## M:A-I:A  0.28301798  0.20959477  0.35644118 4.152234e-14
## F:A-I:A  0.66044327  0.58556599  0.73532054 1.265654e-14
## I:B-I:A -0.02480111 -0.09480740  0.04520517 9.092990e-01
## M:B-I:A  0.27169429  0.19681702  0.34657157 6.084022e-14
## F:B-I:A  0.55653205  0.47803934  0.63502476 1.265654e-14
## F:A-M:A  0.37742529  0.30254802  0.45230257 1.265654e-14
## I:B-M:A -0.30781909 -0.37782537 -0.23781281 1.376677e-14
## M:B-M:A -0.01132368 -0.08620096  0.06355359 9.979453e-01
## F:B-M:A  0.27351408  0.19502137  0.35200679 6.727952e-14
## I:B-F:A -0.68524438 -0.75677422 -0.61371454 1.265654e-14
## M:B-F:A -0.38874898 -0.46505261 -0.31244534 1.265654e-14
## F:B-F:A -0.10391121 -0.18376573 -0.02405669 3.335386e-03
## M:B-I:B  0.29649541  0.22496556  0.36802525 1.909584e-14
## F:B-I:B  0.58133317  0.50602701  0.65663933 1.265654e-14
## F:B-M:B  0.28483776  0.20498324  0.36469228 6.306067e-14</code></pre>
<p>Vemos que prácticamente todos los contrastes fueron significativos, con excepción del periodo inicial (p = 0.9). Esto sugeriría que el comportamiento de las réplicas no fue homogéneo a través del tiempo. Si regresamos brevemente a la tabla del ANOVA veremos que hubo 22 observaciones faltantes, las cuales corresponden a la mortalidad durante el experimento y podrían también explicar estos cambios. Debido a la impraciticidad/imposibilidad de marcar o identificar cada guppy no es posible aplicar un anova de medidas repetidas con estos datos; sin embargo, podemos ejemplificarlo con otros datos.</p>
</div>
</div>
<div id="anova-de-medidas-repetidas" class="section level3">
<h3>ANOVA de medidas repetidas</h3>
<p>El ANOVA de medidas repetidas es otro de los modelos de ANOVA, el cual podemos considerar como una extensión de la prueba t para muestras dependientes; es decir, en la cual los mismos individuos fueron medidos en más de dos ocasiones, denominado ANOVA de medidas repetidas de una vía. Si tenemos no solo los distintos tiempos de medición sino también factores adicionales entonces tendremos ANOVAs de medidas repetidas de dos vías (tiempo y un factor adicional) o de tres vías (tiempo y dos factores adicionales). Al igual que en el ANOVA “normal” comencemos desde abajo con el de una vía.</p>
<div id="anova-de-medidas-repetidas-de-una-vía" class="section level4">
<h4>ANOVA de medidas repetidas de una vía</h4>
<p>Carguemos los datos de ejemplo (selfesteem de la librería datarium), los cuales son una medida de autoestima medida en tres ocasiones distintas:</p>
<pre class="r"><code>data(&quot;selfesteem&quot;, package = &quot;datarium&quot;)
head(selfesteem)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["id"],"name":[1],"type":["int"],"align":["right"]},{"label":["t1"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["t2"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["t3"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"4.005027","3":"5.182286","4":"7.107831"},{"1":"2","2":"2.558124","3":"6.912915","4":"6.308434"},{"1":"3","2":"3.244241","3":"4.443434","4":"9.778410"},{"1":"4","2":"3.419538","3":"4.711696","4":"8.347124"},{"1":"5","2":"2.871243","3":"3.908429","4":"6.457287"},{"1":"6","2":"2.045868","3":"5.340549","4":"6.653224"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>La base se encuentra en formato corto, por lo que habrá que pasarla a formato largo:</p>
<pre class="r"><code>estima &lt;- reshape2::melt(selfesteem, # Datos a modificar
                         id.vars = &quot;id&quot;, # Identificador para cada individuo
                         measure.vars = c(&quot;t1&quot;, &quot;t2&quot;, &quot;t3&quot;), # Variables en columnas
                         variable.name = &quot;tiempo&quot;, # Nombre de la nueva variable de agrupamiento
                         value.name = &quot;estima&quot;) # Nombre de la nueva variable medida
head(estima)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["id"],"name":[1],"type":["int"],"align":["right"]},{"label":["tiempo"],"name":[2],"type":["fct"],"align":["left"]},{"label":["estima"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"t1","3":"4.005027","_rn_":"1"},{"1":"2","2":"t1","3":"2.558124","_rn_":"2"},{"1":"3","2":"t1","3":"3.244241","_rn_":"3"},{"1":"4","2":"t1","3":"3.419538","_rn_":"4"},{"1":"5","2":"t1","3":"2.871243","_rn_":"5"},{"1":"6","2":"t1","3":"2.045868","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="comprobación-de-supuestos-3" class="section level5">
<h5>Comprobación de supuestos</h5>
<p>Para agilizar las cosas (y un poco a mi pesar), utilicemos <code>dplyr</code> para aplicar la prueba de normalidad a los niveles de Periodo. <code>Tidyverse</code> es algo así como un dialecto dentro de R, compuesto de múltiples librerías, en donde el código se puede encadenar para hacerlo más compacto y, según algunos, más legible. “A mi pesar” porque no considero buena práctica didáctica enseñarlo a quienes van comenzando a adquirir experiencia, pues añade un paso más de abstracción al proceso. Habiendo dicho esto, el encadenamiento lo indicamos con el operador <code>%&gt;%</code> (pipe), y lo que hacemos es que lo que está a la izquierda se lo pasamos como argumento a lo que está a la derecha. Esto te sonará familiar a la forma de construir gráficos en <code>ggplot2</code> y con justa razón, pues también forma parte del <code>Tidiverse</code>. Como último comentario al respecto, las funciones de las distintas librerías de <code>Tidiverse</code> pueden utilizarse con la sintaxis de R “normal” y viceversa, las funciones de R “normal” pueden utilizarse con el operador de encadenamiento. Con esto quiero decir que no es necesario utilizar únicamente una u otra opción, sino que podemos aplicarlas a nuestra conveniencia (esa es la idea de escribir nuestro código ;)) Apliquemos entonces la prueba de Shapiro-Wilk a los datos agrupados:</p>
<pre class="r"><code># Toma el data.frame, agrúpalo por tiempo y para cada nivel aplica la función shapiro_test a la columna estima:
estima %&gt;% group_by(tiempo) %&gt;% shapiro_test(estima)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["tiempo"],"name":[1],"type":["fct"],"align":["left"]},{"label":["variable"],"name":[2],"type":["chr"],"align":["left"]},{"label":["statistic"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["p"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"t1","2":"estima","3":"0.9666901","4":"0.8585757"},{"1":"t2","2":"estima","3":"0.8758846","4":"0.1169956"},{"1":"t3","2":"estima","3":"0.9227150","4":"0.3801563"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Ahora la homocedasticidad o, mejor dicho, el supuesto de esfericidad. Este supuesto es una “extensión” del supuesto de homogeneidad de varianzas. Definimos esfericidad como la condición en la que las varianzas de las <strong>diferencias</strong> entre todas las combinaciones de los niveles de interés son iguales. La violación de este supuesto conlleva un incremento en la probabilidad de un falso positivo; es decir, vuelve a la prueba demasiado “liberal” o “crédula”. Aunque este supuesto es sumamente importante, no necesitamos probarlo directamente, pues la función con la que implementaremos el análisis hace la prueba correspondiente (prueba de Mauchly para esfericidad) y, además, aplica una corrección (corrección de Greenhouse-Geisser) a los grados de libertad de aquellos factores que violen el supuesto.</p>
</div>
<div id="aplicación-del-anova-2" class="section level5">
<h5>Aplicación del ANOVA</h5>
<p>Esta vez no utilizaremos la notación de fórmula ni tan siquiera la función aov, sino que recurriremos a la función <code>anova_test()</code> de la librería <code>rstatix</code> para hacer más intuitiva la declaración, donde <code>data</code> es el data.frame con los datos (dah!), <code>dv</code> es la variable dependiente; es decir, nuestra variable a comparar, <code>wid</code> es un identificador único para cada individuo y <code>within</code> el factor dentro del cual queremos hacer las comparaciones:</p>
<pre class="r"><code>anova_rep1 &lt;- rstatix::anova_test(data = estima, dv = estima, wid = id, within = tiempo)
get_anova_table(anova_rep1)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Effect"],"name":[1],"type":["chr"],"align":["left"]},{"label":["DFn"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["DFd"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["F"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["p"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["p<.05"],"name":[6],"type":["chr"],"align":["left"]},{"label":["ges"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"tiempo","2":"2","3":"18","4":"55.469","5":"2.01e-08","6":"*","7":"0.829","_rn_":"1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Lo primero que llama la atención es que la tabla de ANOVA reporta resultados para una prueba de tipo III. OJO! esto no tiene nada que ver con el error tipo III que mencioné en la clase de pruebas de hipótesis (ese error no es formal). El tipo de prueba hace referencia al tipo de ANOVA que se está realizando o, mejor dicho, al modo en el que se calculan las sumas de cuadrados. Si te interesa leer más al respecto, visita <a href="https://www.ibm.com/support/knowledgecenter/SSLVMB_24.0.0/spss/com%20mon/glm_general_factorial_sum_of_squares.html">este</a> o <a href="http://www.statsoft.com/textbook/">este</a> enlace.</p>
<p>Otra cosa que debe llamar tu atención es el término ges. Este es el factor de corrección de Greenhouse-Geisser a los grados de libertad. El modo de reportar estos resultados sería algo como <em>“las medidas de autoestima a través del tiempo fueron significativamente diferentes (F(2,18) = 55.5, p &lt; 0.0001; <span class="math inline">\(\eta^2\)</span> generalizado = 0.82)”</em>. El término <span class="math inline">\(\eta^2\)</span> generalizado lo puedes encontrar también como <span class="math inline">\(\hat{\epsilon}\)</span>.</p>
</div>
<div id="prueba-post-hoc-2" class="section level5">
<h5>Prueba post-hoc</h5>
<p>Debido a que las medidas son repetidas, no podemos aplicar la prueba de diferencias honestas de Tukey, pero sí podemos aplicar pruebas t de Student pareadas y corregir el valor de p con una corrección de Bonferroni. En la sección de multivariado se abordará esta corrección, pero entiéndela en este momento como el modo de evitar que incrementemos la probabilidad de un falso positivo y, en consecuencia, deberemos de interpretar los valores de la columna p.adj. Viendo la tabla, es posible concluir que hubo diferencias entre las medidas de autoestima en los tres periodos.</p>
<pre class="r"><code>pwt &lt;- pairwise_t_test(data = estima, estima~tiempo, paired = T, p.adjust.method = &quot;bonferroni&quot;)
pwt</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":[".y."],"name":[1],"type":["chr"],"align":["left"]},{"label":["group1"],"name":[2],"type":["chr"],"align":["left"]},{"label":["group2"],"name":[3],"type":["chr"],"align":["left"]},{"label":["n1"],"name":[4],"type":["int"],"align":["right"]},{"label":["n2"],"name":[5],"type":["int"],"align":["right"]},{"label":["statistic"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["df"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["p"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["p.adj"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["p.adj.signif"],"name":[10],"type":["chr"],"align":["left"]}],"data":[{"1":"estima","2":"t1","3":"t2","4":"10","5":"10","6":"-4.967618","7":"9","8":"7.72e-04","9":"2e-03","10":"**","_rn_":"1"},{"1":"estima","2":"t1","3":"t3","4":"10","5":"10","6":"-13.228148","7":"9","8":"3.34e-07","9":"1e-06","10":"****","_rn_":"2"},{"1":"estima","2":"t2","3":"t3","4":"10","5":"10","6":"-4.867816","7":"9","8":"8.86e-04","9":"3e-03","10":"**","_rn_":"3"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
</div>
<div id="anova-de-medidas-repetidas-de-dos-vías" class="section level4">
<h4>ANOVA de medidas repetidas de dos vías</h4>
<p>Al igual que en el ANOVA “normal”, hablamos de dos vías cuando tenemos dos factores, en este caso son el tiempo y alguno adicional. Para ejemplificarlo utilizaremos la base de datos <code>selfesteem2</code> de <code>datarium</code>.</p>
<pre class="r"><code>data(&quot;selfesteem2&quot;, package = &quot;datarium&quot;)
estima2 &lt;- reshape2::melt(selfesteem2, # Datos a modificar
                         id.vars = c(&quot;id&quot;, &quot;treatment&quot;), # Identificadores para cada individuo
                         measure.vars = c(&quot;t1&quot;, &quot;t2&quot;, &quot;t3&quot;), # Variables en columnas
                         variable.name = &quot;tiempo&quot;, # Nombre de la nueva variable de agrupamiento
                         value.name = &quot;estima&quot;) # Nombre de la nueva variable medida
head(estima2)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["id"],"name":[1],"type":["fct"],"align":["left"]},{"label":["treatment"],"name":[2],"type":["fct"],"align":["left"]},{"label":["tiempo"],"name":[3],"type":["fct"],"align":["left"]},{"label":["estima"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"ctr","3":"t1","4":"83","_rn_":"1"},{"1":"2","2":"ctr","3":"t1","4":"97","_rn_":"2"},{"1":"3","2":"ctr","3":"t1","4":"93","_rn_":"3"},{"1":"4","2":"ctr","3":"t1","4":"92","_rn_":"4"},{"1":"5","2":"ctr","3":"t1","4":"77","_rn_":"5"},{"1":"6","2":"ctr","3":"t1","4":"72","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="comprobación-de-supuestos-4" class="section level5">
<h5>Comprobación de supuestos</h5>
<p>Al igual que en el ANOVA de medidas repetidas, únicamente comprobaremos el Supuesto de Normalidad, solo que aquí lo haremos considerando la “anidación” de los factores; es decir, que las medidas repetidas fueron para cada tratamiento:</p>
<pre class="r"><code>estima2 %&gt;% group_by(treatment, tiempo) %&gt;% shapiro_test(estima)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["treatment"],"name":[1],"type":["fct"],"align":["left"]},{"label":["tiempo"],"name":[2],"type":["fct"],"align":["left"]},{"label":["variable"],"name":[3],"type":["chr"],"align":["left"]},{"label":["statistic"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["p"],"name":[5],"type":["dbl"],"align":["right"]}],"data":[{"1":"ctr","2":"t1","3":"estima","4":"0.8282109","5":"0.01996624"},{"1":"ctr","2":"t2","3":"estima","4":"0.8681048","5":"0.06183503"},{"1":"ctr","2":"t3","3":"estima","4":"0.8868127","5":"0.10720878"},{"1":"Diet","2":"t1","3":"estima","4":"0.9191145","5":"0.27866459"},{"1":"Diet","2":"t2","3":"estima","4":"0.9234678","5":"0.31596236"},{"1":"Diet","2":"t3","3":"estima","4":"0.8858129","5":"0.10407920"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Aparentemente hubo desviaciones de la normalidad en el t1 para el grupo control. Podemos corroborarlo con un gráfico QQ. Aparentemente es culpa de de algunos puntos ligeramente fuera del resto de la tendencia ubicados en el centro. Recordemos que el ANOVA es robusto a ciertas violaciones de la normalidad, y en este caso no parecen ser especialmente serias. Sigamos con el análisis.</p>
<pre class="r"><code>ggpubr::ggqqplot(estima2, &quot;estima&quot;, ggtheme = theme_bw()) + facet_grid(tiempo~treatment, labeller = &quot;label_both&quot;)</code></pre>
<p><img src="c7_param_files/figure-html/unnamed-chunk-54-1.png" width="420" /></p>
</div>
<div id="aplicación-del-anova-3" class="section level5">
<h5>Aplicación del ANOVA</h5>
<p>Utilizaremos la misma estructura que en el caso anterior; la unica diferencia es que al argumento <code>within</code> le pasaremos un vector con dos factores:</p>
<pre class="r"><code>anova_rep2 &lt;- anova_test(data = estima2, dv = estima, wid = id, within = c(treatment, tiempo))
get_anova_table(anova_rep2)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Effect"],"name":[1],"type":["chr"],"align":["left"]},{"label":["DFn"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["DFd"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["F"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["p"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["p<.05"],"name":[6],"type":["chr"],"align":["left"]},{"label":["ges"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"treatment","2":"1.00","3":"11.00","4":"15.541","5":"2.00e-03","6":"*","7":"0.059","_rn_":"1"},{"1":"tiempo","2":"1.31","3":"14.37","4":"27.369","5":"5.03e-05","6":"*","7":"0.049","_rn_":"2"},{"1":"treatment:tiempo","2":"2.00","3":"22.00","4":"30.424","5":"4.63e-07","6":"*","7":"0.050","_rn_":"3"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>De la tabla podemos concluir que todos los contrastes fueron significativos, lo cual indica que hubo diferencias entre los tratamientos (F(1, 11), = 15.5; p = 0.02), entre los tiempos (F(1.31, 14.37), = 27.4; p &lt; 0.0001) y tambien un efecto combinado (F(2,22) = 30.4; p &lt; 0.0001). Debido a que los efectos principales (“solos”) no son suficientes para describir los datos, el proceso post-hoc es un poco más complicado que en el caso anterior.</p>
</div>
<div id="pruebas-post-hoc" class="section level5">
<h5>Pruebas post-hoc</h5>
<p>Debido a la significancia del término de interacción es necesario descomponerlo en:</p>
<ol style="list-style-type: lower-alpha">
<li>Efecto principal simple; es decir, un modelo de una vía de la primera variable para cada nivel de la segunda. Debido a que hacerlo a mano es un poco tedioso, encadenemos el proceso:</li>
</ol>
<pre class="r"><code>anova_rep2_post1 &lt;- estima2 %&gt;%
                    group_by(tiempo) %&gt;% # Agrupa la base por cada nivel de tiempo
                    anova_test(dv = estima, wid = id, within = treatment) %&gt;% # Aplica un ANOVA de medidas repetidas para cada nivel
                    get_anova_table() %&gt;% # Extrae los resultados
                    adjust_pvalue(method = &quot;bonferroni&quot;) # Ajusta los valores de p

anova_rep2_post1</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["tiempo"],"name":[1],"type":["fct"],"align":["left"]},{"label":["Effect"],"name":[2],"type":["chr"],"align":["left"]},{"label":["DFn"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["DFd"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["F"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["p"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["p<.05"],"name":[7],"type":["chr"],"align":["left"]},{"label":["ges"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["p.adj"],"name":[9],"type":["dbl"],"align":["right"]}],"data":[{"1":"t1","2":"treatment","3":"1","4":"11","5":"0.376","6":"0.55200","7":"","8":"0.000767","9":"1.00000"},{"1":"t2","2":"treatment","3":"1","4":"11","5":"9.026","6":"0.01200","7":"*","8":"0.052000","9":"0.03600"},{"1":"t3","2":"treatment","3":"1","4":"11","5":"30.902","6":"0.00017","7":"*","8":"0.199000","9":"0.00051"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<ol start="2" style="list-style-type: lower-alpha">
<li>Aplicar una prueba t de Student para datos dependientes en los términos significativos. Debido a que tratamiento tiene solo dos niveles, realizar este proceso es redundante; de hecho, los valores de p serán iguales a los mostrados atrás; sin embargo, hagámoslo con fines demostrativos:</li>
</ol>
<pre class="r"><code>pwt_2 &lt;- estima2 %&gt;%
         group_by(tiempo) %&gt;%
         pairwise_t_test(estima~treatment, paired = T, p.adjust.method = &quot;bonferroni&quot;)
pwt_2</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["tiempo"],"name":[1],"type":["fct"],"align":["left"]},{"label":[".y."],"name":[2],"type":["chr"],"align":["left"]},{"label":["group1"],"name":[3],"type":["chr"],"align":["left"]},{"label":["group2"],"name":[4],"type":["chr"],"align":["left"]},{"label":["n1"],"name":[5],"type":["int"],"align":["right"]},{"label":["n2"],"name":[6],"type":["int"],"align":["right"]},{"label":["statistic"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["df"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["p"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["p.adj"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["p.adj.signif"],"name":[11],"type":["chr"],"align":["left"]}],"data":[{"1":"t1","2":"estima","3":"ctr","4":"Diet","5":"12","6":"12","7":"0.613349","8":"11","9":"0.55200","10":"0.55200","11":"ns","_rn_":"1"},{"1":"t2","2":"estima","3":"ctr","4":"Diet","5":"12","6":"12","7":"-3.004270","8":"11","9":"0.01200","10":"0.01200","11":"*","_rn_":"2"},{"1":"t3","2":"estima","3":"ctr","4":"Diet","5":"12","6":"12","7":"-5.558933","8":"11","9":"0.00017","10":"0.00017","11":"***","_rn_":"3"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Esto es todo para la clase de hoy. Es una clase bastante extensa y aún con ello se quedaron fuera algunas variantes de ANOVA; sin embargo, creo que estos cubren los casos más generales. ¡Nos vemos en la siguiente!</p>
</div>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiVMOpY25pY2FzIFBhcmFtw6l0cmljYXMiCmF1dGhvcjogIk0uIGVuIEMuIEFydHVybyBCZWxsIEVucsOtcXVleiBHYXJjw61hIgpvdXRwdXQ6CiAgICBodG1sX2RvY3VtZW50OgogICAgICBkZl9wcmludDogcGFnZWQKICAgICAgdGhlbWU6IGNvc21vCiAgICAgIHRvYzogVFJVRQogICAgICB0b2NfZmxvYXQ6IFRSVUUKICAgICAgY29kZV9kb3dubG9hZDogVFJVRQotLS0KCioqW1ZJREVPXShodHRwczovL3lvdXR1LmJlLzQ4QlhhSUthdkJVKSoqCgojIyBMaWJyZXLDrWFzCmBgYHtyfQpsaWJyYXJ5KGdncGxvdDIpCmxpYnJhcnkoY29ycnBsb3QpCmxpYnJhcnkoZ3JpZEV4dHJhKQpsaWJyYXJ5KHJzdGF0aXgpCiNsaWJyYXJ5KGNhcikKbGlicmFyeShkcGx5cikKbGlicmFyeShnZ3B1YnIpCmBgYAoKIyMgVGVvcmVtYSBkZWwgTMOtbWl0ZSBDZW50cmFsCgoiRGFkYXMgbXVlc3RyYXMgYWxlYXRvcmlhcyBlIGluZGVwZW5kaWVudGVzIGNvbiBOIG9ic2VydmFjaW9uZXMgY2FkYSB1bmEsIGxhIGRpc3RyaWJ1Y2nDs24gZGUgc3VzIG1lZGlhcyBzZSBhcHJveGltYSBhIHVuYSBkaXN0cmlidWNpw7NuIG5vcm1hbCBjb25mb3JtZSBOIGluY3JlbWVudGEsIElOREVQRU5ESUVOVEVNRU5URSBkZSBsYSBkaXN0cmlidWNpw7NuIHBvYmxhY2lvbmFsIjsgZXMgZGVjaXIsIG1pZW50cmFzIE4gc2VhIGdyYW5kZSwgJFxiYXJ7eH0gXHNpbSBOb3JtYWwkLiBQYXJhIHByb2JhciBlc3RvIHBvZGVtb3MgaGFjZXIgdW4gZWplcmNpY2lvIGVuIGVsIGN1YWwgc2ltdWxlbW9zIHVuYSBwb2JsYWNpw7NuIGNvbiBkaXN0cmlidWNpw7NuIEdhbW1hLCBjdXlhIHpvbmEgZGUgbWF5b3IgZGVuc2lkYWQgc2UgZW5jdWVudHJhIGRlc3BsYXphZGEgYSBsYSBpenF1aWVyZGE6CgpgYGB7cn0Kc2V0LnNlZWQoMCkKZGF0b3MgPC0gZGF0YS5mcmFtZSh4ID0gMToxMDAwLCB5ID0gcmdhbW1hKDEwMDAsIDEpKQpnYW1tYSA8LSBnZ3Bsb3QoZGF0YSA9IGRhdG9zLCBhZXMoeSkpICsgCiAgICAgICAgIGdlb21fZGVuc2l0eShmaWxsID0gcmdiKDExOCw3OCwxNDQsIG1heENvbG9yVmFsdWUgPSAyNTUpLCBhbHBoYSA9IDAuNSwgY29sb3VyID0gIndoaXRlIikgKwogICAgICAgICB0aGVtZV9idygpICsKICAgICAgICAgbGFicyh0aXRsZSA9ICJEaXN0cmlidWNpw7NuIEdhbW1hIiwKICAgICAgICAgICAgICB4ID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgIHkgPSBlbGVtZW50X2JsYW5rKCkpICsKICAgICAgICAgdGhlbWUodGV4dCA9IGVsZW1lbnRfdGV4dChjb2xvdXIgPSAiZ3JheTQwIikpCgojY2Fpcm9fcGRmKCJnYW1tYS5wZGYiLCBmYW1pbHkgPSAiTW9udHNlcnJhdCIsIGhlaWdodCA9IDUsIHdpZHRoID0gNSoxLjYsIHBvaW50c2l6ZSA9IDIwKQpnYW1tYQojZGV2Lm9mZigpCmBgYAoKQ29uIG51ZXN0cmEgcG9ibGFjacOzbiBkZWZpbmlkYSwgcG9kZW1vcyBzZWxlY2Npb25hciBhbGd1bm9zIHRhbWHDsW9zIGRlIG11ZXN0cmEsIHJlYWxpemFyIDEwMDAgbXVlc3RyZW9zIGFsZWF0b3Jpb3MsIG9idGVuZXIgbGEgbWVkaWEgZGUgY2FkYSBtdWVzdHJlbyB5IGdyYWZpY2FyIHN1IGRpc3RyaWJ1Y2nDs24uIFByaW1lcm8gcGFyYSBOID0gMwpgYGB7cn0KTiA9IDMKbWVkaWFzIDwtIGRhdGEuZnJhbWUoeCA9IDE6MTAwMCwgeSA9IHJlcGxpY2F0ZSgxMDAwLCBtZWFuKHNhbXBsZShkYXRvcyR5LCBOKSkpKQoKCmRpc3RfbjMgPC0gZ2dwbG90KGRhdGEgPSBtZWRpYXMsIGFlcyh5KSkgKwogICAgICAgICAgIGdlb21fZGVuc2l0eShmaWxsID0gImRvZGdlcmJsdWU0IiwgYWxwaGEgPSAwLjUsIGNvbG91ciA9ICJ3aGl0ZSIpICsKICAgICAgICAgICB0aGVtZV9idygpICsKICAgICAgICAgICBsYWJzKHRpdGxlID0gc3ByaW50ZigiRGlzdHJpYnVjacOzbiBtdWVzdHJlYWwgY29uIE4gPSAlZCIsIE4pLAogICAgICAgICAgICAgICAgeCA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgIHkgPSBlbGVtZW50X2JsYW5rKCkpICsKICAgICAgICAgICB0aGVtZSh0ZXh0ID0gZWxlbWVudF90ZXh0KGNvbG91ciA9ICJncmF5NDAiKSkKCiNjYWlyb19wZGYoIm5fMy5wZGYiLCBmYW1pbHkgPSAiTW9udHNlcnJhdCIsIGhlaWdodCA9IDUsIHdpZHRoID0gNSoxLjYsIHBvaW50c2l6ZSA9IDIwKQpkaXN0X24zCiNkZXYub2ZmKCkKYGBgCgpBaG9yYSBwYXJhIE4gPSAxMC4gTGEgZGlzdHJpYnVjacOzbiBzZSBhcHJveGltYSBtw6FzIGEgdW5hIGRpc3RyaWJ1Y2nDs24gbm9ybWFsLgpgYGB7cn0KTiA9IDEwCm1lZGlhcyA8LSBkYXRhLmZyYW1lKHggPSAxOjEwMDAsIHkgPSByZXBsaWNhdGUoMTAwMCwgbWVhbihzYW1wbGUoZGF0b3MkeSwgTikpKSkKCmRpc3RfbjEwIDwtIGdncGxvdChkYXRhID0gbWVkaWFzLCBhZXMoeSkpICsKICAgICAgICAgICAgZ2VvbV9kZW5zaXR5KGZpbGwgPSAiZG9kZ2VyYmx1ZTQiLCBhbHBoYSA9IDAuNSwgY29sb3VyID0gIndoaXRlIikgKwogICAgICAgICAgICB0aGVtZV9idygpICsKICAgICAgICAgICAgbGFicyh0aXRsZSA9IHNwcmludGYoIkRpc3RyaWJ1Y2nDs24gbXVlc3RyZWFsIGNvbiBOID0gJWQiLCBOKSwKICAgICAgICAgICAgICAgICB4ID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgIHkgPSBlbGVtZW50X2JsYW5rKCkpICsKICAgICAgICAgICAgdGhlbWUodGV4dCA9IGVsZW1lbnRfdGV4dChjb2xvdXIgPSAiZ3JheTQwIikpCgojY2Fpcm9fcGRmKCJuXzEwLnBkZiIsIGZhbWlseSA9ICJNb250c2VycmF0IiwgaGVpZ2h0ID0gNSwgd2lkdGggPSA1KjEuNiwgcG9pbnRzaXplID0gMjApCmRpc3RfbjEwCiNkZXYub2ZmKCkKYGBgCgpDb24gTiA9IDMwIGxhIGRpc3RyaWJ1Y2nDs24gZXMgbcOhcyBjZXJjYW5hIGEgdW5hIG5vcm1hbCBxdWUgYSBsYSBnYW1tYSwgcG9yIGxvIHF1ZSB1c3VhbG1lbnRlIHNlIGFjZXB0YSBxdWU6IGNvbiBO4omlMzAgbGEgZGlzdHJpYnVjacOzbiBtdWVzdHJlYWwgZGUgbGEgbWVkaWEgREVCRVLDgSBzZXIgbm9ybWFsOgpgYGB7cn0KTiA9IDMwCm1lZGlhcyA8LSBkYXRhLmZyYW1lKHggPSAxOjEwMDAsIHkgPSByZXBsaWNhdGUoMTAwMCwgbWVhbihzYW1wbGUoZGF0b3MkeSwgTikpKSkKCgpkaXN0X24zMCA8LSBnZ3Bsb3QoZGF0YSA9IG1lZGlhcywgYWVzKHkpKSArCiAgICAgICAgICAgIGdlb21fZGVuc2l0eShmaWxsID0gImRvZGdlcmJsdWU0IiwgYWxwaGEgPSAwLjUsIGNvbG91ciA9ICJ3aGl0ZSIpICsKICAgICAgICAgICAgdGhlbWVfYncoKSArCiAgICAgICAgICAgIGxhYnModGl0bGUgPSBzcHJpbnRmKCJEaXN0cmlidWNpw7NuIG11ZXN0cmVhbCBjb24gTiA9ICVkIiwgTiksCiAgICAgICAgICAgICAgICAgeCA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICB5ID0gZWxlbWVudF9ibGFuaygpKSArCiAgICAgICAgICAgIHRoZW1lKHRleHQgPSBlbGVtZW50X3RleHQoY29sb3VyID0gImdyYXk0MCIpKQoKI2NhaXJvX3BkZigibl8zMC5wZGYiLCBmYW1pbHkgPSAiTW9udHNlcnJhdCIsIGhlaWdodCA9IDUsIHdpZHRoID0gNSoxLjYsIHBvaW50c2l6ZSA9IDIwKQpkaXN0X24zMAojZGV2Lm9mZigpCmBgYAoKUGFyYSBjb21wcm9iYXIsIGhhZ8OhbW9zIGVsIGVqZXJjaWNpbyBjb24gdW5hIGRpc3RyaWJ1Y2nDs24gdW5pZm9ybWU7IGVzIGRlY2lyLCBlbiBsYSBjdWFsIHRvZG9zIGxvcyB2YWxvcmVzIHRpZW5lbiBsYSBtaXNtYSBwcm9iYWJpbGlkYWQgZGUgc2VyIG9idGVuaWRvcyAoZGVzdmlhY2lvbmVzIGRlYmlkbyBhbCBnZW5lcmFkb3IgZGUgbsO6bWVyb3MgImFsZWF0b3Jpb3MiKToKYGBge3J9Ck4gPSAzMApkYXRvcyA8LSBkYXRhLmZyYW1lKHggPSAxOjEwMDAsIHkgPSBydW5pZigxMDAwKSkKdW5pZiA8LSBnZ3Bsb3QoZGF0YSA9IGRhdG9zLCBhZXMoeSkpICsgCiAgICAgICAgZ2VvbV9kZW5zaXR5KGZpbGwgPSByZ2IoMTE4LDc4LDE0NCwgbWF4Q29sb3JWYWx1ZSA9IDI1NSksIGFscGhhID0gMC41LCBjb2xvdXIgPSAid2hpdGUiKSArCiAgICAgICAgdGhlbWVfYncoKSArCiAgICAgICAgbGFicyh0aXRsZSA9ICJEaXN0cmlidWNpw7NuIFwidW5pZm9ybWVcIiIsCiAgICAgICAgICAgICB4ID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgeSA9IGVsZW1lbnRfYmxhbmsoKSkgKwogICAgICAgIHRoZW1lKHRleHQgPSBlbGVtZW50X3RleHQoY29sb3VyID0gImdyYXk0MCIpKQoKI2NhaXJvX3BkZigidW5pZi5wZGYiLCBmYW1pbHkgPSAiTW9udHNlcnJhdCIsIGhlaWdodCA9IDUsIHdpZHRoID0gNSoxLjYsIHBvaW50c2l6ZSA9IDIwKQp1bmlmCiNkZXYub2ZmKCkKYGBgCgpgYGB7cn0KbWVkaWFzIDwtIGRhdGEuZnJhbWUoeCA9IDE6MTAwMCwgeSA9IHJlcGxpY2F0ZSgxMDAwLCBtZWFuKHNhbXBsZShkYXRvcyR5LCBOKSkpKQoKZGlzdF9uMzAgPC0gZ2dwbG90KGRhdGEgPSBtZWRpYXMsIGFlcyh5KSkgKwogICAgICAgICAgICBnZW9tX2RlbnNpdHkoZmlsbCA9ICJkb2RnZXJibHVlNCIsIGFscGhhID0gMC41LCBjb2xvdXIgPSAid2hpdGUiKSArCiAgICAgICAgICAgIHRoZW1lX2J3KCkgKwogICAgICAgICAgICBsYWJzKHRpdGxlID0gc3ByaW50ZigiRGlzdHJpYnVjacOzbiBtdWVzdHJlYWwgY29uIE4gPSAlZCIsIE4pLAogICAgICAgICAgICAgICAgIHggPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICAgICAgICAgICAgeSA9IGVsZW1lbnRfYmxhbmsoKSkgKwogICAgICAgICAgICB0aGVtZSh0ZXh0ID0gZWxlbWVudF90ZXh0KGNvbG91ciA9ICJncmF5NDAiKSkKCiNjYWlyb19wZGYoIm5fMzB1LnBkZiIsIGZhbWlseSA9ICJNb250c2VycmF0IiwgaGVpZ2h0ID0gNSwgd2lkdGggPSA1KjEuNiwgcG9pbnRzaXplID0gMjApCmRpc3RfbjMwCiNkZXYub2ZmKCkKYGBgCgpVbiBhc3BlY3RvIGltcG9ydGFudGUgYSBjb25zaWRlcmFyIGVzIGxhICJQcmltZXJhIFByb3BpZWRhZCBDb25vY2lkYSIgZGUgbGEgZGlzdHJpYnVjacOzbiBub3JtYWw6ICpkYWRhcyBtdWVzdHJhcyBhbGVhdG9yaWFzIGUgaW5kZXBlbmRpZW50ZXMgY29uIE4gb2JzZXJ2YWNpb25lcyBjYWRhIHVuYSAodG9tYWRhcyBkZSB1bmEgZGlzdHJpYnVjacOzbiBub3JtYWwpLCBsYSBkaXN0cmlidWNpw7NuIGRlIG1lZGlhcyBtdWVzdHJlYWxlcyBlcyBub3JtYWwgZSBpbnNlc2dhZGEgKGkuZS4sIGNlbnRyYWRhIGVuIGxhIG1lZGlhIHBvYmxhY2lvbmFsKSwgaW5kZXBlbmRpZW50ZW1lbnRlIGRlbCB0YW1hw7FvIGRlIE4qLiBQb3IgbG8gdGFudG8sIGHDum4gdW4gTiBkZSAxIGRlYmVyw61hIGRhciB1bmEgZGlzdHJpYnVjacOzbiBwYXJlY2lkYSBhIGxhIG5vcm1hbC4gQ29tcHJvYmVtb3M6CmBgYHtyfQpOID0gMQpkYXRvcyA8LSBkYXRhLmZyYW1lKHggPSAxOjEwMDAsIHkgPSBybm9ybSgxMDAwKSkKbm9ybSA8LSBnZ3Bsb3QoZGF0YSA9IGRhdG9zLCBhZXMoeSkpICsgCiAgICAgICAgZ2VvbV9kZW5zaXR5KGZpbGwgPSByZ2IoMTE4LDc4LDE0NCwgbWF4Q29sb3JWYWx1ZSA9IDI1NSksIGFscGhhID0gMC41LCBjb2xvdXIgPSAid2hpdGUiKSArCiAgICAgICAgdGhlbWVfYncoKSArCiAgICAgICAgbGFicyh0aXRsZSA9ICJEaXN0cmlidWNpw7NuIE5vcm1hbCIsCiAgICAgICAgICAgICB4ID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgeSA9IGVsZW1lbnRfYmxhbmsoKSkgKwogICAgICAgIHRoZW1lKHRleHQgPSBlbGVtZW50X3RleHQoY29sb3VyID0gImdyYXk0MCIpKQoKI2NhaXJvX3BkZigibm9ybS5wZGYiLCBmYW1pbHkgPSAiTW9udHNlcnJhdCIsIGhlaWdodCA9IDUsIHdpZHRoID0gNSoxLjYsIHBvaW50c2l6ZSA9IDIwKQpub3JtCiNkZXYub2ZmKCkKYGBgCmBgYHtyfQptZWRpYXMgPC0gZGF0YS5mcmFtZSh4ID0gMToxMDAwLCB5ID0gcmVwbGljYXRlKDEwMDAsIG1lYW4oc2FtcGxlKGRhdG9zJHksIE4pKSkpCgpkaXN0X24xIDwtIGdncGxvdChkYXRhID0gbWVkaWFzLCBhZXMoeSkpICsKICAgICAgICAgICBnZW9tX2RlbnNpdHkoZmlsbCA9ICJkb2RnZXJibHVlNCIsIGFscGhhID0gMC41LCBjb2xvdXIgPSAid2hpdGUiKSArCiAgICAgICAgICAgdGhlbWVfYncoKSArCiAgICAgICAgICAgbGFicyh0aXRsZSA9IHNwcmludGYoIkRpc3RyaWJ1Y2nDs24gbXVlc3RyZWFsIGNvbiBOID0gJWQiLCBOKSwKICAgICAgICAgICAgICAgIHggPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICAgICAgICAgICB5ID0gZWxlbWVudF9ibGFuaygpKSArCiAgICAgICAgICAgdGhlbWUodGV4dCA9IGVsZW1lbnRfdGV4dChjb2xvdXIgPSAiZ3JheTQwIikpCgojY2Fpcm9fcGRmKCJuXzEucGRmIiwgZmFtaWx5ID0gIk1vbnRzZXJyYXQiLCBoZWlnaHQgPSA1LCB3aWR0aCA9IDUqMS42LCBwb2ludHNpemUgPSAyMCkKZGlzdF9uMQojZGV2Lm9mZigpCmBgYAoKTGEgaW1wbGljYWNpw7NuIGRlIGVzdGEgcHJvcGllZGFkIGVzIHF1ZSBlbnRyZSBtZW5vcyAibm9ybWFsIiAoZW4gdMOpcm1pbm9zIGRlIHN1IGRpc3RyaWJ1Y2nDs24gZXN0YWTDrXN0aWNhKSBzZWEgbnVlc3RyYSBwb2JsYWNpw7NuIGRlIGVzdHVkaW8sIG5lY2VzaXRhcmVtb3MgdW4gbWF5b3IgdGFtYcOxbyBkZSBtdWVzdHJhIHBhcmEgcXVlIG51ZXN0cmEgZGlzdHJpYnVjacOzbiBtdWVzdHJhbCBkZSBsYSBtZWRpYSBzZWEgbm9ybWFsLiBFbCBwcm9ibGVtYSBzdXJnZSBjdWFuZG8gbm9zIGRlYmVtb3MgZGUgZW5mcmVudGFyIGEgdGFtYcOxb3MgZGUgbXVlc3RyYSBwZXF1ZcOxb3MgKG4gPCAzMCkuIEF1bnF1ZSBzaWVtcHJlIHBvZGVtb3MgYXN1bWlyIChsaXRlcmFsbWVudGUpIHF1ZSBudWVzdHJhIHBvYmxhY2nDs24gc2UgZW5jdWVudHJhIG5vcm1hbG1lbnRlIGRpc3RyaWJ1aWRhIHkgImNhcGl0YWxpemFyIGVuIGxhIHJvYnVzdGV6IGRlbCBtb2RlbG8gZXN0YWTDrXN0aWNvIHN1YnlhY2VudGUiLCBhYnVzYW5kbyBkZWwgVExDLCBvIHJlY29ub2NlciBxdWUgdGFtYcOxb3MgZGUgbXVlc3RyYSBtw6FzIHBlcXVlw7FvcyBub3MgcHVlZGVuIGFjZXJjYXIgbG8gc3VmaWNpZW50ZSAobiA+IDMwIGVzIHBhcmEgY2Fzb3MgZXh0cmVtb3MpLiBMYSB0ZXJjZXJhIG9wY2nDs24gZXMgbGEgZXZhbHVhY2nDs24gZm9ybWFsLCBsYSBjdWFsIGNvbnNpc3RlIGVuIGhhY2VyIHVuYSBwcnVlYmEgZGUgYm9uZGFkIGRlIGFqdXN0ZSBwYXJhIGNvbm9jZXIgc2kgbnVlc3Ryb3MgZGF0b3Mgc2UgZGVzdsOtYW4gbyBubyBkZSB1bmEgZGlzdHJpYnVjacOzbiBub3JtYWwgdGXDs3JpY2EuIEFudGVzIGRlIGVudHJhciBhIGVzb3MgbcOpdG9kb3MsIGFuYWxpY2Vtb3MgbGEgcHJ1ZWJhIGRlIGJvbmRhZCBkZSBhanVzdGUgbcOhcyBjb25vY2lkYTogbGEgcHJ1ZWJhICRcY2hpXjIkIGRlIGluZGVwZW5kZW5jaWEuCgojIyBQcnVlYmFzIGRlIGJvbmRhZCBkZSBhanVzdGU6ICRcY2hpXjIkCkVzdGEgcHJ1ZWJhIG5vcyBwZXJtaXRlIHByb2JhciBzaSBsYSBkaXN0cmlidWNpw7NuIGRlIG51ZXN0cm9zIGRhdG9zIChmcmVjdWVuY2lhcyBkZSB2YXJpYWJsZXMgbm9taW5hbGVzKSBzb24gaWd1YWxlcyBhIHVuYSBkaXN0cmlidWNpw7NuIHRlw7NyaWNhLiBFbCBlamVtcGxvIG3DoXMgc2VuY2lsbG8gbG8gdGVuZW1vcyBhbCBldmFsdWFyIHNpIGxhIGRpc3RyaWJ1Y2nDs24gZGUgc2V4b3MgZW4gdW5hIHBvYmxhY2nDs24gZXMgZGlmZXJlbnRlIGRlIDE6MS4gRW4gZXN0ZSBjYXNvLCBsYSBkaXN0cmlidWNpw7NuIGRlIG51ZXN0cm9zIGRhdG9zIGVzIGJpbm9taWFsIChkb3MgY2F0ZWdvcsOtYXMsIHZlcmRhZGVyby9mYWxzbywgw6l4aXRvL2ZyYWNhc28sIG1hY2hvL2hlbWJyYSwgZXRjLikuIEVuIG51ZXN0cm8gbXVlc3RyZW8gY29udGFtb3MgMTQyIG1hY2hvcyB5IDE5MCBoZW1icmFzLiBDb2xvcXVlbW9zIGVzb3MgZGF0b3MgZW4gdW4gb2JqZXRvIHkgcmVhbGljZW1vcyBsYSBwcnVlYmE6CgpgYGB7cn0Kc2V4b3MgPC0gYyhtYWNob3MgPSAxNDIsIGhlbWJyYXMgPSAxOTApCnNleF9jaGkgPC0gY2hpc3EudGVzdChzZXhvcykKc2V4X2NoaQpgYGAKVmVhbW9zIGxhIGRpc3RyaWJ1Y2nDs24gdGXDs3JpY2EgZ3LDoWZpY2FtZW50ZSB5IHZlYW1vcyBsYSB1YmljYWNpw7NuIGRlbCBlc3RhZMOtc3RpY28gZGUgcHJ1ZWJhOgpgYGB7cn0KY2hpX2RhdGEgPC0gZGF0YS5mcmFtZSh4ID0gcmNoaXNxKDEwMDAsIDEpKQoKY2hpc3FfcGxvdCA8LSBnZ3Bsb3QoZGF0YSA9IGNoaV9kYXRhLCBhZXMoeCkpICsKICAgICAgICAgICAgICBnZW9tX2RlbnNpdHkoZmlsbCA9IHJnYigxMTgsNzgsMTQ0LCBtYXhDb2xvclZhbHVlID0gMjU1KSwgYWxwaGEgPSAwLjUsIGNvbG91ciA9ICJ3aGl0ZSIpICsKICAgICAgICAgICAgICBnZW9tX3ZsaW5lKHhpbnRlcmNlcHQgPSBzZXhfY2hpJHN0YXRpc3RpYywgY29sb3IgPSAiZmlyZWJyaWNrIikgKwogICAgICAgICAgICAgIGFubm90YXRlKGdlb20gPSAidGV4dCIsIHggPSBzZXhfY2hpJHN0YXRpc3RpYysxLjEsIHkgPSAxLCBsYWJlbCA9IHNwcmludGYoIlheMiA9ICUuMmYiLCByb3VuZChzZXhfY2hpJHN0YXRpc3RpYywgMikpKSArCiAgICAgICAgICAgICAgdGhlbWVfYncoKSArCiAgICAgICAgICAgICAgbGFicyh0aXRsZSA9IHNwcmludGYoIkRpc3RyaWJ1Y2nDs24gWF4yIHRlw7NyaWNhIChnLmwgPSAlZCkiLCBzZXhfY2hpJHBhcmFtZXRlciksCiAgICAgICAgICAgICAgICAgICB4ID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgICAgeSA9IGVsZW1lbnRfYmxhbmsoKSkgKwogICAgICAgICAgICAgdGhlbWUodGV4dCA9IGVsZW1lbnRfdGV4dChjb2xvdXIgPSAiZ3JheTQwIikpCiNjYWlyb19wZGYoImNoaV9wbG90LnBkZiIsIGZhbWlseSA9ICJNb250c2VycmF0IiwgaGVpZ2h0ID0gNSwgd2lkdGggPSA1KjEuNiwgcG9pbnRzaXplID0gMjApCmNoaXNxX3Bsb3QKI2Rldi5vZmYoKQpgYGAKClBhcnRpZW5kbyBkZWwgdmFsb3IgZGUgcCBwb2RlbW9zIGNvbmNsdWlyIHF1ZSBsYSBwcm9wb3JjacOzbiBmdWUgZGlmZXJlbnRlIGRlIG51ZXN0cm8gbW9kZWxvIHRlw7NyaWNvIDE6MSwgcGVybyDCv3F1w6kgcGFzYSBzaSBub3MgaW50ZXJlc2FyYSBjb21wcm9iYXIgc2kgZXMgZGlmZXJlbnRlIGEgb3RyYSBwcm9wb3JjacOzbiwgcG9yIGVqZW1wbG8gNDAlIG1hY2hvcyB5IDYwJSBoZW1icmFzPyBFbiBlc2UgY2FzbyDDum5pY2FtZW50ZSBkZWJlbW9zIGRlIHByb3BvcmNpb25hciB1biB2ZWN0b3IgYHBgIGVuIGVsIGN1YWwgZXN0YWJsZXpjYW1vcyBsYSBwcm9iYWJpbGlkYWQgY29ycmVzcG9uZGllbnRlIGEgY2FkYSBncnVwbzoKYGBge3J9CmNoaXNxLnRlc3Qoc2V4b3MsIHAgPSBjKDAuNCwgMC42KSkKYGBgCgpBcXXDrSBudWVzdHJvcyBkYXRvcyBubyByaWRpY3VsaXphbiBhIG51ZXN0cmEgaGlww7N0ZXNpcyBkZSBudWxpZGFkLCBwb3IgbG8gcXVlIG5vIHBvZGVtb3MgcmVjaGF6YXJsYS4gVW4gZWplbXBsbyBtw6FzIGNvbXBsZWpvIGVzIGVsIGRlIGxhIHByZXNlbnRhY2nDs24sIGVuIGRvbmRlIHRyYXRhbW9zIGRlIHByb2JhciBzaSBlbCBwcm9jZXNvIGRlIHZhY3VuYWNpw7NuIGhpem8gYWxndW5hIGRpZmVyZW5jaWEgZW4gZWwgZXN0YWRvIGRlIHNhbHVkIGRlIGxvcyBlbXBsZWFkb3MgbywgZW4gb3RyYXMgcGFsYWJyYXMsIMK/bGEgaW5jaWRlbmNpYSBkZSBwbmV1bW9uw61hIGZ1ZSBsYSBtaXNtYSwgSU5ERVBFTkRJRU5URU1FTlRFIGRlIHNpIGxvcyBlbXBsZWFkb3Mgc2UgdmFjdW5hcm9uIG8gbm8/IEFsIGlndWFsIHF1ZSBlbiBlbCBjYXNvIGFudGVyaW9yLCBjb2xvcXVlbW9zIGxvcyBkYXRvcyBlbiB1biBvYmpldG86CgpgYGB7cn0KdmFjdW5hcyA8LSBkYXRhLmZyYW1lKG5vX3ZhY3VuYSA9IGMoMjMsIDgsIDYxKSwgdmFjdW5hID0gYyg1LCAxMCwgNzcpLCByb3cubmFtZXMgPSBjKCJuZXVtb2NvY28iLCAib3RyYV9uZXVtb25pYSIsICJzaW5fbmV1bW9uaWEiKSkKdmFjdW5hcwpgYGAKCkFob3JhIGFwbGlxdWVtb3MgbGEgcHJ1ZWJhOgoKYGBge3J9CnZhY3MgPC0gY2hpc3EudGVzdCh2YWN1bmFzKQp2YWNzCmBgYAoKQ29tbyBlcmEgZGUgZXNwZXJhcnNlIGFsIHZlciBsYXMgZnJlY3VlbmNpYXMsIGxhIGluY2lkZW5jaWEgZGUgcG5ldW1vbsOtYSBhcGFyZW50ZW1lbnRlIG5vIGZ1ZSBsYSBtaXNtYSBlbnRyZSBsb3MgZW1wbGVhZG9zIHZhY3VuYWRvcyB5IGxvcyBxdWUgbm8gc2UgdmFjdW5hcm9uLiBFbiBlc3RlIGNhc28sIHBvZGVtb3MgZXh0cmFlciBhw7puIG3DoXMgaW5mb3JtYWNpw7NuLCB0YWwgeSBjb21vIGxhIGRlcGVuZGVuY2lhIGVudHJlIGxhcyB2YXJpYWJsZXMuIFBhcmEgZWxsbyBhY2NlZGVyZW1vcyBhbCBhdHJpYnV0byByZXNpZHVhbHMgZGUgbGEgc2FsaWRhIGRlIGNoaXNxLnRlc3QsIGVsIGN1YWwgcmVwcmVzZW50YSBsb3MgcmVzaWR1YWxlcyBkZSBQZWFyc29uIHBhcmEgY2FkYSBjZWxkYToKYGBge3J9CnZhY3MkcmVzaWR1YWxzCmBgYAoKVmFsb3JlcyBwb3NpdGl2b3MgbXVlc3RyYW4gdW5hIGFzb2NpYWNpw7NuIHBvc2l0aXZhIGVudHJlIGxhcyB2YXJpYWJsZXMgY29ycmVzcG9uZGllbnRlczsgZXMgZGVjaXIsIGxhIGluY2lkZW5jaWEgZGUgbmV1bW9uw61hIHBvciBuZXVtb2NvY28gYXVtZW50w7MgKHNpZ25vIHBvc2l0aXZvKSBlbiBhcXVlbGxvcyBlbXBsZWFkb3MgcXVlIG5vIGZ1ZXJvbiB2YWN1bmFkb3MgeSB2aWNldmVyc2EsIHZhbG9yZXMgbmVnYXRpdm9zIG11ZXN0cmFuIHVuYSBhc29jaWFjacOzbiBuZWdhdGl2YTsgZXMgZGVjaXIsIGxhIGluY2lkZW5jaWEgZGlzbWludXnDsyBlbiBhcXVlbGxvcyBxdWUgc8OtIGZ1ZXJvbiB2YWN1bmFkb3MuIFNpIG51ZXN0cm8gaW50ZXLDqXMgZnVlcmEgc2FiZXIgcXXDqSB0YW50byBjb250cmlidXnDsyBjYWRhIGNlbGRhIGFsIHZhbG9yIGRlICRcY2hpXjIkIHBvZGVtb3MgZWxldmFyIGNhZGEgcmVzaWR1YWwgYWwgY3VhZHJhZG8geSBkaXZpZGlybG8gZW50cmUgZWwgdmFsb3IgZGUgJFxjaGleMiQgb2JzZXJ2YWRvLCB0YWwgcXVlOgpgYGB7cn0KY29udHJpYiA8LSAxMDAqKCh2YWNzJHJlc2lkdWFsc14yKS92YWNzJHN0YXRpc3RpYykKY29udHJpYgpgYGAKCkV2aWRlbnRlbWVudGUsIGxvcyByZXNpZHVhbGVzIG3DoXMgZ3JhbmRlcyB0dXZpZXJvbiBsYSBtYXlvciBjb250cmlidWNpw7NuIHF1ZSwgZW4gZXN0ZSBjYXNvLCBlc3R1dm8gZGFkYSBwb3IgbGEgaW5jaWRlbmNpYSBkZSBuZXVtb27DrWEgcG9yIG5ldW1vY29jbyBlbiBhbWJvcyBncnVwb3MuIFBvZGVtb3MgdmVyIGVzdG9zIHJlc3VsdGFkb3MgZGUgbWFuZXJhIGdyw6FmaWNhIHV0aWxpemFuZG8gbGEgbGlicmVyw61hIGNvcnJwbG90OgoKYGBge3J9CmNvcnJwbG90Ojpjb3JycGxvdChjb250cmliLCBpcy5jb3JyID0gRikKYGBgCgpBaG9yYSBxdWUgdGVuZW1vcyB1bmEgaWRlYSBzb2JyZSBjw7NtbyBmdW5jaW9uYW4gbGFzIHBydWViYXMgZGUgYm9uZGFkIGRlIGFqdXN0ZSwgcG9kZW1vcyByZWdyZXNhciBhIGhhYmxhciBzb2JyZSBsYXMgcHJ1ZWJhcyBkZSBub3JtYWxpZGFkLgoKIyMjIFN1cHVlc3RvIGRlIE5vcm1hbGlkYWQKQ29tbyBpbWFnaW5hcsOhcywgbGFzIHBydWViYXMgZGUgbm9ybWFsaWRhZCBzb24gcHJ1ZWJhcyBkZSBib25kYWQgZGUgYWp1c3RlIGVuIGRvbmRlIGxhIGRpc3RyaWJ1Y2nDs24gdGXDs3JpY2EgZXMgdW5hIGRpc3RyaWJ1Y2nDs24gbm9ybWFsLCBhdW5xdWUgZWwgbW9kbyBlbiBlbCBjdWFsIHNlIGV2YWzDumFuIGxhcyBkZXN2aWFjaW9uZXMgZGUgbGEgbm9ybWFsaWRhZCAoKmkuZS4qLCBsYXMgZGlmZXJlbmNpYXMpIGVzIGRpZmVyZW50ZSBwYXJhIGNhZGEgcHJ1ZWJhLiBQYXJhIGFwbGljYXJsYXMsIHV0aWxpemFyZW1vcyBsYSBiYXNlIGRlIGRhdG9zIGRlIG11ZXN0cmFzIGluZGVwZW5kaWVudGVzIGRlbCBhcmNoaXZvIGBkYXRvc190YCwgcGFydGljdWxhcm1lbnRlIGxhIGNvbHVtbmEgREM6CgpgYGB7cn0KZGMgPC0gb3Blbnhsc3g6OnJlYWQueGxzeCgiZGF0YS9kYXRvc190Lnhsc3giLCBzaGVldCA9IDEpCmRjCmBgYAoKUG9kZW1vcyBoYWNlciB1bmEgcHJpbWVyYSB2YWxvcmFjacOzbiB1dGlsaXphbmRvIHVuIGdyw6FmaWNvIGRlIGRlbnNpZGFkIGNvbiB1biBncsOhZmljbyBkZSBkZW5zaWRhZCBub3JtYWwgdGXDs3JpY28gc3VwZXJwdWVzdG86CmBgYHtyfQpzZXQuc2VlZCgwKQpub3JtX3Bsb3QgPC0gZ2dwbG90KGRhdGEgPSBkYywgYWVzKERDKSkgKwogICAgICAgICAgICAgZ2VvbV9kZW5zaXR5KGZpbGwgPSByZ2IoMTE4LDc4LDE0NCwgbWF4Q29sb3JWYWx1ZSA9IDI1NSksIGNvbG91ciA9ICJ3aGl0ZSIsIGFscGhhID0gMC41KSArCiAgICAgICAgICAgICBzdGF0X2Z1bmN0aW9uKGZ1biA9IGRub3JtLCBuID0gMTAwLCBhcmdzID0gbGlzdChtZWFuID0gbWVhbihkYyREQyksIHNkID0gc2QoZGMkREMpKSkgKwogICAgICAgICAgICAgIyBMw61taXRlcyBleHBhbmRpZG9zIHBhcmEgdmlzdWFsaXphciBlbCBrZGUgbm9ybWFsICJjb21wbGV0byIuCiAgICAgICAgICAgICAjRWwga2RlIG9ic2VydmFkbyBzZSBlbmN1ZW50cmEgZXh0ZW5kaWRvIG3DoXMgYWxsw6EgZGUgbG9zIGzDrW1pdGVzIGRlIGxvcyBkYXRvczoKICAgICAgICAgICAgIHhsaW0oYyg0MCwgNjUpKSArIAogICAgICAgICAgICAgdGhlbWVfYncoKSArCiAgICAgICAgICAgICBsYWJzKHRpdGxlID0gIkdyw6FmaWNvIGRlIGRlbnNpZGFkIGRlIERDIChtb3JhZG8pIHZzLiBub3JtYWwgdGXDs3JpY2EgKGzDrW5lYSBuZWdyYSkiLAogICAgICAgICAgICAgICAgICB4ID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgICB5ID0gZWxlbWVudF9ibGFuaygpKSArCiAgICAgICAgICAgICB0aGVtZSh0ZXh0ID0gZWxlbWVudF90ZXh0KGNvbG91ciA9ICJncmF5NDAiKSkKCiNjYWlyb19wZGYoIm5vcm1fcGxvdC5wZGYiLCBoZWlnaHQgPSA1LCB3aWR0aCA9IDUqMS42LCBwb2ludHNpemUgPSAyMCkKbm9ybV9wbG90CiNkZXYub2ZmKCkKYGBgCgrCv1F1w6kgb3BpbmFzPyBBcGxpcXVlbW9zIGFob3JhIGxhcyBwcnVlYmFzIGRlIG5vcm1hbGlkYWQ6CgojIyMjIFBydWViYSBkZSBTaGFwaXJvLVdpbGsKTGEgcHJ1ZWJhIG3DoXMgY29ub2NpZGEgcGFyYSBldmFsdWFyIGxhIG5vcm1hbGlkYWQgZGUgdW4gY29uanVudG8gZGUgZGF0b3MgZXMgbGEgcHJ1ZWJhIGRlIFNoYXBpcm8tV2lsay4gU3UgZXN0YWTDrXN0aWNvIGRlIHBydWViYSAoVykgc2UgY2FsY3VsYSBkZSB1bmEgbWFuZXJhIHBvY28gYW1pZ2FibGUsIHBlcm8gY29uY2VwdHVhbG1lbnRlIGltcGxpY2Egb3JkZW5hciBsb3MgdmFsb3JlcyBkZSBsYSBtdWVzdHJhIHkgZXZhbHVhciBsYXMgZGVzdmlhY2lvbmVzIChkaWZlcmVuY2lhcykgY29uIHJlc3BlY3RvIGEgbGEgbWVkaWEsIGxhIHZhcmlhbnphIHkgc3UgY292YXJpYW56YSAoZXN0ZSBjb25jZXB0byBzZSByZXRvbWEgbcOhcyBhZGVsYW50ZSkgZXNwZXJhZGFzLiBFbiBwb2NhcyBwYWxhYnJhcywgbGEgY292YXJpYW56YSBpbmRpY2EgY3XDoW50byBjYW1iaWEgdW5hIHZhcmlhYmxlIChsYSBtZWRpYSkgY29uIHJlc3BlY3RvIGEgb3RyYSAobGEgdmFyaWFuemEpLiAKCsK/UXXDqSB0aWVuZSBxdWUgdmVyIGxhIGNvdmFyaWFuemEgY29uIGVsIFN1cHVlc3RvIGRlIE5vcm1hbGlkYWQ/IFRpZW5lIHF1ZSB2ZXIgY29uIGxhIFNlZ3VuZGEgUHJvcGllZGFkIENvbm9jaWRhIGRlIGxhIERpc3RyaWJ1Y2nDs24gTm9ybWFsLCBsYSBjdWFsIGVzdGFibGVjZSBxdWUgKkRhZGFzIG9ic2VydmFjaW9uZXMgYWxlYXRvcmlhcyBlIGluZGVwZW5kaWVudGVzIChkZSB1bmEgZGlzdHJpYnVjacOzbiBub3JtYWwpLCBsYSBtZWRpYSBtdWVzdHJhbCB5IGxhIHZhcmlhbnphIG11ZXN0cmFsIHNvbiBpbmRlcGVuZGllbnRlcyouIEVuIG90cmFzIHBhbGFicmFzLCBjdWFuZG8gdG9tYXMgdW5hIG11ZXN0cmEgeSBsYSB1c2FzIHBhcmEgZXN0aW1hciB0YW50byBsYSBtZWRpYSBjb21vIGxhIHZhcmlhbnphIGRlIGxhIHBvYmxhY2nDs24sIHF1w6kgdGFudG8gcHVlZGVzIGVxdWl2b2NhcnRlIHNvYnJlIGxhIG1lZGlhIGVzIGluZGVwZW5kaWVudGUgZGUgcXXDqSB0YW50byBwdWVkZXMgZXF1aXZvY2FydGUgc29icmUgbGEgdmFyaWFuemEuIEVzdGEgZXMgdW5hIGNhcmFjdGVyw61zdGljYSAqKsO6bmljYSoqIGRlIGxhIGRpc3RyaWJ1Y2nDs24gbm9ybWFsIHkgZXMgdW5hIGRlIGxhcyByYXpvbmVzIHBvciBsYSBxdWUgbGEgcHJ1ZWJhIGRlIFMtVyBlcyBkZSBsYXMgbcOhcyAocG9yIG5vIGRlY2lyIGxhIG3DoXMpIHV0aWxpemFkYSB5IHJlY29tZW5kYWRhLCBlc3BlY2lhbG1lbnRlIHBhcmEgbXVlc3RyYXMgcGVxdWXDsWFzLiBFbiBhbGd1bm9zIGVzdHVkaW9zIGRlIHNpbXVsYWNpw7NuIGNvbW8gW2VzdGVdKGh0dHA6Ly93d3cudWttLm15L2pzbS9wZGZfZmlsZXMvU00tUERGLTQwLTYtMjAxMS8xNSUyME5vckFpc2hhaC5wZGYpIGhhIGRlbW9zdHJhZG8gc2VyIG3DoXMgc2Vuc2libGUgYSBsYXMgZGVzdmlhY2lvbmVzIGRlIGxhIG5vcm1hbGlkYWQgcXVlIGxhIHBydWViYSBkZSBLb2xtb2dvcm92LVNtaXJub3YsIGF1bnF1ZSBhbnRlcyBkZSBleHBsaWNhcmxhIGFwbGlxdWVtb3MgbGEgcHJ1ZWJhIGRlIFMtVzoKCmBgYHtyfQpzaGFwaXJvLnRlc3QoZGMkREMpCmBgYAoKRWwgdmFsb3IgZGUgcCBubyBub3MgcGVybWl0ZSByZWNoYXphciBudWVzdHJhIGhpcMOzdGVzaXMgZGUgbnVsaWRhZCBhIHVuICRcYWxwaGEgPSAwLjA1JCwgcG9yIGxvIHF1ZSBwb2RlbW9zIGNvbmNsdWlyIHF1ZSBsb3MgZGF0b3Mgc2UgYWp1c3RhbiBhIHVuYSBkaXN0cmlidWNpw7NuIG5vcm1hbC4gVnVlbHZlIGFsIGdyw6FmaWNvIGRlIGRlbnNpZGFkIG5vcm1hbCwgwr9xdcOpIG9waW5hcz8KCkNvbW8gYcOxYWRpZG8sIHZpc3VhbGljZW1vcyBsYSBzZWd1bmRhIHByb3BpZWRhZCBjb25vY2lkYSBkZSBsYSBkaXN0cmlidWNpw7NuIG5vcm1hbDoKCmBgYHtyfQptZWFucyA8LSBOQQpzZHMgPC0gTkEKCmZvciAoaSBpbiAxOjEwMDApIHsKICBub3JtX2RhdGEgPC0gcm5vcm0oMTApCiAgbWVhbnNbaV0gPC0gbWVhbihub3JtX2RhdGEpCiAgc2RzW2ldIDwtIHNkKG5vcm1fZGF0YSkKfQoKbWVhbl9zZCA8LSBkYXRhLmZyYW1lKG1lYW4gPSBtZWFucywgc2QgPSBzZHMpCgpwcm9wXzIgPC0gZ2dwbG90KGRhdGEgPSBtZWFuX3NkLCBhZXMoeCA9IG1lYW4sIHkgPSBzZCkpICsKICAgICAgICAgIGdlb21fcG9pbnQoY29sb3IgPSAiZG9kZ2VyYmx1ZTQiLCBzaXplID0gMiwgYWxwaGEgPSAwLjUpICsKICAgICAgICAgIHRoZW1lX2J3KCkgKwogICAgICAgICAgbGFicyh0aXRsZSA9ICJTZWd1bmRhIFByb3BpZWRhZCBDb25vY2lkYSBkZSBsYSBEaXN0cmlidWNpw7NuIE5vcm1hbCIsCiAgICAgICAgICAgICAgIHN1YnRpdGxlID0gIjEwMDAgbXVlc3RyZW9zIGRlIHVuYSBwb2JsYWNpw7NuIG5vcm1hbCIsCiAgICAgICAgICAgICAgIHggPSAiTWVkaWEiLAogICAgICAgICAgICAgICB5ID0gIkRlc3ZpYWNpw7NuIEVzdMOhbmRhciIpICsKICAgICAgICAgIHRoZW1lKHRleHQgPSBlbGVtZW50X3RleHQoY29sb3VyID0gImdyYXk0MCIpKQojY2Fpcm9fcGRmKCJwcm9wXzIucGRmIiwgZmFtaWx5ID0gIk1vbnRzZXJyYXQiLCBoZWlnaHQgPSA1LCB3aWR0aCA9IDUqMS42LCBwb2ludHNpemUgPSAyMCkKcHJvcF8yCiNkZXYub2ZmKCkKYGBgCgpDb24gdW5hIGRpc3RyaWJ1Y2nDs24gR2FtbWE6CmBgYHtyfQptZWFucyA8LSBOQQpzZHMgPC0gTkEKCmZvciAoaSBpbiAxOjEwMDApIHsKICBnYW1tYV9kYXRhIDwtIHJnYW1tYSgxMCwgc2hhcGUgPSAxKQogIG1lYW5zW2ldIDwtIG1lYW4oZ2FtbWFfZGF0YSkKICBzZHNbaV0gPC0gc2QoZ2FtbWFfZGF0YSkKfQoKbWVhbl9zZCA8LSBkYXRhLmZyYW1lKG1lYW4gPSBtZWFucywgc2QgPSBzZHMpCgpwcm9wX2cgPC0gZ2dwbG90KGRhdGEgPSBtZWFuX3NkLCBhZXMoeCA9IG1lYW4sIHkgPSBzZCkpICsKICAgICAgICAgIGdlb21fcG9pbnQoY29sb3IgPSAiZG9kZ2VyYmx1ZTQiLCBzaXplID0gMiwgYWxwaGEgPSAwLjUpICsKICAgICAgICAgIHRoZW1lX2J3KCkgKwogICAgICAgICAgbGFicyh0aXRsZSA9ICJTZWd1bmRhIFByb3BpZWRhZCBDb25vY2lkYSBkZSBsYSBEaXN0cmlidWNpw7NuIE5vcm1hbCIsCiAgICAgICAgICAgICAgIHN1YnRpdGxlID0gIjEwMDAgbXVlc3RyZW9zIGRlIHVuYSBwb2JsYWNpw7NuIGdhbW1hIiwKICAgICAgICAgICAgICAgeCA9ICJNZWRpYSIsCiAgICAgICAgICAgICAgIHkgPSAiRGVzdmlhY2nDs24gRXN0w6FuZGFyIikgKwogICAgICAgICAgdGhlbWUodGV4dCA9IGVsZW1lbnRfdGV4dChjb2xvdXIgPSAiZ3JheTQwIikpCgojY2Fpcm9fcGRmKCJwcm9wX2cucGRmIiwgZmFtaWx5ID0gIk1vbnRzZXJyYXQiLCBoZWlnaHQgPSA1LCB3aWR0aCA9IDUqMS42LCBwb2ludHNpemUgPSAyMCkKcHJvcF9nCiNkZXYub2ZmKCkKYGBgCgpFamVyaWNpbyBvcGNpb25hbDogUmVhbGl6YSBlbCBtaXNtbyBncsOhZmljbyBwYXJhIGxhIGNvbHVtbmEgREMgeSBwYXJhIGxhIGNvbHVtbmEgQ0guCgojIyMjIFBydWViYSBLb2xtb2dvcm92LVNtaXJub3YKCkEgZGlmZXJlbmNpYSBkZSBsYSBwcnVlYmEgUy1XLCBsYSBwcnVlYmEgSy1TIGNvbXBhcmEgbGFzIGZ1bmNpw7NuIGRlIGRlbnNpZGFkIGFjdW11bGFkYSBlbXDDrXJpY2EgKG9ic2VydmFkYSkgdnMuIHVuYSBmdW5jacOzbiBkZSBkZW5zaWRhZCBhY3VtdWxhZGEgdGXDs3JpY2EgKG5vIG5lY2VzYXJpYW1lbnRlIG5vcm1hbCksIGxvIGN1YWwgY2F1c2EgcXVlIHNlYSBzZW5zaWJsZSBhIGRlc3ZpYWNpb25lcyBlbiBlbCBjZW50cm8gZGUgbGEgZGlzdHJpYnVjacOzbiBwZXJvIG5vIGVuIGxhcyBjb2xhczsgc2luIGVtYmFyZ28sIGVzIGltcG9ydGFudGUgbWVuY2lvbmFyLCBxdWUgbGEgcHJ1ZWJhIEstUyBlcyBjb252ZXJnZW50ZTsgZXMgZGVjaXIsIHF1ZSBjb25mb3JtZSAkTiBccmlnaHRhcnJvdyBcaW5mdHkkIGxhIHBydWViYSBjb252ZXJnZSBhIGxhICJyZXNwdWVzdGEgdmVyZGFkZXJhIiBlbiB0w6lybWlub3MgZGUgcHJvYmFiaWxpZGFkLiBFc3RhIHJhesOzbiBoYWNlIHF1ZSBlc3RhIHBydWViYSBubyBzZSByZWNvbWllbmRlIHBhcmEgdGFtYcOxb3MgZGUgbXVlc3RyYSBwZXF1ZcOxb3MuIFBhcmEgYXBsaWNhcmxhOgoKYGBge3J9CmtzLnRlc3QoZGMkREMsICJwbm9ybSIpCmBgYAoKQSBkaWZlcmVuY2lhIGRlbCBjYXNvIGFudGVyaW9yLCBlc3RhIHBydWViYSBzaSB0dXZvIGV2aWRlbmNpYSBzdWZpY2llbnRlIHBhcmEgcmlkaWN1bGl6YXIgbnVlc3RyYSBoaXDDs3Rlc2lzIG51bGEsIHBvciBsbyBxdWUgcG9kZW1vcyBjb25jbHVpciBxdWUgbnVlc3Ryb3MgZGF0b3Mgbm8gc2UgYWp1c3RhbiBhIHVuYSBkaXN0cmlidWNpw7NuIG5vcm1hbC4gVnVlbHZlIG51ZXZhbWVudGUgYWwgZ3LDoWZpY28gS0RFLiDCv1F1w6kgb3BpbmFzPwoKVmVhbW9zIGxhcyBkZW5zaWRhZGVzIGFjdW11bGFkYXM6CgpgYGB7cn0KIyBHZW5lcmFtb3MgdW5hIGNkZiBub3JtYWwgdGXDs3JpY2E6CmNkZiA8LSBkYXRhLmZyYW1lKG5vcm0gPSBybm9ybSgxMDAwLCBtZWFuID0gbWVhbihkYyREQyksIHNkID0gc2QoZGMkREMpKSkKIyBHcmFmaWNhbW9zIHVuYSB2cy4gbGEgb3RyYToKY2RmcGxvdCA8LSBnZ3Bsb3QoZGF0YSA9IGRjLCBhZXMoREMpKSArCiAgICAgICAgICAgc3RhdF9lY2RmKGdlb20gPSAic3RlcCIsIGNvbG91ciA9IHJnYigxMTgsNzgsMTQ0LCBtYXhDb2xvclZhbHVlID0gMjU1KSwgYWxwaGEgPSAxKSArCiAgICAgICAgICAgc3RhdF9lY2RmKGRhdGEgPSBjZGYsIGFlcyhub3JtKSwgZ2VvbSA9ICJsaW5lIiwgY29sb3VyID0gImJsYWNrIikgKwogICAgICAgICAgIHRoZW1lX2J3KCkgKwogICAgICAgICAgIGxhYnModGl0bGUgPSAiRGVuc2lkYWRlcyBlbXDDrXJpY2EgKG1vcmFkbykgeSB0ZcOzcmljYSAobmVncm8pIEFjdW11bGFkYXMgcGFyYSBEQyIsCiAgICAgICAgICAgICAgICB4ID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgeSA9IGVsZW1lbnRfYmxhbmsoKSkKCiNjYWlyb19wZGYoImNkZi5wZGYiLCBmYW1pbHkgPSAiTW9udHNlcnJhdCIsIGhlaWdodCA9IDUsIHdpZHRoID0gNSoxLjYsIHBvaW50c2l6ZSA9IDIwKQpjZGZwbG90CiNkZXYub2ZmKCkKYGBgCgpDb25qdW50YW5kbyBjb24gZWwgZ3LDoWZpY28ga2RlIG9yaWdpbmFsIHBvZGVtb3MgdmVyIHBvciBxdcOpIGxhIHBydWViYSBLLVMgYXJyb2rDsyB1biByZXN1bHRhZG8gc2lnbmlmaWNhdGl2bywgeWEgcXVlIGh1Ym8gZGVzdmlhY2lvbmVzIGltcG9ydGFudGVzIGVuIGxhIHpvbmEgY2VudHJhbC4gSW50ZXJwcmV0YXIgY29ycmVjdGFtZW50ZSB1biBncsOhZmljbyBDREYgTk8gZXMgc2VuY2lsbG8geSByZXF1aWVyZSBkZSBleHBlcmllbmNpYSwgcG9yIGxvIHF1ZSDDum5pY2FtZW50ZSBsbyBpbmNsdcOtIHBhcmEgYWNvbXBhw7FhciBhIGxhIHBydWViYSBxdWUgc2UgYmFzYSBlbiBsYSBkZW5zaWRhZCBhY3VtdWxhZGEuCgpIYWJpZW5kbyBleHBsaWNhZG8gZG9zIGRlIGxhcyBwcnVlYmFzIGRlIG5vcm1hbGlkYWQgbcOhcyBjb211bmVzLCBwYXNlbW9zIGEgbG9zIGFuw6FsaXNpcyBwYXJhbcOpdHJpY29zLiBFbCBwcmltZXJvIGRlIGVsbG9zIGxvIHJldmlzYW1vcyBkdXJhbnRlIGxhIGNsYXNlIGRlIHBydWViYXMgZGUgaGlww7N0ZXNpczogbGEgcHJ1ZWJhIHQgZGUgU3R1ZGVudCwgcG9yIGxvIHF1ZSBwYXNhcmVtb3MgZGlyZWN0YW1lbnRlIGFsIEFuw6FsaXNpcyBkZSBsYSBWYXJpYW56YS4KCiMjIEFuw6FsaXNpcyBkZSBsYSBWYXJpYW56YQpFbiB0w6lybWlub3Mgc2ltcGxlcywgcG9kZW1vcyBwZW5zYXIgZW4gZWwgQU5PVkEgY29tbyB1bmEgZXh0ZW5zacOzbiBkZSBsYSBwcnVlYmEgdC1TdHVkZW50IGEgbcOhcyBkZSBkb3MgZ3J1cG9zIGEgY29tcGFyYXIuIER1cmFudGUgbGEgY2xhc2UgZGUgQ29tcGFyYWNpb25lcyBNdWx0aXZhcmlhZGFzIGFib3JkYW1vcyBlbCByaWVzZ28gcXVlIGNvbmxsZXZhIHJlYWxpemFyIG3Dumx0aXBsZXMgcHJ1ZWJhcyBkZSBoaXDDs3Rlc2lzIChjb21wYXJhY2lvbmVzKSBlbiBudWVzdHJvcyBkYXRvczsgZXMgZGVjaXIsIGVsIHByb2JsZW1hIGRlIHJlYWxpemFyIGRvcyBvIG3DoXMgY29tcGFyYWNpb25lcyBlbnRyZSBncnVwb3MgY29tbyBzaSBzZSB0cmF0YXJhIGRlIHBydWViYXMgaW5kZXBlbmRpZW50ZXMuIFBvciBlbCBtb21lbnRvLCBzb2xvIHRlbiBlbiBtZW50ZSBxdWUgc2UgaW5jcmVtZW50YSBsYSBwb3NpYmlsaWRhZCBkZSBvYnRlbmVyIHVuIGZhbHNvIHBvc2l0aXZvIMO6bmljYW1lbnRlIHBvciBhemFyLCBwb3IgbG8gcXVlIGhheSBxdWUgdXRpbGl6YXIgdW5hIHTDqWNuaWNhIGFkZWN1YWRhIHkgZXMgYWjDrSBkb25kZSBlbnRyYSBlbCBBTk9WQSBvLCBtZWpvciBkaWNobywgbG9zIEFOT1ZBcy4gQ29tbyB0ZSBpbWFnaW5hcsOhcywgZXN0YXMgcHJ1ZWJhcyBub3MgcGVybWl0ZW4gY29tcGFyYXIgbWVkaWFzIGVudHJlIG3DoXMgZGUgZG9zIGdydXBvcywgYXVucXVlIGFxdcOtIGxhIGNvbXBhcmFjacOzbiBzZSByZWFsaXphIGRlIG1hbmVyYSBnbG9iYWwgeSBsYSBoaXDDs3Rlc2lzIGFsdGVybmF0aXZhIHNlIGV4cHJlc2EgY29tbyAiQWwgbWVub3MgdW5hIGRlIGxhcyBtZWRpYXMgZXMgZGlmZXJlbnRlIi4gRXN0byBxdWllcmUgZGVjaXIgcXVlIGVsIEFOT1ZBIG5vIG5vcyBkaXLDoSBlbnRyZSBxdcOpIHBhcihlcykgZGUgZ3J1cG9zIHNlIGVuY29udHJhcm9uIGxhcyBkaWZlcmVuY2lhcywgc2lubyBxdWUgaGFicsOhIHF1ZSBhY29tcGHDsWFybG8gZGUgdW5hIHBydWViYSBwb3N0LWhvYy4gRXN0YSBwcnVlYmEgZXMgbGEgcHJ1ZWJhIGRlIGRpZmVyZW5jaWFzIGhvbmVzdGFzIChIU0QpIGRlIFR1a2V5LCBsYSBjdWFsIHNlIGVuY3VlbnRyYSBiYXNhZGEgZW4gbGEgZGlzdHJpYnVjacOzbiBkZSBsb3MgcmFuZ29zIGVzdHVkZW50aXphZG9zIHkgZnVlIGRpc2XDsWFkYSBwYXJhIG5vIGluY3JlbWVudGFyIGxhIHByb2JhYmlsaWRhZCBkZSBmYWxzb3MgcG9zaXRpdm9zIGFsIHJlYWxpemFyIG3Dumx0aXBsZXMgY29tcGFyYWNpb25lcy4gRW4gZXN0YSBzZXNpw7NuIHJldmlzYXJlbW9zIHRyZXMgbW9kYWxpYWRlcyBkZSBBTk9WQTogZGUgdW5hIHbDrWEsIGRlIGRvcyB2w61hcyB5IGZhY3RvcmlhbCwgZGUgbWVub3IgYSBtYXlvciBjb21wbGVqaWRhZCwgYXVucXVlIGVzdG9zIG5vIHNvbiBsb3Mgw7puaWNvcy4gRW50cmUgbG9zIGRlbcOhcyBkaXNlw7FvcyBkZSBBTk9WQSBzZSBlbmN1ZW50cmFuIGVsIEFOT1ZBIGRlIG1lZGlkYXMgcmVwZXRpZGFzIChlc3R1ZGlvcyBkZSBjcmVjaW1pZW50byBlbiBsYWJvcmF0b3JpbyBjb24gbWVkaWRhcyBpbnRlcm1lZGlhcyBlbnRyZSBlbCBpbmljaW8geSBlbCBmaW5hbCwgcG9yIGVqZW1wbG8pIG8gZWwgQU5PVkEgYW5pZGFkbywgZW4gZWwgY3VhbCBlbCBkaXNlw7FvIGVzIHNpbWlsYXIgYSB1bmEgbXXDsWVjYSBydXNhLgoKQW50ZXMgZGUgYXBsaWNhciB5IGV4cGxpY2FyIGxvcyBtb2RlbG9zIGRlIEFOT1ZBLCBlcyBuZWNlc2FyaW8gZGVzYXJyb2xsYXIgdW5hIGludHVpY2nDs24gc29icmUgZWwgcHJvY2VkaW1pZW50by4gRWwgbm9tYnJlICJBbsOhbGlzaXMgZGUgVmFyaWFuemEiIHZpZW5lIGRlIHF1ZSwgbGl0ZXJhbG1lbnRlLCBzZSB1dGlsaXphbiBsYXMgdmFyaWFuemFzIHBhcmEgY29tcGFyYXIgbGFzIG1lZGlhcy4gQXVucXVlIGVsIHByb2Nlc28gbWF0ZW3DoXRpY28gaW1wbGljYSBjYWxjdWxhciBwcm9tZWRpb3MgZGUgcHJvbWVkaW9zLCB2YXJpYXMgc3VtYXMgZGUgY3VhZHJhZG9zIHkgY3VhZHJhZG9zIG1lZGlvcyBkZWwgZXJyb3IsIHBvZGVtb3MgcmVzdW1pcmxvIHBhcmEgZmluZXMgcHLDoWN0aWNvcyBlbiBxdWUgbGEgY29tcGFyYWNpw7NuIHNlIHJlYWxpemEgbWVkaWFudGUgdW5hIHJhesOzbi9jb2NpZW50ZSwgdGFsIHF1ZToKCiQkRiA9IFxmcmFje1xzaWdtYV4yX3tlbnRyZX19e1xzaWdtYV4yX3tkZW50cm99fSQkCgpTw6kgcXVlIGVzdG8gcHVlZGUgc29uYXIgbXV5IHBvY28gaW50dWl0aXZvLCBwZXJvIHNpIG5vcyBkZXRlbmVtb3MgdW4gcG9jbyBhIGFuYWxpemFyIGxhIGVjdWFjacOzbiBwb2RlbW9zIGRhcmxlIG11Y2hvIHNlbnRpZG8uIExhIHZhcmlhbnphIGRlbnRybyBkZSBsb3MgZ3J1cG9zIHBvZGVtb3MgY29uc2lkZXJhcmxhIGNvbW8gbGEgdmFyaWFuemEgInByb21lZGlvIiBkZSBjYWRhIGdydXBvIChyYXrDs24gcG9yIGxhIHF1ZSBlcyBpbXBvcnRhbnRlIHF1ZSBlc3RhcyBzZWFuIGhvbW9nw6luZWFzIGVudHJlIHRvZG9zIG51ZXN0cm9zIGdydXBvcyksIG1pZW50cmFzIHF1ZSBsYSB2YXJpYW56YSBlbnRyZSBsb3MgZ3J1cG9zIHJlcHJlc2VudGEgbGEgInNlcGFyYWNpw7NuIiAoZGlzcGVyc2nDs24pIGVudHJlIGxvcyBncnVwb3MgKHNpbiBjb25zaWRlcmFyIGVsIGVycm9yKS4gUGFydGllbmRvIGRlIGVzdG8sIGVzIGV2aWRlbnRlIHF1ZSBzaSBsYSB2YXJpYW56YSBlbnRyZSBncnVwb3MgZXMgbXV5IGdyYW5kZSBlbiByZWxhY2nDs24gYSBsYSB2YXJpYW56YSBkZW50cm8gZGUgbG9zIGdydXBvcyBwb2RlbW9zIGluZmVyaXIgcXVlIGV4aXN0ZSB1biBlZmVjdG8gZGVsIGZhY3RvciBkZSBhZ3J1cGFtaWVudG8gcHVlcyAibm8gaGF5IiAob2pvIGEgbGFzIGNvbWlsbGFzIHkgbG9zIHN1cHVlc3Rvcykgb3RyYSBmb3JtYSBkZSBxdWUgbGFzIGRpc3RyaWJ1Y2lvbmVzIGRlIGxvcyBncnVwb3Mgc2UgZGVzcGxhY2VuLgoKR3LDoWZpY2FtZW50ZSBsYSB2YXJpYW56YSBkZW50cm8gZGUgbG9zIGdydXBvcyBzZSByZXByZXNlbnRhcsOtYSBkZSBsYSBzaWd1aWVudGUgbWFuZXJhOgoKYGBge3J9CmFub3Zfc2ltIDwtIGRhdGEuZnJhbWUoZ3J1cG8gPSBhcy5mYWN0b3IoYyhyZXAoIkEiLCAxMDAwKSwgcmVwKCJCIiwgMTAwMCkpKSwKICAgICAgICAgICAgICAgICAgICAgICB5ID0gYyhybm9ybSgxMDAwLCBtZWFuID0gMTAsIHNkID0gMSksIHJub3JtKDEwMDAsIG1lYW4gPSAyMCwgc2QgPSAxKSkpCgpkZW50cm9fcGxvdCA8LSBnZ3Bsb3QoZGF0YSA9IGFub3Zfc2ltLCBhZXMoeSwgZmlsbCA9IGdydXBvLCBhbHBoYSA9IDAuNSkpICsKICAgICAgICAgICAgICAgZ2VvbV9kZW5zaXR5KHRyaW0gPSBULCBzaG93LmxlZ2VuZCA9IEYsIGNvbG91ciA9ICJ3aGl0ZSIpICsKICAgICAgICAgICAgICAgdGhlbWVfbWluaW1hbCgpICsKICAgICAgICAgICAgICAgbGFicyh0aXRsZSA9ICJWYXJpYW56YSBkZW50cm8gZGUgbG9zIGdydXBvcyIsCiAgICAgICAgICAgICAgICAgICAgeCA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICAgICB5ID0gZWxlbWVudF9ibGFuaygpKSArCiAgICAgICAgICAgICAgIHNjYWxlX3lfY29udGludW91cyhsYWJlbHMgPSBOVUxMKSArCiAgICAgICAgICAgICAgIHhsaW0oYyg1LCAyNSkpCmRlbnRyb19wbG90CmBgYAoKTWllbnRyYXMgcXVlIGxhIHZhcmlhbnphIGVudHJlIGxvcyBncnVwb3MgcG9kZW1vcywgcGFyYSBmaW5lcyBkZSBpbnRlcnByZXRhY2nDs24sIHZpc3VhbGl6YXJsYSBjb21vIGxhIHZhcmlhbnphIGRhZGEgcG9yIGFtYm9zIGdydXBvcy4gRW4gcmVhbGlkYWQgZXN0byByZXByZXNlbnRhcsOtYSBsYSB2YXJpYW56YSB0b3RhbCB5IGxhIHZhcmlhbnphIGVudHJlIGxvcyBncnVwb3MgZXMgZWwgcmVzdWx0YWRvIGRlIGVsaW1pbmFyIGxhIHZhcmlhbnphIGRhZGEgcG9yIGVsIGVycm9yLCBwZXJvIHNpZ2Ftb3MgY29uIGVsIGVqZW1wbG86CgpgYGB7cn0KYW5vdl9zaW0kdG90IDwtIHJub3JtKDIwMCwgbWVhbiA9IDE1LCBzZCA9IHNkKGFub3Zfc2ltJHkpKQplbnRyZV9wbG90IDwtIGdncGxvdChkYXRhID0gYW5vdl9zaW0sIGFlcyh0b3QpKSArIAogICAgICAgICAgICAgIGdlb21fZGVuc2l0eShmaWxsID0gImRvZGdlcmJsdWU0IiwgYWxwaGEgPSAwLjUsIGNvbG91ciA9ICJ3aGl0ZSIpICsKICAgICAgICAgICAgICB0aGVtZV9taW5pbWFsKCkgKwogICAgICAgICAgICAgIGxhYnModGl0bGUgPSAiVmFyaWFuemEgZW50cmUgbG9zIGdydXBvcyIsCiAgICAgICAgICAgICAgICAgICB4ID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgICAgeSA9IGVsZW1lbnRfYmxhbmsoKSkgKwogICAgICAgICAgICAgIHNjYWxlX3lfY29udGludW91cyhsYWJlbHMgPSBOVUxMKSArCiAgICAgICAgICAgICAgeGxpbShjKDUsIDI1KSkKZW50cmVfcGxvdApgYGAKClZpc3VhbGl6w6FuZG9sYXMgY29tbyBzaSBkZSB1biBjb2NpZW50ZSBzZSB0cmF0YXJhIGVzIHBvc2libGUgZGFyc2UgY3VlbnRhIGPDs21vIGxhIHZhcmlhbnphICJlbnRyZSIgbG9zIGdydXBvcyBlcyBtdWNobyBtYXlvciBxdWUgbGEgdmFyaWFuemEgZGVudHJvIGRlIGxvcyBncnVwb3MsIGxvIGN1YWwgZGFyw61hIHVuIHZhbG9yIGRlIGxhIHJhesOzbiBkZSB2YXJpYW56YXMgbXV5IGFsdG8sIHN1Z2lyaWVuZG8gdW4gZWZlY3RvIGRlbCBmYWN0b3IgZGUgYWdydXBhbWllbnRvLgpgYGB7cn0KI2NhaXJvX3BkZigiYW5vdmFfcGxvdC5wZGYiLCBmYW1pbHkgPSAiTW9udHNlcnJhdCIsIGhlaWdodCA9IDUsIHdpZHRoID0gNSoxLjYsIHBvaW50c2l6ZSA9IDIwKQpncmlkRXh0cmE6OmdyaWQuYXJyYW5nZShlbnRyZV9wbG90LCBkZW50cm9fcGxvdCkKI2Rldi5vZmYoKQpgYGAKClZlYW1vcyBxdcOpIHBhc2EgY3VhbmRvIGxhcyBtZWRpYXMgc29uIG3DoXMgY2VyY2FuYXMgZW50cmUgc8OtOgpgYGB7cn0KYW5vdl9zaW0yIDwtIGRhdGEuZnJhbWUoZ3J1cG8gPSBhcy5mYWN0b3IoYyhyZXAoIkEiLCAxMDAwKSwgcmVwKCJCIiwgMTAwMCkpKSwKICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMocm5vcm0oMTAwMCwgbWVhbiA9IDEwLCBzZCA9IDEpLCBybm9ybSgxMDAwLCBtZWFuID0gMTEsIHNkID0gMSkpKQphbm92X3NpbTIkdG90IDwtIHJub3JtKDIwMDAsIG1lYW4oMTAuNSksIHNkKGFub3Zfc2ltMiR5KSkKZGVudHJvX3Bsb3QyIDwtIGdncGxvdChkYXRhID0gYW5vdl9zaW0yLCBhZXMoeSwgZmlsbCA9IGdydXBvLCBhbHBoYSA9IDAuNSkpICsKICAgICAgICAgICAgICAgZ2VvbV9kZW5zaXR5KHRyaW0gPSBULCBzaG93LmxlZ2VuZCA9IEYsIGNvbG91ciA9ICJ3aGl0ZSIpICsKICAgICAgICAgICAgICAgdGhlbWVfbWluaW1hbCgpICsKICAgICAgICAgICAgICAgbGFicyh0aXRsZSA9ICJWYXJpYW56YSBkZW50cm8gZGUgbG9zIGdydXBvcyIsCiAgICAgICAgICAgICAgICAgICAgeCA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICAgICB5ID0gZWxlbWVudF9ibGFuaygpKSArCiAgICAgICAgICAgICAgIHNjYWxlX3lfY29udGludW91cyhsYWJlbHMgPSBOVUxMKSArCiAgICAgICAgICAgICAgIHhsaW0oYyg1LCAxNSkpCmVudHJlX3Bsb3QyIDwtIGdncGxvdChkYXRhID0gYW5vdl9zaW0yLCBhZXModG90KSkgKyAKICAgICAgICAgICAgICBnZW9tX2RlbnNpdHkoZmlsbCA9ICJkb2RnZXJibHVlNCIsIGFscGhhID0gMC41LCBjb2xvdXIgPSAid2hpdGUiKSArCiAgICAgICAgICAgICAgdGhlbWVfbWluaW1hbCgpICsKICAgICAgICAgICAgICBsYWJzKHRpdGxlID0gIlZhcmlhbnphIGVudHJlIGxvcyBncnVwb3MiLAogICAgICAgICAgICAgICAgICAgeCA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICAgIHkgPSBlbGVtZW50X2JsYW5rKCkpICsKICAgICAgICAgICAgICBzY2FsZV95X2NvbnRpbnVvdXMobGFiZWxzID0gTlVMTCkgKwogICAgICAgICAgICAgIHhsaW0oYyg1LCAxNSkpCiNjYWlyb19wZGYoImFub3ZhX3Bsb3QyLnBkZiIsIGZhbWlseSA9ICJNb250c2VycmF0IiwgaGVpZ2h0ID0gNSwgd2lkdGggPSA1KjEuNiwgcG9pbnRzaXplID0gMjApCmdyaWRFeHRyYTo6Z3JpZC5hcnJhbmdlKGVudHJlX3Bsb3QyLCBkZW50cm9fcGxvdDIpCiNkZXYub2ZmKCkKYGBgCgojIyMgU3VwdWVzdG8gZGUgaG9tb2dlbmVpZGFkIGRlIFZhcmlhbnphcwoKQ29tbyBwb2Ryw6FzIGltYWdpbmFyLCBlbCBxdWUgbGFzIHZhcmlhbnphcyBkZSBsb3MgZ3J1cG9zIG5vIHNlYW4gaG9tb2fDqW5lYXMgZ2VuZXJhcsOhIHVuIHNlc2dvIGFsIG1vbWVudG8gZGUgY2FsY3VsYXIgZWwgY29jaWVudGUgeSwgZW4gY29uc2VjdWVuY2lhLCBlbCBuaXZlbCBkZSBzaWduaWZpY2FuY2lhIGRlIGxhIHBydWViYS4gRXN0byBlcyBsbyBxdWUgZGEgb3JpZ2VuIGFsIFN1cHVlc3RvIGRlIEhvbW9nZW5laWRhZCBkZSBWYXJpYW56YXMuIEV4aXN0ZSB1bmEgZ3JhbiBkaXZlcnNpZGFkIGRlIHBydWViYXMsIGNhZGEgdW5hIGNvbiBzdXMgY29uc2lkZXJhY2lvbmVzLCBmb3J0YWxlemFzIHkgZGVzdmVudGFqYXMsIHBlcm8gYW5hbGl6YXJlbW9zIMO6bmljYW1lbnRlIGxhcyAocG9zaWJsZW1lbnRlKSBtw6FzIGNvbm9jaWRhcy4KCiMjIyMgUHJ1ZWJhIGRlIEJhcnRsZXR0CgpMYSBwcnVlYmEgZGUgQmFydGxldHQgc2UgY29uc2lkZXJhIGNvbW8gbGEgcHJ1ZWJhIFVuaWZvcm1lbWVudGUgTcOhcyBQb2Rlcm9zYTsgZXMgZGVjaXIsIGxhIHF1ZSBlcyBtZW5vcyBwcm9wZW5zYSBhIGNvbWV0ZXIgdW4gZmFsc28gbmVnYXRpdm8gcGFyYSBjdWFscXVpZXIgdmFsb3IgZGUgJFxhbHBoYSQuIEVzdGUgcG9kZXIsIHNpbiBlbWJhcmdvLCB0aWVuZSBzdXMgYmVtb2xlcyBvIHN1IGJlbW9sLCBtZWpvciBkaWNoby4gRXN0YSBwcnVlYmEgc2UgYXBveWEgVE9UQUxNRU5URSBlbiBxdWUgbGEgdmFyaWFibGUgZGUgaW50ZXLDqXMgZW4gY2FkYSBmYWN0b3Igc2UgZW5jdWVudHJhIG5vcm1hbG1lbnRlIGRpc3RyaWJ1w61kYSAowqFIb2xhIGRlIG51ZXZvLCBTdXB1ZXN0byBkZSBOb3JtYWxpZGFkISkuIERlIHZpb2xhcnNlIGVzdGUgc3VwdWVzdG8gZWwgdmFsb3IgZGUgJFxhbHBoYV92JCAodmVyZGFkZXJvKSBwYXJhIGxhIHBydWViYSBwdWVkZSBzZXIgbWF5b3IgbyBtZW5vciBhbCBkZWZpbmlkbyBwb3Igbm9zb3Ryb3MgKCRcYWxwaGFfbiQsIG5vbWluYWwpLiBEZSBtYW5lcmEgcGFydGljdWxhciwgc2kgbGEgZGlzdHJpYnVjacOzbiBkZSBsYSB2YXJpYWJsZSBhbmFsaXphZGEgcHJlc2VudGEgdW5hIGN1cnRvc2lzIG5lZ2F0aXZhIGVsICRcYWxwaGFfdiQgc2Vyw6EgbWVub3IgYWwgbm9taW5hbCwgbWllbnRyYXMgcXVlIGNvbiB1bmEgY3VydG9zaXMgcG9zaXRpdmEgc2Vyw6EgZWwgY2FzbyBjb250cmFyaW8uIEVzdG8gbGxldmEgYSBxdWUgaGFnYW1vcyB1bmEgcHJ1ZWJhIG3DoXMgbyBtZW5vcyBlc3RyaWN0YSBkZSBsbyBxdWUgaGFiw61hbW9zIHBsYW5lYWRvIG9yaWdpbmFsbWVudGUgeSBxdWUgbnVlc3Ryb3MgcmVzdWx0YWRvcyBubyBzZWFuIGNvbmZpYWJsZXMuIERlIGN1YWxxdWllciBtYW5lcmEsIHZlYW1vcyBjw7NtbyBhcGxpY2FybGE6CgpgYGB7cn0KYmFydGxldHQudGVzdCh5fmdydXBvLCBkYXRhID0gYW5vdl9zaW0pCmBgYAoKRW4gZXN0ZSBjYXNvLCBubyBwb2RlbW9zIHJpZGljdWxpemFyIG51ZXN0cmEgaGlww7N0ZXNpcyBkZSBudWxpZGFkLCBwb3IgbG8gcXVlIHBvZGVtb3MgY29uY2x1aXIgcXVlIGxhcyB2YXJpYW56YXMgZW50cmUgbnVlc3Ryb3MgZ3J1cG9zIHNvbiBob21vZ8OpbmVhcyAoeSBkZWJlbiBzZXJsbywgcHVlcyBhc8OtIGxhcyBlc3BlY2lmaWNhbW9zKS4KCiMjIyMgUHJ1ZWJhIGRlIExldmVuZQoKRXMgbGEgYWx0ZXJuYXRpdmEgcmVjb21lbmRhZGEgcG9yIG11Y2hvcyBhIGxhIHBydWViYSBkZSBCYXJ0bGV0dC4gQXVucXVlIG5vIGVzIHRhbiBwb2Rlcm9zYSwgc8OtIGVzIHJvYnVzdGEgYSBsYXMgdmlvbGFjaW9uZXMgYWwgc3VwdWVzdG8gZGUgbm9ybWFsaWRhZCwgZGUgbW9kbyBxdWUgZWwgJFxhbHBoYSQgdmVyZGFkZXJvIGVzIG11eSBzaW1pbGFyIGFsIG5vbWluYWwgcGFyYSB1bmEgZ3JhbiBjYW50aWRhZCBkZSBkaXN0cmlidWNpb25lcywgYXVucXVlIGVzIGluc2Vuc2libGUgYSBkaXN0cmlidWNpb25lcyBzaW3DqXRyaWNhcyBjb24gY29sYXMgYWx0YXMgY29tbyBsYSB0IGRlIFN0dWRlbnQgbyBkb2JsZSBleHBvbmVuY2lhbCAodGFtYmnDqW4gY29ub2NpZGEgY29tbyBkaXN0cmlidWNpw7NuIGRlIExhcGxhY2UpLiBBcGxpY2FybGEgdGFtYmnDqW4gZXMgc3VtYW1lbnRlIHNlbmNpbGxvOgpgYGB7cn0KY2FyOjpsZXZlbmVUZXN0KHl+Z3J1cG8sIGRhdGEgPSBhbm92X3NpbSkKYGBgCgpDb21vIGVyYSBkZSBlc3BlcmFyc2UsIGVsIHJlc3VsdGFkbyBlcyBjb25zaXN0ZW50ZSBjb24gbGEgcHJ1ZWJhIGRlIEJhcnRsZXR0IHBhcmEgZXN0ZSBjYXNvLgoKIyMjIEFOT1ZBIGRlIHVuYSBzb2xhIHbDrWEKCkhhYmllbmRvIHJldmlzYWRvIGxvcyBjb25jZXB0b3MgYsOhc2ljb3MgZGV0csOhcyBkZWwgQU5PVkEsIHBvZGVtb3MgcGFzYXIgYSBhcGxpY2FyIGFsZ3Vub3MgbW9kZWxvcy4gRWwgbcOhcyBzZW5jaWxsbyBlcyBlbCBBTk9WQSBkZSB1bmEgc29sYSB2w61hLCBlbCBjdWFsIGVzIGVsIGNhc28gbcOhcyBzZW5jaWxsbzsgZXMgZGVjaXIsIGNvbXBhcmFtb3MgdW5hIHNvbGEgdmFyaWFibGUgbnVtw6lyaWNhIGVudHJlIGxvcyBuaXZlbGVzIGRlIHVuIHNvbG8gZmFjdG9yIChwZXNvcyBmaW5hbGVzIHBhcmEgdHJlcyBhbGltZW50b3MgZGlzdGludG9zLCBwb3IgZWplbXBsbykuIFBhcmEgZWplbXBsaWZpY2FybG8gdXRpbGl6YXJlbW9zIGxhIGJhc2UgYGRhdG9zMWAgcXVlIHNlIHRyYWJhasOzIHBhcmEgbGEgdGFyZWEgZGUgSW50ZXJ2YWxvcyBkZSBjb25maWFuemEsIGNvbiB1bmEgY29sdW1uYSBleHRyYTogaWQsIGVsIGN1YWwgZXMgdW4gaWRlbnRpZmljYWRvciBwYXJhIGNhZGEgaW5kaXZpZHVvLiBFc3RhIGNvbHVtbmEgZnVlIGHDsWFkaWRhIMO6bmljYW1lbnRlIHBhcmEgZWplbXBsaWZpY2FyIHVuIGNhc28gZGUgQU5PVkEgcG9zdGVyaW9yLiBFbiBlc3RlIGVqZW1wbG8sIGNvbXBhcmFyZW1vcyBsb3MgcGVzb3MgdG90YWxlcyBlbnRyZSBsb3MgdHJlcyBwZXJpb2RvcyAoT0pPOiBlc3RlIGVzIHVuIGRpc2XDsW8gcGFyYSB1biBBTk9WQSBmYWN0b3JpYWwsIMO6bmljYW1lbnRlIGxvIHV0aWxpemFyZW1vcyBjb21vIGVqZW1wbG8pLgoKRWwgcHJpbWVyIHBhc28gZXMsIGV2aWRlbnRlbWVudGUsIGNhcmdhciBsYSBiYXNlIGRlIGRhdG9zOgoKYGBge3J9CmRmIDwtIHJlYWQudGFibGUoImRhdGEvRGF0b3MxLmNzdiIsIGhlYWRlciA9IEYsIHNraXAgPSAxLCBzZXAgPSAiLCIpCmNvbG5hbWVzKGRmKSA8LSBjKCJEaWV0YSIsICJQZXJpb2RvIiwgIlJlcCIsICJMVCIsICJQVCIsICJpZCIpCmRmJFBlcmlvZG8gPC0gZmFjdG9yKGRmJFBlcmlvZG8sIGxldmVscyA9IGMoIkkiLCAiTSIsICJGIikpCmhlYWQoZGYpCmBgYAoKIyMjIyBDb21wcm9iYWNpw7NuIGRlIHN1cHVlc3RvcwoKRWwgc2VndW5kbyBwYXNvIGVzIGxhIGNvbXByb2JhY2nDs24gZGUgc3VwdWVzdG9zLiBQcmltZXJvIGVsIGRlIE5vcm1hbGlkYWQ6CgpgYGB7cn0KI05vcm1hbGlkYWQKIyMgRGF0YS5mcmFtZSBhIGxsZW5hcgpub3JtIDwtIGRhdGEuZnJhbWUoZ3J1cG8gPSBOQSwgVyA9IE5BLCBwID0gTkEpCgojIyBOaXZlbGVzIGEgcHJvYmFyOgpsdmxzIDwtIGxldmVscyhkZiRQZXJpb2RvKQoKZm9yIChpIGluIHNlcV9hbG9uZyhsdmxzKSkgewogIHRlbXAgPC0gc2hhcGlyby50ZXN0KGRmJFBUW2RmJFBlcmlvZG8gPT0gbHZsc1tpXV0pCiAgbm9ybVtpLF0gPC0gYyhsdmxzW2ldLCB0ZW1wJHN0YXRpc3RpYywgdGVtcCRwLnZhbHVlKQp9Cm5vcm0KYGBgCgpMYSBwcnVlYmEgZGUgUy1XIHN1Z2llcmUgcXVlIG5vIGhheSBkZXN2aWFjaW9uZXMgc2lnbmlmaWNhdGl2YXMgZGUgbGEgbm9ybWFsaWRhZC4gQ29ycm9ib3JlbW9zIGNvbiB1biBncsOhZmljbyBkZSB2aW9sw61uLiBBbCBwYXJlY2VyLCBsb3MgcmVzdWx0YWRvcyBzb24gY29oZXJlbnRlcyBjb24gbGEgZGlzdHJpYnVjacOzbiBkZSBsb3MgZGF0b3MuCgpgYGB7cn0KZ2dwbG90KGRhdGEgPSBkZiwgYWVzKHggPSBQZXJpb2RvLCB5ID0gUFQsIGZpbGwgPSBQZXJpb2RvKSkgKwogIGdlb21fdmlvbGluKGFscGhhID0gMC41LCBzaG93LmxlZ2VuZCA9IEYpICsKICBsYWJzKHRpdGxlID0gIkRpc3RyaWJ1Y2nDs24gZGUgUFQgZW4gbG9zIHRyZXMgbW9tZW50b3MgZGUgbWVkaWNpw7NuIiwKICAgICAgIHggPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICB5ID0gZWxlbWVudF9ibGFuaygpKSArCiAgdGhlbWVfYncoKQpgYGAKCkFob3JhIGVsIHN1cHVlc3RvIGRlIGlndWFsZGFkIGRlIHZhcmlhbnphcywgdXRpbGl6YW5kbyBsYSBwcnVlYmEgZGUgTGV2ZW5lLiBQb2RlbW9zIGNvbmNsdWlyIHF1ZSBsYXMgdmFyaWFuemFzIG5vIHNvbiBob21vZ8OpbmVhcywgcG9yIGxvIHF1ZSBsYSByZWNvbWVuZGFjacOzbiBzZXLDrWEgcmVjdXJyaXIgYSB1bmEgcHJ1ZWJhIG5vIHBhcmFtw6l0cmljYTsgc2luIGVtYmFyZ28sIHNpZ2Ftb3MgY29uIGVsIGVqZXJjaWNpbyB5IGVzY2FsYW5kbyBsYSBjb21wbGVqaWRhZCBkZWwgYW7DoWxpc2lzIGFudGVzIGRlIHNhbHRhciBhcHJlc3VyYWRhbWVudGUgYSBjb25jbHVzaW9uZXMuCmBgYHtyfQpjYXI6OmxldmVuZVRlc3QoUFR+UGVyaW9kbywgZGF0YSA9IGRmKQpgYGAKCiMjIyMgQXBsaWNhY2nDs24gZGVsIEFOT1ZBCkVsIHNpZ3VpZW50ZSBwYXNvIGVzIGFwbGljYXIgZWwgQU5PVkEuIEVsIHZhbG9yIGRlIHAgZXMgYmFzdGFudGUgYmFqbywgbG8gY3VhbCByaWRpY3VsaXphIG51ZXN0cmEgaGlww7N0ZXNpcyBkZSBudWxpZGFkIHkgY29uY2x1aW1vcyBxdWUgYWwgbWVub3MgdW4gcGFyIGRlIG1lZGlhcyBzb24gc2lnbmlmaWNhdGl2YW1lbnRlIGRpZmVyZW50ZXMgZW50cmUgc8OtIChGKDIsIDE1NSkgPSA1NzQuMzsgcCA8IDAuMDAwMSkuCgpgYGB7cn0KdW5hX3ZpYSA8LSBhb3YoUFR+UGVyaW9kbywgZGF0YSA9IGRmKQpzdW1tYXJ5KHVuYV92aWEpCmBgYAoKIyMjIyBQcnVlYmEgcG9zdC1ob2MKCkVsIMO6bHRpbW8gcGFzbyBlcyBhcGxpY2FyIGxhIHBydWViYSBwb3N0LWhvYy4gRXN0YSBwcnVlYmEgc2UgY29uc3RydXllIGEgcGFydGlyIGRlIGxhIGRpc3RyaWJ1Y2nDs24gZGUgcmFuZ29zIGVzdHVkZW50aXphZG9zLCB5IGZ1ZSBkaXNlw7FhZGEgcGFyYSBldml0YXIgZWwgY29uZmxpY3RvIGVudHJlIGVsICRcYWxwaGEkIHkgZWwgbsO6bWVybyBkZSBjb21wYXJhY2lvbmVzLCBwb3IgbG8gcXVlIGxhIGludGVycHJldGFjacOzbiBkZWwgdmFsb3IgZGUgcCBlcyBkaXJlY3RhLiBFbiBlc3RlIGNhc28sIGVsIHZhbG9yIGRlIHAgZnVlIG11eSBwZXF1ZcOxbyBwYXJhIGxhcyB0cmVzIGNvbXBhcmFjaW9uZXMsIHBvciBsbyBxdWUgcmVjaGF6YW1vcyBudWVzdHJhIGhpcMOzdGVzaXMgZGUgbnVsaWRhZCBlbiBsb3MgdHJlcyBjYXNvcy4gRWwgcmVzdG8gZGUgbGEgdGFibGEgZXMgdGFtYmnDqW4gaW5mb3JtYXRpdm8sIHB1ZXMgbm9zIGluZGljYSBsYSBtYWduaXR1ZCBkZSBsYXMgZGlmZXJlbmNpYXMgeSBzdXMgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEgKHRhbCB5IGNvbW8gZW4gbGEgcHJ1ZWJhIHQgZGUgU3R1ZGVudCk6CgpgYGB7cn0KVHVrZXlIU0QodW5hX3ZpYSkKYGBgCgpDb24gZXNvcyA0IHBhc29zIHRlcm1pbmFtb3MgbnVlc3RybyBBTk9WQSBkZSB1bmEgdsOtYS4gUGFzZW1vcyBlbnRvbmNlcyBhbCBBTk9WQSBkZSBkb3MgdsOtYXMuCgojIyMgQU5PVkEgZGUgZG9zIHbDrWFzClNpIHVuYSB2w61hIGVzIGEgdW4gZmFjdG9yLCBkb3MgdsOtYXMgZXMgYSBkb3MgZmFjdG9yZXMuIEVuIGVzdGUgYW7DoWxpc2lzIGNvbXBhcmFyZW1vcyBlbCBlZmVjdG8gZGUgYW1ib3MgZmFjdG9yZXMgc2ltdWx0w6FuZWFtZW50ZSwgcGVybyBkZSBtYW5lcmEgaW5kZXBlbmRpZW50ZTsgZXMgZGVjaXIsIGF1bnF1ZSBzZSBoYXLDoSBsYSBjb21wYXJhY2nDs24gcGFyYSBhbWJvcywgbm8gc2UgY29uc2lkZXJhcsOhIGxhIGludGVyYWNjacOzbiBlbnRyZSBlbGxvcy4gTnVlc3RybyBzZWd1bmRvIGZhY3RvciBzZXLDoSBsYSBEaWV0YS4gTG9zIHBhc29zIHNvbiBleGFjdGFtZW50ZSBsb3MgbWlzbW9zIHF1ZSBlbiBlbCBhbnRlcmlvcjoKCiMjIyMgQ29tcHJvYmFjacOzbiBkZSBTdXB1ZXN0b3MKCkRhZG8gcXVlIHlhIGNvbXByb2JhbW9zIGxvcyBzdXB1ZXN0b3MgcGFyYSBlbCBmYWN0b3IgUGVyaW9kbywgc29sbyBoYWJyw6EgcXVlIGhhY2VybG8gcGFyYSBlbCBmYWN0b3IgRGlldGE6CgpgYGB7cn0KI05vcm1hbGlkYWQKZGYkRGlldGEgPC0gZmFjdG9yKGRmJERpZXRhLCBsZXZlbHMgPSBjKCJBIiwgIkIiLCAiQyIpKQojIyBEYXRhLmZyYW1lIGEgbGxlbmFyCm5vcm0gPC0gZGF0YS5mcmFtZShncnVwbyA9IE5BLCBXID0gTkEsIHAgPSBOQSkKCiMjIE5pdmVsZXMgYSBwcm9iYXI6Cmx2bHMgPC0gbGV2ZWxzKGRmJERpZXRhKQoKZm9yIChpIGluIHNlcV9hbG9uZyhsdmxzKSkgewogIHRlbXAgPC0gc2hhcGlyby50ZXN0KGRmJFBUW2RmJERpZXRhID09IGx2bHNbaV1dKQogIG5vcm1baSxdIDwtIGMobHZsc1tpXSwgdGVtcCRzdGF0aXN0aWMsIHRlbXAkcC52YWx1ZSkKfQpub3JtCmBgYAoKRGViaWRvIGEgcXVlIGVsIGZhY3RvciBkaWV0YSBpbmNsdXllIGVsIGVmZWN0byBkZWwgcGVyaW9kbyBkZSBtZWRpY2nDs24geSBkZXRlY3RhbW9zIGRpZmVyZW5jaWFzIGVudHJlIGVsbG9zLCBlcyBlc3BlcmFibGUgcXVlIG5vIHNlIGN1bXBsYSBlbCBzdXB1ZXN0byBkZSBub3JtYWxpZGFkLiBFbiBlc3RlIGNhc28sIGVsIGRpc2XDsW8gc2Vyw61hIG1lam9yIGFuYWxpemFkbyB1dGlsaXphbmRvIHVuIEFOT1ZBIGZhY3RvcmlhbCBxdWUgdW5vIGRlIGRvcyB2w61hcyBwZXJvLCBhbCBpZ3VhbCBxdWUgZW4gZWwgY2FzbyBhbnRlcmlvciwgc2VndWlyZW1vcyDDum5pY2FtZW50ZSBwYXJhIGZpbmVzIGlsdXN0cmF0aXZvcy4KClBhcmEgbGEgaG9tb2dlbmVpZGFkIGRlIHZhcmlhbnphcyBsYSBpbnRlcnByZXRhY2nDs24gZXMgbGEgbWlzbWEsIGF1bnF1ZSBsYSBjb25zZWN1ZW5jaWEgZXMgbGEgY29udHJhcmlhLiBObyB2aW9sYW1vcyBlbCBzdXB1ZXN0byBkZSBob21vZ2VuZWlkYWQgZGUgdmFyaWFuemFzIGRlYmlkbyBhIHF1ZSB0YW1wb2NvIHNlIHZpb2zDsyBlbnRyZSBsb3MgcGVyaW9kb3MuIEVzdG8gZGEgdW4gcG9jbyBtw6FzIGRlIHJlc3BhbGRvIGEgc2VndWlyIGNvbiBlbCBhbsOhbGlzaXMsIHB1ZXMgZXMgbcOhcyByb2J1c3RvIGEgbGEgdmlvbGFjacOzbiBkZWwgc3VwdWVzdG8gZGUgbm9ybWFsaWRhZCBxdWUgYWwgZGUgaG9tb2dlbmVpZGFkIGRlIHZhcmlhbnphcy4KYGBge3J9CmNhcjo6bGV2ZW5lVGVzdChQVH5EaWV0YSwgZGF0YSA9IGRmKQpgYGAKCiMjIyMgQXBsaWNhY2nDs24gZGVsIEFOT1ZBLgoKRWwgQU5PVkEgZGUgZG9zIHbDrWFzIGVzIHVuIGNhc28gZXNwZWNpYWwgZGVsIEFOT1ZBIGZhY3RvcmlhbCwgZW4gZWwgY3XDoWwgw7puaWNhbWVudGUgaGF5IGRvcyBmYWN0b3JlcyB5IE5PIHNlIGNvbnNpZGVyYSBzdSBpbnRlcmFjY2nDs24sIHBvciBsbyBxdWUgZWwgbW9kbyBkZSBkZWNsYXJhcmxvIGVzIHVuYSBmw7NybXVsYSBlbiBsYSBjdcOhbCBsb3MgZmFjdG9yZXMgc2UgY29uc2lkZXJhbiBkZSBtYW5lcmEgYWRpdGl2YS4gTGEgZm9ybWEgdHJhZGljaW9uYWwgZGUgcmVwb3J0YXIgbG9zIHJlc3VsdGFkb3MgZGUgZXN0ZSBBTk9WQSBzZXLDrWE6IGh1Ym8gdW4gZWZlY3RvIHNpZ25pZmljYXRpdm8gZGUgbGFzIGRpZXRhcyAoRigyLCAxNTMpID0gMTEuNDU7IHAgPCAwLjAwMDEpIHkgZGUgbG9zIHBlcmlvZG9zIChGKDIsIDE1MykgPSA1NjAuNDI7IHAgPCAwLjAwMDEpLgoKYGBge3J9CmRvc192aWFzIDwtIGFvdihQVH5EaWV0YStQZXJpb2RvLCBkYXRhID0gZGYpCnN1bW1hcnkoZG9zX3ZpYXMpCmBgYAoKIyMjIyBQcnVlYmEgcG9zdC1ob2MuIAoKRW4gZXN0ZSBjYXNvIHR1dmltb3MgdmFsb3JlcyBkZSBwIG11eSBwZXF1ZcOxb3MgcGFyYSBhbWJvcyBmYWN0b3JlcywgcmVhbGljZW1vcyBsYSBwcnVlYmEgSFNEIGRlIFR1a2V5LiBBbCB2ZXIgbGEgc2FsaWRhIHB1ZWRlcyBpbnRlcnByZXRhciBxdWUgZXN0YSBlcyB1bmEgbGlzdGEsIHkgcXVlIHBvZHLDrWFtb3MgYWNjZWRlciBhIGxvcyByZXN1bHRhZG9zIGRlIGN1YWxxdWllciBmYWN0b3IgdXRpbGl6YW5kbyBlbCBvcGVyYWRvciBgJGAgKGBUdWtleUhTRChhb3Zfb2JqKSRmYWN0b3JgKS4gQXF1w60sIGxhcyBkaWZlcmVuY2lhcyBzZSBlbmNvbnRyYXJvbiBlbnRyZSBsYSBkaWV0YSBDIHkgbGFzIG90cmFzIGRvcywgcGVybyBubyBlbnRyZSBBIHkgQi4gCmBgYHtyfQpUdWtleUhTRChkb3NfdmlhcykKYGBgCgpDb25zaWRlcmFuZG8gZWwgZGlzZcOxbyBmYWN0b3JpYWwgZGUgbGEgYmFzZSBkZSBkYXRvcywgwr9jw7NtbyBpbnRlcnByZXRhcsOtYXMgZXN0b3MgcmVzdWx0YWRvcz8gwr9wb2RlbW9zIGNvbmZpYXIgZW4gZWxsb3M/IExhIHJlc3B1ZXN0YSBxdWUgeW8gZXNwZXJhcsOtYSBlcyBxdWUgbm8sIHB1ZXMgc2kgZWwgZXhwZXJpbWVudG8gZnVlIGJpZW4gZGlzZcOxYWRvIGFsIGluaWNpbyB0b2RvcyBsb3MgYW5pbWFsZXMgZGViw61hbiB0ZW5lciBhcHJveGltYWRhbWVudGUgbGFzIG1pc21hcyBjYXJhY3RlcsOtc3RpY2FzIHkgdmltb3MgdGFudG8gZ3LDoWZpY2FtZW50ZSBjb21vIGVuIGFtYm9zIEFOT1ZBcyBxdWUgaHVibyB1biBjcmVjaW1pZW50by4gVmVhbW9zIHF1w6kgcGFzYSBjb24gbGFzIGRpc3RyaWJ1Y2lvbmVzIHV0aWxpemFuZG8gdW4gZ3LDoWZpY28gZGUgaW50ZXJhY2Npw7NuLgoKYGBge3J9CmdncGxvdChkYXRhID0gZGYsIGFlcyh4ID0gRGlldGEsIHkgPSBQVCwgZmlsbCA9IFBlcmlvZG8pKSArCiAgZ2VvbV92aW9saW4oYWxwaGEgPSAwLjUsIHNob3cubGVnZW5kID0gVCkgKwogIGxhYnModGl0bGUgPSAiRGlzdHJpYnVjacOzbiBkZSBQVCBlbiBsb3MgdHJlcyBtb21lbnRvcyBkZSBtZWRpY2nDs24iLAogICAgICAgeCA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgIHkgPSBlbGVtZW50X2JsYW5rKCkpICsKICB0aGVtZV9idygpCmBgYAoKRXMgZXZpZGVudGUgcXVlIGVuIGxvcyB0cmVzIHRyYXRhbWllbnRvcyBodWJvIHVuIGNyZWNpbWllbnRvLCBlbCBjdWFsIGFkZW3DoXMgcGFyZWNlIGhhYmVyIHNpZG8gYmFzdGFudGUgc2ltaWxhci4gRXN0ZSBlcyB1biBlamVtcGxvIGRlbCBlcnJvciBkZSB0aXBvIElJSSBxdWUgbWVuY2lvbmFiYSBlbiBsYSBjbGFzZSBkZSBwcnVlYmFzIGRlIGhpcMOzdGVzaXM6IHV0aWxpemFyIGxhIG1hdGVtw6F0aWNhIGNvcnJlY3RhIHBhcmEgcmVzcG9uZGVyIGxhIHByZWd1bnRhIGVxdWl2b2NhZGEuIFZlYW1vcyBxdcOpIHBhc2Egc2kgcmVhbGl6YW1vcyB1biBBTk9WQSBmYWN0b3JpYWwuCgojIyMgQU5PVkEgZmFjdG9yaWFsCkNvbW8gdGUgcG9kcsOhcyBpbWFnaW5hciBhIHBhcnRpciBkZSBsbyBtZW5jaW9uYWRvIHNvYnJlIGVsIEFOT1ZBIGRlIGRvcyB2w61hcywgZXN0ZSBBTk9WQSBlcyBsYSB2ZXJzacOzbiBtw6FzIGdlbmVyYWxpemFkYSBlbiBsYSBjdWFsIHBvZGVtb3MgdXRpbHphciBtw6FzIGRlIGRvcyBmYWN0b3JlcyB5IGFkZW3DoXMgYW5hbGl6YXIgc3UgaW50ZXJhY2Npw7NuLiBTaWdhbW9zIGNvbiBsYSBiYXNlIGFudGVyaW9yLCBlbiBlc3RlIGNhc28gY29uc2lkZXJhbmRvIHRhbWJpw6luIGVsIGZhY3RvciByw6lwbGljYToKCmBgYHtyfQpkZiRSZXAgPC0gZmFjdG9yKGRmJFJlcCwgbGV2ZWxzID0gYygiQSIsICJCIikpCmBgYAoKIyMjIyBDb21wcm9iYWNpw7NuIGRlIHN1cHVlc3RvcwpObyBoYXkgc29ycHJlc2FzIGVuIG5pbmd1bm8gZGUgbG9zIGRvcyBjYXNvcywgbGFzIGludGVycHJldGFjaW9uZXMgZGUgbG9zIHJlc3VsdGFkb3Mgc29uIGxhcyBtaXNtYXMgcXVlIGVuIGVsIGNhc28gYW50ZXJpb3I7IGVzIGRlY2lyLCBlc3RlIE5PIGVzIGVsIG1vZG8gY29ycmVjdG8gZGUgY29tcHJvYmFyIGxhIG5vcm1hbGlkYWQuIEN1YW5kbyBoYWJsZW1vcyBkZWwgQU5PVkEgZGUgbWVkaWRhcyByZXBldGlkYXMgdmVyZW1vcyB1biBlamVtcGxvIGRlIGPDs21vIGhhY2VybG8gZGUgbWFuZXJhIGNvcnJlY3RhIChub3JtYWxpZGFkIGRlIHVuIGZhY3RvciBkYWRvcyBsb3Mgbml2ZWxlcyBkZWwgb3RybyBmYWN0b3IpLgpgYGB7cn0KIyMgRGF0YS5mcmFtZSBhIGxsZW5hcgpub3JtIDwtIGRhdGEuZnJhbWUoZ3J1cG8gPSBOQSwgVyA9IE5BLCBwID0gTkEpCgojIyBOaXZlbGVzIGEgcHJvYmFyOgpsdmxzIDwtIGxldmVscyhkZiRSZXApCgpmb3IgKGkgaW4gc2VxX2Fsb25nKGx2bHMpKSB7CiAgdGVtcCA8LSBzaGFwaXJvLnRlc3QoZGYkUFRbZGYkUmVwID09IGx2bHNbaV1dKQogIG5vcm1baSxdIDwtIGMobHZsc1tpXSwgdGVtcCRzdGF0aXN0aWMsIHRlbXAkcC52YWx1ZSkKfQpub3JtCmBgYAoKYGBge3J9CmNhcjo6bGV2ZW5lVGVzdChQVH5SZXAsIGRhdGEgPSBkZikKYGBgCgojIyMjIEFwbGljYWNpw7NuIGRlbCBBTk9WQQoKTGEgw7puaWNhIGRpZmVyZW5jaWEgY29uIGVsIGNhc28gYW50ZXJpb3IgZXMgcXVlIGVzdGEgdmV6IHV0aWxpemFyZW1vcyBlbCBvcGVyYWRvciBgKmAgcGFyYSBhw7FhZGlyIGxvcyBudWV2b3MgdMOpcm1pbm9zLCBlbiB2ZXogZGUgaGFjZXJsbyBkZSBmb3JtYSBhZGl0aXZhLiBIYWNpZW5kbyBlc3RvIGxhIHRhYmxhIGRlbCBBTk9WQSBjYW1iaWEsIGVuIGRvbmRlIHByaW1lcm8gYXBhcmVjZSBlbCBlZmVjdG8gZGUgY2FkYSBmYWN0b3IgYW5hbGl6YWRvIGRlIG1hbmVyYSBpbmRlcGVuZGlldGUgKGNvbW8gc2kgaHViaWVyYW1vcyBoZWNobyB1biBBTk9WQSBkZSAidHJlcyB2w61hcyIpIHkgZGVzcHXDqXMgbG9zIHTDqXJtaW5vcyBkZSBpbnRlcmFjY2nDs24uIExhIGludGVyYWNjacOzbiBlbnRyZSBkb3MgZmFjdG9yZXMgcmVwcmVzZW50YSB1biBlZmVjdG8gY29tYmluYWRvIGRlIGxvcyBmYWN0b3JlcyBpbnZvbHVjcmFkb3MgZW4gbGEgdmFyaWFibGUgYW5hbGl6YWRhOyBlcyBkZWNpciwgY3VhbmRvIGhheSBpbnRlcmFjY2nDs24gZW50cmUgZG9zIGZhY3RvcmVzIGVsIGVmZWN0byBkZSB1bm8gImRlcGVuZGUiIGRlbCBlbCBuaXZlbCBkZWwgb3Ryby4gCgpgYGB7cn0KZmFjdCA8LSBhb3YoUFR+RGlldGEqUGVyaW9kbypSZXAsIGRhdGEgPSBkZikKc3VtbWFyeShmYWN0KQpgYGAKCiMjIyMgUHJ1ZWJhIHBvc3QtaG9jCgpFbiBlc3RlIGNhc28gZWwgw7puaWNvIHTDqXJtaW5vIGRlIGludGVyYWNjacOzbiBjb24gcmVzdWx0YWRvcyBzaWduaWZpY2F0aXZvcyBlcyBsYSBpbnRlcmFjY2nDs24gZW50cmUgUGVyaW9kbyB5IFLDqXBsaWNhIChgUGVyaW9kbzpSZXBgKSwgbG8gY3VhbCBpbmRpY2EgcXVlIGVsIGNvbXBvcnRhbWllbnRvIGRlIGxvcyBwZXJpb2RvcyBmdWUgZGlmZXJlbnRlIGVudHJlIHLDqXBsaWNhcy4gUmVhbGljZW1vcyBsYXMgcHJ1ZWJhcyBwb3N0LWhvYyBjb3JyZXNwb25kaWVudGVzLiBBdW5xdWUgZW5jb250cmFtb3MgdW4gZWZlY3RvIHNpZ25pZmljYXRpdm8gZGUgbGFzIHLDqXBsaWNhcywgZXN0ZSBmYWN0b3Igw7puaWNhbWVudGUgdGllbmUgZG9zIG5pdmVsZXMsIHBvciBsbyBxdWUgcmVhbGl6YXIgbGEgcHJ1ZWJhIHBvc3QtaG9jIGVzIG9jaW9zbyB5LCBwb3IgdGFudG8sIGxhIHJlYWxpemFyZW1vcyDDum5pY2FtZW50ZSBwYXJhIFBlcmlvZG86UmVwLiBOb3RhIHF1ZSBkZWJpZG8gYSBsYSBwcmVzZW5jaWEgZGVsIG9wZXJhZG9yIGA6YCBlbiBlbCBub21icmUgZGVsIHTDqXJtaW5vIGVzIG5lY2VzYXJpbyB1dGlsaXphciBjb21pbGxhcyBwYXJhIHBvZGVyIGFjY2VkZXIgYSBlc2UgYXRyaWJ1dG86CmBgYHtyfQpUdWtleUhTRChmYWN0KSQiUGVyaW9kbzpSZXAiCmBgYAoKVmVtb3MgcXVlIHByw6FjdGljYW1lbnRlIHRvZG9zIGxvcyBjb250cmFzdGVzIGZ1ZXJvbiBzaWduaWZpY2F0aXZvcywgY29uIGV4Y2VwY2nDs24gZGVsIHBlcmlvZG8gaW5pY2lhbCAocCA9IDAuOSkuIEVzdG8gc3VnZXJpcsOtYSBxdWUgZWwgY29tcG9ydGFtaWVudG8gZGUgbGFzIHLDqXBsaWNhcyBubyBmdWUgaG9tb2fDqW5lbyBhIHRyYXbDqXMgZGVsIHRpZW1wby4gU2kgcmVncmVzYW1vcyBicmV2ZW1lbnRlIGEgbGEgdGFibGEgZGVsIEFOT1ZBIHZlcmVtb3MgcXVlIGh1Ym8gMjIgb2JzZXJ2YWNpb25lcyBmYWx0YW50ZXMsIGxhcyBjdWFsZXMgY29ycmVzcG9uZGVuIGEgbGEgbW9ydGFsaWRhZCBkdXJhbnRlIGVsIGV4cGVyaW1lbnRvIHkgcG9kcsOtYW4gdGFtYmnDqW4gZXhwbGljYXIgZXN0b3MgY2FtYmlvcy4gRGViaWRvIGEgbGEgaW1wcmFjaXRpY2lkYWQvaW1wb3NpYmlsaWRhZCBkZSBtYXJjYXIgbyBpZGVudGlmaWNhciBjYWRhIGd1cHB5IG5vIGVzIHBvc2libGUgYXBsaWNhciB1biBhbm92YSBkZSBtZWRpZGFzIHJlcGV0aWRhcyBjb24gZXN0b3MgZGF0b3M7IHNpbiBlbWJhcmdvLCBwb2RlbW9zIGVqZW1wbGlmaWNhcmxvIGNvbiBvdHJvcyBkYXRvcy4KCiMjIyBBTk9WQSBkZSBtZWRpZGFzIHJlcGV0aWRhcwoKRWwgQU5PVkEgZGUgbWVkaWRhcyByZXBldGlkYXMgZXMgb3RybyBkZSBsb3MgbW9kZWxvcyBkZSBBTk9WQSwgZWwgY3VhbCBwb2RlbW9zIGNvbnNpZGVyYXIgY29tbyB1bmEgZXh0ZW5zacOzbiBkZSBsYSBwcnVlYmEgdCBwYXJhIG11ZXN0cmFzIGRlcGVuZGllbnRlczsgZXMgZGVjaXIsIGVuIGxhIGN1YWwgbG9zIG1pc21vcyBpbmRpdmlkdW9zIGZ1ZXJvbiBtZWRpZG9zIGVuIG3DoXMgZGUgZG9zIG9jYXNpb25lcywgZGVub21pbmFkbyBBTk9WQSBkZSBtZWRpZGFzIHJlcGV0aWRhcyBkZSB1bmEgdsOtYS4gU2kgdGVuZW1vcyBubyBzb2xvIGxvcyBkaXN0aW50b3MgdGllbXBvcyBkZSBtZWRpY2nDs24gc2lubyB0YW1iacOpbiBmYWN0b3JlcyBhZGljaW9uYWxlcyBlbnRvbmNlcyB0ZW5kcmVtb3MgQU5PVkFzIGRlIG1lZGlkYXMgcmVwZXRpZGFzIGRlIGRvcyB2w61hcyAodGllbXBvIHkgdW4gZmFjdG9yIGFkaWNpb25hbCkgbyBkZSB0cmVzIHbDrWFzICh0aWVtcG8geSBkb3MgZmFjdG9yZXMgYWRpY2lvbmFsZXMpLiBBbCBpZ3VhbCBxdWUgZW4gZWwgQU5PVkEgIm5vcm1hbCIgY29tZW5jZW1vcyBkZXNkZSBhYmFqbyBjb24gZWwgZGUgdW5hIHbDrWEuCgojIyMjIEFOT1ZBIGRlIG1lZGlkYXMgcmVwZXRpZGFzIGRlIHVuYSB2w61hCgpDYXJndWVtb3MgbG9zIGRhdG9zIGRlIGVqZW1wbG8gKHNlbGZlc3RlZW0gZGUgbGEgbGlicmVyw61hIGRhdGFyaXVtKSwgbG9zIGN1YWxlcyBzb24gdW5hIG1lZGlkYSBkZSBhdXRvZXN0aW1hIG1lZGlkYSBlbiB0cmVzIG9jYXNpb25lcyBkaXN0aW50YXM6CgpgYGB7cn0KZGF0YSgic2VsZmVzdGVlbSIsIHBhY2thZ2UgPSAiZGF0YXJpdW0iKQpoZWFkKHNlbGZlc3RlZW0pCmBgYApMYSBiYXNlIHNlIGVuY3VlbnRyYSBlbiBmb3JtYXRvIGNvcnRvLCBwb3IgbG8gcXVlIGhhYnLDoSBxdWUgcGFzYXJsYSBhIGZvcm1hdG8gbGFyZ286CmBgYHtyfQplc3RpbWEgPC0gcmVzaGFwZTI6Om1lbHQoc2VsZmVzdGVlbSwgIyBEYXRvcyBhIG1vZGlmaWNhcgogICAgICAgICAgICAgICAgICAgICAgICAgaWQudmFycyA9ICJpZCIsICMgSWRlbnRpZmljYWRvciBwYXJhIGNhZGEgaW5kaXZpZHVvCiAgICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlLnZhcnMgPSBjKCJ0MSIsICJ0MiIsICJ0MyIpLCAjIFZhcmlhYmxlcyBlbiBjb2x1bW5hcwogICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUubmFtZSA9ICJ0aWVtcG8iLCAjIE5vbWJyZSBkZSBsYSBudWV2YSB2YXJpYWJsZSBkZSBhZ3J1cGFtaWVudG8KICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSAiZXN0aW1hIikgIyBOb21icmUgZGUgbGEgbnVldmEgdmFyaWFibGUgbWVkaWRhCmhlYWQoZXN0aW1hKQpgYGAKCiMjIyMjIENvbXByb2JhY2nDs24gZGUgc3VwdWVzdG9zCgpQYXJhIGFnaWxpemFyIGxhcyBjb3NhcyAoeSB1biBwb2NvIGEgbWkgcGVzYXIpLCB1dGlsaWNlbW9zIGBkcGx5cmAgcGFyYSBhcGxpY2FyIGxhIHBydWViYSBkZSBub3JtYWxpZGFkIGEgbG9zIG5pdmVsZXMgZGUgUGVyaW9kby4gYFRpZHl2ZXJzZWAgZXMgYWxnbyBhc8OtIGNvbW8gdW4gZGlhbGVjdG8gZGVudHJvIGRlIFIsIGNvbXB1ZXN0byBkZSBtw7psdGlwbGVzIGxpYnJlcsOtYXMsIGVuIGRvbmRlIGVsIGPDs2RpZ28gc2UgcHVlZGUgZW5jYWRlbmFyIHBhcmEgaGFjZXJsbyBtw6FzIGNvbXBhY3RvIHksIHNlZ8O6biBhbGd1bm9zLCBtw6FzIGxlZ2libGUuICJBIG1pIHBlc2FyIiBwb3JxdWUgbm8gY29uc2lkZXJvIGJ1ZW5hIHByw6FjdGljYSBkaWTDoWN0aWNhIGVuc2XDsWFybG8gYSBxdWllbmVzIHZhbiBjb21lbnphbmRvIGEgYWRxdWlyaXIgZXhwZXJpZW5jaWEsIHB1ZXMgYcOxYWRlIHVuIHBhc28gbcOhcyBkZSBhYnN0cmFjY2nDs24gYWwgcHJvY2Vzby4gSGFiaWVuZG8gZGljaG8gZXN0bywgZWwgZW5jYWRlbmFtaWVudG8gbG8gaW5kaWNhbW9zIGNvbiBlbCBvcGVyYWRvciBgJT4lYCAocGlwZSksIHkgbG8gcXVlIGhhY2Vtb3MgZXMgcXVlIGxvIHF1ZSBlc3TDoSBhIGxhIGl6cXVpZXJkYSBzZSBsbyBwYXNhbW9zIGNvbW8gYXJndW1lbnRvIGEgbG8gcXVlIGVzdMOhIGEgbGEgZGVyZWNoYS4gRXN0byB0ZSBzb25hcsOhIGZhbWlsaWFyIGEgbGEgZm9ybWEgZGUgY29uc3RydWlyIGdyw6FmaWNvcyBlbiBgZ2dwbG90MmAgeSBjb24ganVzdGEgcmF6w7NuLCBwdWVzIHRhbWJpw6luIGZvcm1hIHBhcnRlIGRlbCBgVGlkaXZlcnNlYC4gQ29tbyDDumx0aW1vIGNvbWVudGFyaW8gYWwgcmVzcGVjdG8sIGxhcyBmdW5jaW9uZXMgZGUgbGFzIGRpc3RpbnRhcyBsaWJyZXLDrWFzIGRlIGBUaWRpdmVyc2VgIHB1ZWRlbiB1dGlsaXphcnNlIGNvbiBsYSBzaW50YXhpcyBkZSBSICJub3JtYWwiIHkgdmljZXZlcnNhLCBsYXMgZnVuY2lvbmVzIGRlIFIgIm5vcm1hbCIgcHVlZGVuIHV0aWxpemFyc2UgY29uIGVsIG9wZXJhZG9yIGRlIGVuY2FkZW5hbWllbnRvLiBDb24gZXN0byBxdWllcm8gZGVjaXIgcXVlIG5vIGVzIG5lY2VzYXJpbyB1dGlsaXphciDDum5pY2FtZW50ZSB1bmEgdSBvdHJhIG9wY2nDs24sIHNpbm8gcXVlIHBvZGVtb3MgYXBsaWNhcmxhcyBhIG51ZXN0cmEgY29udmVuaWVuY2lhIChlc2EgZXMgbGEgaWRlYSBkZSBlc2NyaWJpciBudWVzdHJvIGPDs2RpZ28gOykpIEFwbGlxdWVtb3MgZW50b25jZXMgbGEgcHJ1ZWJhIGRlIFNoYXBpcm8tV2lsayBhIGxvcyBkYXRvcyBhZ3J1cGFkb3M6CgpgYGB7cn0KIyBUb21hIGVsIGRhdGEuZnJhbWUsIGFncsO6cGFsbyBwb3IgdGllbXBvIHkgcGFyYSBjYWRhIG5pdmVsIGFwbGljYSBsYSBmdW5jacOzbiBzaGFwaXJvX3Rlc3QgYSBsYSBjb2x1bW5hIGVzdGltYToKZXN0aW1hICU+JSBncm91cF9ieSh0aWVtcG8pICU+JSBzaGFwaXJvX3Rlc3QoZXN0aW1hKQpgYGAKQWhvcmEgbGEgaG9tb2NlZGFzdGljaWRhZCBvLCBtZWpvciBkaWNobywgZWwgc3VwdWVzdG8gZGUgZXNmZXJpY2lkYWQuIEVzdGUgc3VwdWVzdG8gZXMgdW5hICJleHRlbnNpw7NuIiBkZWwgc3VwdWVzdG8gZGUgaG9tb2dlbmVpZGFkIGRlIHZhcmlhbnphcy4gRGVmaW5pbW9zIGVzZmVyaWNpZGFkIGNvbW8gbGEgY29uZGljacOzbiBlbiBsYSBxdWUgbGFzIHZhcmlhbnphcyBkZSBsYXMgKipkaWZlcmVuY2lhcyoqIGVudHJlIHRvZGFzIGxhcyBjb21iaW5hY2lvbmVzIGRlIGxvcyBuaXZlbGVzIGRlIGludGVyw6lzIHNvbiBpZ3VhbGVzLiBMYSB2aW9sYWNpw7NuIGRlIGVzdGUgc3VwdWVzdG8gY29ubGxldmEgdW4gaW5jcmVtZW50byBlbiBsYSBwcm9iYWJpbGlkYWQgZGUgdW4gZmFsc28gcG9zaXRpdm87IGVzIGRlY2lyLCB2dWVsdmUgYSBsYSBwcnVlYmEgZGVtYXNpYWRvICJsaWJlcmFsIiBvICJjcsOpZHVsYSIuIEF1bnF1ZSBlc3RlIHN1cHVlc3RvIGVzIHN1bWFtZW50ZSBpbXBvcnRhbnRlLCBubyBuZWNlc2l0YW1vcyBwcm9iYXJsbyBkaXJlY3RhbWVudGUsIHB1ZXMgbGEgZnVuY2nDs24gY29uIGxhIHF1ZSBpbXBsZW1lbnRhcmVtb3MgZWwgYW7DoWxpc2lzIGhhY2UgbGEgcHJ1ZWJhIGNvcnJlc3BvbmRpZW50ZSAocHJ1ZWJhIGRlIE1hdWNobHkgcGFyYSBlc2ZlcmljaWRhZCkgeSwgYWRlbcOhcywgYXBsaWNhIHVuYSBjb3JyZWNjacOzbiAoY29ycmVjY2nDs24gZGUgR3JlZW5ob3VzZS1HZWlzc2VyKSBhIGxvcyBncmFkb3MgZGUgbGliZXJ0YWQgZGUgYXF1ZWxsb3MgZmFjdG9yZXMgcXVlIHZpb2xlbiBlbCBzdXB1ZXN0by4KCiMjIyMjIEFwbGljYWNpw7NuIGRlbCBBTk9WQQoKRXN0YSB2ZXogbm8gdXRpbGl6YXJlbW9zIGxhIG5vdGFjacOzbiBkZSBmw7NybXVsYSBuaSB0YW4gc2lxdWllcmEgbGEgZnVuY2nDs24gYW92LCBzaW5vIHF1ZSByZWN1cnJpcmVtb3MgYSBsYSBmdW5jacOzbiBgYW5vdmFfdGVzdCgpYCBkZSBsYSBsaWJyZXLDrWEgYHJzdGF0aXhgIHBhcmEgaGFjZXIgbcOhcyBpbnR1aXRpdmEgbGEgZGVjbGFyYWNpw7NuLCBkb25kZSBgZGF0YWAgZXMgZWwgZGF0YS5mcmFtZSBjb24gbG9zIGRhdG9zIChkYWghKSwgYGR2YCBlcyBsYSB2YXJpYWJsZSBkZXBlbmRpZW50ZTsgZXMgZGVjaXIsIG51ZXN0cmEgdmFyaWFibGUgYSBjb21wYXJhciwgYHdpZGAgZXMgdW4gaWRlbnRpZmljYWRvciDDum5pY28gcGFyYSBjYWRhIGluZGl2aWR1byB5IGB3aXRoaW5gIGVsIGZhY3RvciBkZW50cm8gZGVsIGN1YWwgcXVlcmVtb3MgaGFjZXIgbGFzIGNvbXBhcmFjaW9uZXM6CgpgYGB7cn0KYW5vdmFfcmVwMSA8LSByc3RhdGl4Ojphbm92YV90ZXN0KGRhdGEgPSBlc3RpbWEsIGR2ID0gZXN0aW1hLCB3aWQgPSBpZCwgd2l0aGluID0gdGllbXBvKQpnZXRfYW5vdmFfdGFibGUoYW5vdmFfcmVwMSkKYGBgCgpMbyBwcmltZXJvIHF1ZSBsbGFtYSBsYSBhdGVuY2nDs24gZXMgcXVlIGxhIHRhYmxhIGRlIEFOT1ZBIHJlcG9ydGEgcmVzdWx0YWRvcyBwYXJhIHVuYSBwcnVlYmEgZGUgdGlwbyBJSUkuIE9KTyEgZXN0byBubyB0aWVuZSBuYWRhIHF1ZSB2ZXIgY29uIGVsIGVycm9yIHRpcG8gSUlJIHF1ZSBtZW5jaW9uw6kgZW4gbGEgY2xhc2UgZGUgcHJ1ZWJhcyBkZSBoaXDDs3Rlc2lzIChlc2UgZXJyb3Igbm8gZXMgZm9ybWFsKS4gRWwgdGlwbyBkZSBwcnVlYmEgaGFjZSByZWZlcmVuY2lhIGFsIHRpcG8gZGUgQU5PVkEgcXVlIHNlIGVzdMOhIHJlYWxpemFuZG8gbywgbWVqb3IgZGljaG8sIGFsIG1vZG8gZW4gZWwgcXVlIHNlIGNhbGN1bGFuIGxhcyBzdW1hcyBkZSBjdWFkcmFkb3MuIFNpIHRlIGludGVyZXNhIGxlZXIgbcOhcyBhbCByZXNwZWN0bywgdmlzaXRhIFtlc3RlXShodHRwczovL3d3dy5pYm0uY29tL3N1cHBvcnQva25vd2xlZGdlY2VudGVyL1NTTFZNQl8yNC4wLjAvc3Bzcy9jb20gbW9uL2dsbV9nZW5lcmFsX2ZhY3RvcmlhbF9zdW1fb2Zfc3F1YXJlcy5odG1sKSBvIFtlc3RlXShodHRwOi8vd3d3LnN0YXRzb2Z0LmNvbS90ZXh0Ym9vay8pIGVubGFjZS4gCgpPdHJhIGNvc2EgcXVlIGRlYmUgbGxhbWFyIHR1IGF0ZW5jacOzbiBlcyBlbCB0w6lybWlubyBnZXMuIEVzdGUgZXMgZWwgZmFjdG9yIGRlIGNvcnJlY2Npw7NuIGRlIEdyZWVuaG91c2UtR2Vpc3NlciBhIGxvcyBncmFkb3MgZGUgbGliZXJ0YWQuIEVsIG1vZG8gZGUgcmVwb3J0YXIgZXN0b3MgcmVzdWx0YWRvcyBzZXLDrWEgYWxnbyBjb21vICoibGFzIG1lZGlkYXMgZGUgYXV0b2VzdGltYSBhIHRyYXbDqXMgZGVsIHRpZW1wbyBmdWVyb24gc2lnbmlmaWNhdGl2YW1lbnRlIGRpZmVyZW50ZXMgKEYoMiwxOCkgPSA1NS41LCBwIDwgMC4wMDAxOyAkXGV0YV4yJCBnZW5lcmFsaXphZG8gPSAwLjgyKSIqLiBFbCB0w6lybWlubyAkXGV0YV4yJCBnZW5lcmFsaXphZG8gbG8gcHVlZGVzIGVuY29udHJhciB0YW1iacOpbiBjb21vICRcaGF0e1xlcHNpbG9ufSQuCgojIyMjIyBQcnVlYmEgcG9zdC1ob2MKCkRlYmlkbyBhIHF1ZSBsYXMgbWVkaWRhcyBzb24gcmVwZXRpZGFzLCBubyBwb2RlbW9zIGFwbGljYXIgbGEgcHJ1ZWJhIGRlIGRpZmVyZW5jaWFzIGhvbmVzdGFzIGRlIFR1a2V5LCBwZXJvIHPDrSBwb2RlbW9zIGFwbGljYXIgcHJ1ZWJhcyB0IGRlIFN0dWRlbnQgcGFyZWFkYXMgeSBjb3JyZWdpciBlbCB2YWxvciBkZSBwIGNvbiB1bmEgY29ycmVjY2nDs24gZGUgQm9uZmVycm9uaS4gRW4gbGEgc2VjY2nDs24gZGUgbXVsdGl2YXJpYWRvIHNlIGFib3JkYXLDoSBlc3RhIGNvcnJlY2Npw7NuLCBwZXJvIGVudGnDqW5kZWxhIGVuIGVzdGUgbW9tZW50byBjb21vIGVsIG1vZG8gZGUgZXZpdGFyIHF1ZSBpbmNyZW1lbnRlbW9zIGxhIHByb2JhYmlsaWRhZCBkZSB1biBmYWxzbyBwb3NpdGl2byB5LCBlbiBjb25zZWN1ZW5jaWEsIGRlYmVyZW1vcyBkZSBpbnRlcnByZXRhciBsb3MgdmFsb3JlcyBkZSBsYSBjb2x1bW5hIHAuYWRqLiBWaWVuZG8gbGEgdGFibGEsIGVzIHBvc2libGUgY29uY2x1aXIgcXVlIGh1Ym8gZGlmZXJlbmNpYXMgZW50cmUgbGFzIG1lZGlkYXMgZGUgYXV0b2VzdGltYSBlbiBsb3MgdHJlcyBwZXJpb2Rvcy4KYGBge3J9CnB3dCA8LSBwYWlyd2lzZV90X3Rlc3QoZGF0YSA9IGVzdGltYSwgZXN0aW1hfnRpZW1wbywgcGFpcmVkID0gVCwgcC5hZGp1c3QubWV0aG9kID0gImJvbmZlcnJvbmkiKQpwd3QKYGBgCgojIyMjIEFOT1ZBIGRlIG1lZGlkYXMgcmVwZXRpZGFzIGRlIGRvcyB2w61hcwpBbCBpZ3VhbCBxdWUgZW4gZWwgQU5PVkEgIm5vcm1hbCIsIGhhYmxhbW9zIGRlIGRvcyB2w61hcyBjdWFuZG8gdGVuZW1vcyBkb3MgZmFjdG9yZXMsIGVuIGVzdGUgY2FzbyBzb24gZWwgdGllbXBvIHkgYWxndW5vIGFkaWNpb25hbC4gUGFyYSBlamVtcGxpZmljYXJsbyB1dGlsaXphcmVtb3MgbGEgYmFzZSBkZSBkYXRvcyBgc2VsZmVzdGVlbTJgIGRlIGBkYXRhcml1bWAuCgpgYGB7cn0KZGF0YSgic2VsZmVzdGVlbTIiLCBwYWNrYWdlID0gImRhdGFyaXVtIikKZXN0aW1hMiA8LSByZXNoYXBlMjo6bWVsdChzZWxmZXN0ZWVtMiwgIyBEYXRvcyBhIG1vZGlmaWNhcgogICAgICAgICAgICAgICAgICAgICAgICAgaWQudmFycyA9IGMoImlkIiwgInRyZWF0bWVudCIpLCAjIElkZW50aWZpY2Fkb3JlcyBwYXJhIGNhZGEgaW5kaXZpZHVvCiAgICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlLnZhcnMgPSBjKCJ0MSIsICJ0MiIsICJ0MyIpLCAjIFZhcmlhYmxlcyBlbiBjb2x1bW5hcwogICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUubmFtZSA9ICJ0aWVtcG8iLCAjIE5vbWJyZSBkZSBsYSBudWV2YSB2YXJpYWJsZSBkZSBhZ3J1cGFtaWVudG8KICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSAiZXN0aW1hIikgIyBOb21icmUgZGUgbGEgbnVldmEgdmFyaWFibGUgbWVkaWRhCmhlYWQoZXN0aW1hMikKYGBgCgojIyMjIyBDb21wcm9iYWNpw7NuIGRlIHN1cHVlc3RvcwpBbCBpZ3VhbCBxdWUgZW4gZWwgQU5PVkEgZGUgbWVkaWRhcyByZXBldGlkYXMsIMO6bmljYW1lbnRlIGNvbXByb2JhcmVtb3MgZWwgU3VwdWVzdG8gZGUgTm9ybWFsaWRhZCwgc29sbyBxdWUgYXF1w60gbG8gaGFyZW1vcyBjb25zaWRlcmFuZG8gbGEgImFuaWRhY2nDs24iIGRlIGxvcyBmYWN0b3JlczsgZXMgZGVjaXIsIHF1ZSBsYXMgbWVkaWRhcyByZXBldGlkYXMgZnVlcm9uIHBhcmEgY2FkYSB0cmF0YW1pZW50bzoKYGBge3J9CmVzdGltYTIgJT4lIGdyb3VwX2J5KHRyZWF0bWVudCwgdGllbXBvKSAlPiUgc2hhcGlyb190ZXN0KGVzdGltYSkKYGBgCgpBcGFyZW50ZW1lbnRlIGh1Ym8gZGVzdmlhY2lvbmVzIGRlIGxhIG5vcm1hbGlkYWQgZW4gZWwgdDEgcGFyYSBlbCBncnVwbyBjb250cm9sLiBQb2RlbW9zIGNvcnJvYm9yYXJsbyBjb24gdW4gZ3LDoWZpY28gUVEuIEFwYXJlbnRlbWVudGUgZXMgY3VscGEgZGUgZGUgYWxndW5vcyBwdW50b3MgbGlnZXJhbWVudGUgZnVlcmEgZGVsIHJlc3RvIGRlIGxhIHRlbmRlbmNpYSB1YmljYWRvcyBlbiBlbCBjZW50cm8uIFJlY29yZGVtb3MgcXVlIGVsIEFOT1ZBIGVzIHJvYnVzdG8gYSBjaWVydGFzIHZpb2xhY2lvbmVzIGRlIGxhIG5vcm1hbGlkYWQsIHkgZW4gZXN0ZSBjYXNvIG5vIHBhcmVjZW4gc2VyIGVzcGVjaWFsbWVudGUgc2VyaWFzLiBTaWdhbW9zIGNvbiBlbCBhbsOhbGlzaXMuCmBgYHtyLCBmaWcuaGVpZ2h0PSA3LCBmaWcud2lkdGg9Ny8xLjZ9CmdncHVicjo6Z2dxcXBsb3QoZXN0aW1hMiwgImVzdGltYSIsIGdndGhlbWUgPSB0aGVtZV9idygpKSArIGZhY2V0X2dyaWQodGllbXBvfnRyZWF0bWVudCwgbGFiZWxsZXIgPSAibGFiZWxfYm90aCIpCmBgYAoKIyMjIyMgQXBsaWNhY2nDs24gZGVsIEFOT1ZBClV0aWxpemFyZW1vcyBsYSBtaXNtYSBlc3RydWN0dXJhIHF1ZSBlbiBlbCBjYXNvIGFudGVyaW9yOyBsYSB1bmljYSBkaWZlcmVuY2lhIGVzIHF1ZSBhbCBhcmd1bWVudG8gYHdpdGhpbmAgbGUgcGFzYXJlbW9zIHVuIHZlY3RvciBjb24gZG9zIGZhY3RvcmVzOgpgYGB7cn0KYW5vdmFfcmVwMiA8LSBhbm92YV90ZXN0KGRhdGEgPSBlc3RpbWEyLCBkdiA9IGVzdGltYSwgd2lkID0gaWQsIHdpdGhpbiA9IGModHJlYXRtZW50LCB0aWVtcG8pKQpnZXRfYW5vdmFfdGFibGUoYW5vdmFfcmVwMikKYGBgCgpEZSBsYSB0YWJsYSBwb2RlbW9zIGNvbmNsdWlyIHF1ZSB0b2RvcyBsb3MgY29udHJhc3RlcyBmdWVyb24gc2lnbmlmaWNhdGl2b3MsIGxvIGN1YWwgaW5kaWNhIHF1ZSBodWJvIGRpZmVyZW5jaWFzIGVudHJlIGxvcyB0cmF0YW1pZW50b3MgKEYoMSwgMTEpLCA9IDE1LjU7IHAgPSAwLjAyKSwgZW50cmUgbG9zIHRpZW1wb3MgKEYoMS4zMSwgMTQuMzcpLCA9IDI3LjQ7IHAgPCAwLjAwMDEpIHkgdGFtYmllbiB1biBlZmVjdG8gY29tYmluYWRvIChGKDIsMjIpID0gMzAuNDsgcCA8IDAuMDAwMSkuIERlYmlkbyBhIHF1ZSBsb3MgZWZlY3RvcyBwcmluY2lwYWxlcyAoInNvbG9zIikgbm8gc29uIHN1ZmljaWVudGVzIHBhcmEgZGVzY3JpYmlyIGxvcyBkYXRvcywgZWwgcHJvY2VzbyBwb3N0LWhvYyBlcyB1biBwb2NvIG3DoXMgY29tcGxpY2FkbyBxdWUgZW4gZWwgY2FzbyBhbnRlcmlvci4KCiMjIyMjIFBydWViYXMgcG9zdC1ob2MKCkRlYmlkbyBhIGxhIHNpZ25pZmljYW5jaWEgZGVsIHTDqXJtaW5vIGRlIGludGVyYWNjacOzbiBlcyBuZWNlc2FyaW8gZGVzY29tcG9uZXJsbyBlbjoKCmEpIEVmZWN0byBwcmluY2lwYWwgc2ltcGxlOyBlcyBkZWNpciwgdW4gbW9kZWxvIGRlIHVuYSB2w61hIGRlIGxhIHByaW1lcmEgdmFyaWFibGUgcGFyYSBjYWRhIG5pdmVsIGRlIGxhIHNlZ3VuZGEuIERlYmlkbyBhIHF1ZSBoYWNlcmxvIGEgbWFubyBlcyB1biBwb2NvIHRlZGlvc28sIGVuY2FkZW5lbW9zIGVsIHByb2Nlc286CgpgYGB7cn0KYW5vdmFfcmVwMl9wb3N0MSA8LSBlc3RpbWEyICU+JQogICAgICAgICAgICAgICAgICAgIGdyb3VwX2J5KHRpZW1wbykgJT4lICMgQWdydXBhIGxhIGJhc2UgcG9yIGNhZGEgbml2ZWwgZGUgdGllbXBvCiAgICAgICAgICAgICAgICAgICAgYW5vdmFfdGVzdChkdiA9IGVzdGltYSwgd2lkID0gaWQsIHdpdGhpbiA9IHRyZWF0bWVudCkgJT4lICMgQXBsaWNhIHVuIEFOT1ZBIGRlIG1lZGlkYXMgcmVwZXRpZGFzIHBhcmEgY2FkYSBuaXZlbAogICAgICAgICAgICAgICAgICAgIGdldF9hbm92YV90YWJsZSgpICU+JSAjIEV4dHJhZSBsb3MgcmVzdWx0YWRvcwogICAgICAgICAgICAgICAgICAgIGFkanVzdF9wdmFsdWUobWV0aG9kID0gImJvbmZlcnJvbmkiKSAjIEFqdXN0YSBsb3MgdmFsb3JlcyBkZSBwCgphbm92YV9yZXAyX3Bvc3QxCmBgYAoKYikgQXBsaWNhciB1bmEgcHJ1ZWJhIHQgZGUgU3R1ZGVudCBwYXJhIGRhdG9zIGRlcGVuZGllbnRlcyBlbiBsb3MgdMOpcm1pbm9zIHNpZ25pZmljYXRpdm9zLiBEZWJpZG8gYSBxdWUgdHJhdGFtaWVudG8gdGllbmUgc29sbyBkb3Mgbml2ZWxlcywgcmVhbGl6YXIgZXN0ZSBwcm9jZXNvIGVzIHJlZHVuZGFudGU7IGRlIGhlY2hvLCBsb3MgdmFsb3JlcyBkZSBwIHNlcsOhbiBpZ3VhbGVzIGEgbG9zIG1vc3RyYWRvcyBhdHLDoXM7IHNpbiBlbWJhcmdvLCBoYWfDoW1vc2xvIGNvbiBmaW5lcyBkZW1vc3RyYXRpdm9zOgoKYGBge3J9CnB3dF8yIDwtIGVzdGltYTIgJT4lCiAgICAgICAgIGdyb3VwX2J5KHRpZW1wbykgJT4lCiAgICAgICAgIHBhaXJ3aXNlX3RfdGVzdChlc3RpbWF+dHJlYXRtZW50LCBwYWlyZWQgPSBULCBwLmFkanVzdC5tZXRob2QgPSAiYm9uZmVycm9uaSIpCnB3dF8yCmBgYAoKCkVzdG8gZXMgdG9kbyBwYXJhIGxhIGNsYXNlIGRlIGhveS4gRXMgdW5hIGNsYXNlIGJhc3RhbnRlIGV4dGVuc2EgeSBhw7puIGNvbiBlbGxvIHNlIHF1ZWRhcm9uIGZ1ZXJhIGFsZ3VuYXMgdmFyaWFudGVzIGRlIEFOT1ZBOyBzaW4gZW1iYXJnbywgY3JlbyBxdWUgZXN0b3MgY3VicmVuIGxvcyBjYXNvcyBtw6FzIGdlbmVyYWxlcy4gwqFOb3MgdmVtb3MgZW4gbGEgc2lndWllbnRlIQ==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("c7_param.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
