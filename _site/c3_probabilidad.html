<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="M. en C. Arturo Bell Enríquez García" />


<title>Probabilidad</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Bioestadística con R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Clases
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Biología como Ciencia de Datos</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c1_Intro_R.html">Introducción a R</a>
        </li>
        <li>
          <a href="c2_ggplot2.html">ggplot2</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Herramientas Básicas</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c3_probabilidad.html">Probabilidad</a>
        </li>
        <li>
          <a href="c4_muestreo.html">Teoría del Muestreo</a>
        </li>
        <li>
          <a href="c5_descriptiva.html">Estadística Descriptiva</a>
        </li>
        <li>
          <a href="c6_ph0.html">Pruebas de hipótesis</a>
        </li>
        <li>
          <a href="c7_param.html">Técnicas Paramétricas</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Relaciones Lineales</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c8_rls.html">Modelo Lineal Simple</a>
        </li>
        <li>
          <a href="c9_glm.html">Modelos Lineales Generalizados</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">No Paramétrico y No Lineal</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c10_no_par.html">Técnicas No Paramétricas</a>
        </li>
        <li>
          <a href="c11_no_lineal.html">Modelos No Lineales</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Técnicas Multivariadas</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c11_intro_mv.html">Introducción</a>
        </li>
        <li>
          <a href="c12_no_sup.html">No supervisadas</a>
        </li>
        <li>
          <a href="c13_comps_mv.html">Comparaciones Multivariadas</a>
        </li>
        <li>
          <a href="c14_clasificacion.html">Clasificaciones</a>
        </li>
        <li>
          <a href="c15_regs_mv.html">Regresiones Múltiples</a>
        </li>
      </ul>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Probabilidad</h1>
<h4 class="author">M. en C. Arturo Bell Enríquez García</h4>

</div>


<p><strong><a href="https://youtu.be/OJbGK6Q_Psg">VIDEO</a></strong></p>
<div id="frecuencia-a-largo-plazo" class="section level2">
<h2>Frecuencia a largo plazo</h2>
<p>Supongamos que queremos conocer la frecuencia relativa a largo plazo de obtener “cara” (H) al lanzar una moneda. La intuición nos dice que deberá de ser 0.5, pero pretendamos que no es tan obvio. Todo lo que sabemos es que existe algún proceso subyacente que genera “H” o “T” (cruz) cuando obtememos una muestra. Este proceso tiene un parámetro <span class="math inline">\(\theta\)</span>, cuyo valor es <span class="math inline">\(\theta = 0.5\)</span>. Si es todo lo que conocemos, podemos <strong>aproximar</strong> la probabilidad de H realizando el experimento N veces. Para ello primero realicemos 500 experimentos y calculemos la proporción acumulada hasta el i-esimo experimento:</p>
<pre class="r"><code>volado &lt;- function(N){
  # N es el número de lanzamientos o experimentos que realizaremos
  
  # Después realizaremos los muestreos:
  sec &lt;- sample(x       = c(0, 1),
                prob    = c(.5 ,.5),
                size    = N,
                replace = TRUE)
  # Calculamos la suma acumulativa. Si solo obtenemos 1s el resultado final será 500, si solo obtenemos 0s el resultado final será 0.
  r &lt;- cumsum(sec)
  
  # Generamos un identificador para cada muestreo 
  n &lt;- 1:N
  # Calculamos la proporción H:T acumulada a cada muestreo
  prop.acum &lt;- r/n
  # Generamos el data.frame con los resultados
  resultados &lt;- data.frame(n, prop.acum) 
  
  return(list(N, sec, prop.acum, resultados))
}</code></pre>
<pre class="r"><code>res.list &lt;- volado(N = 500)
N &lt;- res.list[[1]]
sec &lt;- res.list[[2]]
prop.acum &lt;- res.list[[3]]
resultados &lt;- res.list[[4]]</code></pre>
<p>Podríamos ver los resultados numéricamente; sin embargo, una mejor aproximación para comprender el cambio en las proporciones es utilizar un gráfico de líneas:</p>
<pre class="r"><code>library(ggplot2)
prop.plot &lt;- ggplot(data = resultados, aes(x = n, y = prop.acum)) +
             geom_line(colour = &quot;deepskyblue4&quot;, linetype = &quot;solid&quot;, size = 0.7) +
             geom_point(colour = &quot;deepskyblue4&quot;, alpha = 0.1, fill = NA, 
                        shape = &quot;circle&quot;, stroke = 1, size = 4) +
             labs(x = &quot;# de experimento&quot;,
                  y = element_blank(),
                  title = &quot;Aproximación de P(H) con 500 experimentos&quot;,
                  subtitle = &quot;Proporción H:T acumulativa&quot;,
                  caption = &quot;Datos simulados&quot;) +
             theme(panel.grid.minor = element_blank(),
                   panel.grid.major = element_blank(),
                   panel.background = element_blank(),
                   axis.line = element_blank(),
                   aspect.ratio = 1/1.61,
                   axis.ticks = element_blank(),
                   text = element_text(colour = &quot;gray50&quot;)
                   ) +
             scale_y_continuous(breaks = c(0.0,0.5,1),
                                labels = c(&quot;T&quot;, &quot;0.5&quot;, &quot;H&quot;)) +
             scale_x_continuous(n.breaks = 5) +
             geom_hline(yintercept = 1, colour = rgb(118,78,144, maxColorValue = 255),
                        alpha = 0.9, linetype = &quot;dashed&quot;) +
             geom_hline(yintercept = 0.5, colour = &quot;lightslategray&quot;,
                        alpha = 0.9, linetype = &quot;dashed&quot;) +
             geom_hline(yintercept = 0, colour = rgb(106,16,166, maxColorValue = 255),
                        alpha = 0.9, linetype = &quot;dashed&quot;) +
             annotate(&quot;text&quot;, x = 450, y = 0.75, 
                      label = paste(&quot;Final = &quot;, round(prop.acum[N],2)),
                      colour = &quot;gray50&quot;) +
             annotate(&quot;text&quot;, x = 65, y = 0.25,
                      label = paste(&quot;Tiros: &quot;, 
                                    paste(c(&quot;T&quot;,&quot;H&quot;)[sec[1:10]+1], 
                                                     collapse = &quot;&quot;), &quot;...&quot;), colour = &quot;gray50&quot;)

prop.plot</code></pre>
<p><img src="c3_probabilidad_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div id="distribución-de-probabilidades" class="section level2">
<h2>Distribución de probabilidades</h2>
<p>Veamos ahora la distribución de probabilidades de la proporción H:T o, en otras palabras, la distribución de probabilidades de la probabilidad de que obtengamos H. Para hacer esto debemos de tener algunas consideraciones, la principal es que la información “cruda” no nos funciona para este propósito, tenemos que procesarla y ponerla en términos de frecuencias:</p>
<pre class="r"><code># Primero generamos los intervalos que nos interesan:
amplitud &lt;- 0.1
intervaln &lt;- seq(0, 1, amplitud) # Una secuencia de 0 a 1, cada &quot;amplitud&quot;

# Ahora calculamos las frecuencias para cada intervalo:

freq.table &lt;- transform(table(cut(resultados$prop.acum, intervaln)))

# Cambiemos el nombre de las columnas
colnames(freq.table) &lt;- c(&quot;Intervalo&quot;, &quot;Frecuencia&quot;)

# Generamos una nueva columna que contenga únicamente los límites utilizando la función sapply, 
# Creamos primero una función personalizada:

intervals &lt;- function(x){
  if(!require(&quot;stringr&quot;)) install.packages(&quot;stringr&quot;, dependencies = T) # En caso de que no esté instalada la librería stringr, R la instalará
  
  ifelse(nchar(as.character(x))&gt;7, # Si el número de caracteres es mayor a 7:
         str_replace(substr(x, 2, 8), &quot;,&quot;, &quot;:&quot;), # Extrae los caracteres 2:8 y reemplaza las &quot;,&quot; con &quot;:&quot;
         str_replace(substr(x, 2, 6), &quot;,&quot;, &quot;:&quot;)) # Si no, extrae solamente los caracteres 2:8 y reemplaza las &quot;,&quot; con &quot;:&quot;
}
# Aplicamos la función personalizada y generamos una columna nueva:
freq.table[&quot;Lims&quot;] &lt;- sapply(freq.table$Intervalo, intervals)

# Transformamos los 0s en NAs para que no sean considerados al graficar
freq.table$Frecuencia[freq.table$Frecuencia == 0] &lt;- NA

freq.table</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["Intervalo"],"name":[1],"type":["fct"],"align":["left"]},{"label":["Frecuencia"],"name":[2],"type":["int"],"align":["right"]},{"label":["Lims"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"(0,0.1]","2":"NA","3":"0:0.1"},{"1":"(0.1,0.2]","2":"1","3":"0.1:0.2"},{"1":"(0.2,0.3]","2":"18","3":"0.2:0.3"},{"1":"(0.3,0.4]","2":"20","3":"0.3:0.4"},{"1":"(0.4,0.5]","2":"460","3":"0.4:0.5"},{"1":"(0.5,0.6]","2":"NA","3":"0.5:0.6"},{"1":"(0.6,0.7]","2":"NA","3":"0.6:0.7"},{"1":"(0.7,0.8]","2":"NA","3":"0.7:0.8"},{"1":"(0.8,0.9]","2":"NA","3":"0.8:0.9"},{"1":"(0.9,1]","2":"NA","3":"0.9:1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Ahora que tenemos el resultado en un data.frame, podemos graficarlo (NOTA: Las advertencias no son errores, son solo por los NAs que incluimos anteriormente):</p>
<pre class="r"><code>freq.plot &lt;- ggplot(data = freq.table, aes(x = Lims, y = Frecuencia)) + 
             geom_bar(stat = &quot;identity&quot;, colour = NA, fill = &quot;deepskyblue4&quot;, alpha = 0.5) +
             geom_text(aes(label = Frecuencia),
                       stat = &quot;identity&quot;,
                       nudge_y = 15, colour = &quot;gray50&quot;) +
             labs(x = &quot;Intervalos&quot;,
                  y = element_blank(),
                  title = &quot;Distribución de frecuencias de lanzamientos de monedas&quot;,
                  subtitle = paste(N, &quot; lanzamientos&quot;),
                  caption = &quot;Datos simulados&quot;) +
             theme(panel.grid.minor = element_blank(),
                   panel.grid.major = element_blank(),
                   panel.background = element_blank(),
                   axis.line = element_blank(),
                   aspect.ratio = 1/1.61,
                   axis.ticks = element_blank(),
                   text = element_text(colour = &quot;gray50&quot;)
                   ) +
             scale_y_continuous(breaks = NULL)
freq.plot</code></pre>
<pre><code>## Warning: Removed 6 rows containing missing values (position_stack).</code></pre>
<pre><code>## Warning: Removed 6 rows containing missing values (geom_text).</code></pre>
<p><img src="c3_probabilidad_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>Ahora que tenemos clara la definición de probabilidad, y tomando en consideración el gráfico anterior, pasaremos a hablar de <strong>Distribuciones de probabilidad</strong>.</p>
<p>Para hacer más eficiente el trabajo en clase, en la siguiente celda únicamente estoy “envolviendo” el código de las celdas anteriores en funciones:</p>
<pre class="r"><code># Función para el cálculo de las distribuciones de frecuencias
tabla.frec &lt;- function(df, var.col, inter = 0.1, min = 0, max = 1, ...){
  # df es el data.frame que contiene los resultados de nuestros experimentos
  # var.col es una cadena de caracter que contiene el nombre de la columna con la variable de interés
  # inter indica la amplitud de los intervalos, por defecto = 0.1
  # min indica el valor mínimo de nuestra variable
  # max indica el valor máximo de nuestra variable
  
  # Primero generamos los intervalos que nos interesan:
  intervaln &lt;- seq(min-inter, max+inter, inter) # Una secuencia de 0 a 1, cada &quot;inter&quot;
  
  # Ahora calculamos las frecuencias para cada intervalo:
  # Nota: Se puede realizar con la función hist; fue decisión personal hacerlo de este modo
  
  freq.table &lt;- transform(table(cut(as.matrix(df[var.col]), intervaln)))
  
  # Cambiemos el nombre de las columnas
  colnames(freq.table) &lt;- c(&quot;Intervalo&quot;, &quot;Frecuencia&quot;)
  
  # Generamos una nueva columna que contenga únicamente los límites utilizando la función sapply, 
  # Creamos primero una función personalizada:
  
  intervals &lt;- function(x){
    if(!require(&quot;stringr&quot;)) install.packages(&quot;stringr&quot;, dependencies = T) # En caso de que no esté instalada la librería stringr, R la instalará
    
    str_replace(str_extract(x,&quot;(?&lt;=\\().+?(?=\\])&quot;), &quot;,&quot;, &quot;:&quot;)
    
  }
  # Aplicamos la función personalizada y generamos una columna nueva:
  freq.table[&quot;Lims&quot;] &lt;- sapply(freq.table$Intervalo, intervals)
  
  # Transformamos los 0s en NAs para que no sean considerados al graficar
  #freq.table$Frecuencia[freq.table$Frecuencia == 0] &lt;- NA
  
  return(freq.table)
}

frec.graf &lt;- function(df, lims.col = 3, freq.col = 2){
  # df es el data.frame con nuestra tabla de frecuencias
  # lims.col es el número de la columna que contiene los intervalos (valores de x)
  # freq.col es el número de la columna que contiene el número de frecuencias
  N = sum(df[,freq.col])
  freq.plot &lt;- ggplot(data = df, aes(x = df[,lims.col], y = df[,freq.col])) + 
             geom_bar(stat = &quot;identity&quot;, colour = NA, fill = &quot;deepskyblue4&quot;, alpha = 0.5) +
             geom_text(aes(label = df[,freq.col]),
                       stat = &quot;identity&quot;,
                       nudge_y = 20, colour = &quot;gray50&quot;) +
             labs(x = &quot;Intervalos&quot;,
                  y = element_blank(),
                  title = &quot;Distribución de frecuencias de lanzamientos de monedas&quot;,
                  subtitle = paste(&quot;Experimentos: &quot;,N),
                  caption = &quot;Datos simulados&quot;) +
             theme(panel.grid.minor = element_blank(),
                   panel.grid.major = element_blank(),
                   panel.background = element_blank(),
                   axis.line = element_blank(),
                   aspect.ratio = 1/1.61,
                   axis.ticks = element_blank(),
                   text = element_text(colour = &quot;gray50&quot;)
                   ) +
             scale_y_continuous(breaks = NULL)
  return(freq.plot)
}</code></pre>
<p>Analicemos la distribución de una variable continua distribuída normalmente, primero cada 5 unidades:</p>
<pre class="r"><code>norm.var &lt;- data.frame(var = rnorm(10000, mean = 67, sd = 7))
norm.res.5 &lt;- tabla.frec(norm.var, var.col = &quot;var&quot;, inter = 5, min = min(norm.var), max = max(norm.var))
frec.graf(norm.res.5)</code></pre>
<p><img src="c3_probabilidad_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>Ahora veámosla con una amplitud de 1:</p>
<pre class="r"><code>norm.res.1 &lt;- tabla.frec(norm.var, var.col = &quot;var&quot;, inter = 1, min = min(norm.var), max = max(norm.var))
frec.graf(norm.res.1)</code></pre>
<p><img src="c3_probabilidad_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p>En este punto, incluso desde la gráfica anterior, el gráfico se comenzó a cargar de demasiada información. Esto era de esperarse, tomando en cuenta que en cada ocasión achicamos los intervalos. Para hacerlos infinitesimalmente pequeños podemos utilizar un tipo de gráfico que se conoce como KDE, basado en la técnica “Kernel Density Estimation” que, en pocas palabras, nos permite mostrar la función de densidad de un conjunto de datos:</p>
<pre class="r"><code>prom.norm.var &lt;- mean(norm.var$var)
de.plot &lt;- ggplot(data = norm.var, aes(var)) + 
           geom_density(kernel = &quot;gaussian&quot;, colour = &quot;deepskyblue4&quot;, fill = &quot;deepskyblue4&quot;, alpha = 0.5) +
           labs(x = &quot;Altura&quot;,
                y = element_blank(),
                title = &quot;Gráfico de densidad de alturas en pulgadas&quot;,
                subtitle = paste(&quot;Experimentos: &quot;,length(norm.var$var), &quot;; Media real = 67&quot;),
                caption = &quot;Datos simulados&quot;) +
           theme(panel.grid.minor = element_blank(),
                 panel.grid.major = element_blank(),
                 panel.background = element_blank(),
                 axis.line = element_blank(),
                 aspect.ratio = 1/1.61,
                 axis.ticks = element_blank(),
                 text = element_text(colour = &quot;gray50&quot;)
                 ) +
           scale_y_continuous(breaks = NULL) +
           geom_vline(xintercept = prom.norm.var, colour = rgb(118,78,144, maxColorValue = 255)) +
           annotate(&quot;text&quot;, x = prom.norm.var, y = 0.06, label = paste(&quot;Media = &quot;, round(prom.norm.var, 1)))
de.plot</code></pre>
<p><img src="c3_probabilidad_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>Podemos ver también la importancia de la representatividad con una animación. Primero generemos un data.frame que contenga todos los estados que nos interesan, en este caso desde 10 muestras hasta 1010, en incrementos de 10 muestras:</p>
<pre class="r"><code>for (i in seq(10,1010,10)) {
  ifelse(i == 10,
         norm.var2 &lt;- data.frame(var = norm.var$var[1:i], iter = i, promedio = mean(norm.var$var[1:i])),
         norm.var2 &lt;- rbind(norm.var2, data.frame(var = norm.var$var[1:i], iter = i, promedio = mean(norm.var$var[1:i])))
         )
}</code></pre>
<p>Ahora utilicemos la librería <code>gganimate</code> para generar la animación de nuestro interés. OJO: Esta animación no se mostrará en la libreta, sino en el visor de RStudio OJO 2: Dependiendo de la complejidad de la animación, el proceso de renderizado puede tomar desde unos cuantos segundos hasta varios minutos o, incluso, más de una hora. Este ejemplo es el segundo caso. NO correr al menos de que tengas bastante tiempo disponible o una computadora con bastante fuerza bruta.</p>
<pre class="r"><code># library(gganimate)
# de.plot &lt;- ggplot(data = norm.var2, aes(var)) +
#           geom_density(kernel = &quot;gaussian&quot;, colour = &quot;deepskyblue4&quot;, fill = &quot;deepskyblue4&quot;, alpha = 0.5) +
#           labs(x = &quot;Altura&quot;,
#                y = element_blank(),
#                title = &quot;Gráfico de densidad de alturas (pulgadas)&quot;,
#                subtitle = paste(&quot;Experimentos: &quot;,length(norm.var$var), &quot;; Media real = 67&quot;),
#                caption = &quot;Datos simulados&quot;) +
#           theme(panel.grid.minor = element_blank(),
#                 panel.grid.major = element_blank(),
#                 panel.background = element_blank(),
#                 axis.line = element_blank(),
#                 aspect.ratio = 1/1.61,
#                 axis.ticks = element_blank(),
#                 text = element_text(colour = &quot;gray50&quot;)
#                 ) +
#           scale_y_continuous(breaks = NULL) +
#           geom_vline(xintercept = norm.var2$promedio, colour = rgb(118,78,144, maxColorValue = 255)) +
#           annotate(&quot;text&quot;, x = norm.var2$promedio, y = 0.06, label = paste(&quot;Media = &quot;, round(norm.var2$promedio, 2))) +
#           transition_states(iter) + labs(subtitle = paste(&quot;Experimentos: {closest_state}; Media real = 67&quot;))
# de.plot</code></pre>
</div>
<div id="intervalos-de-confianza" class="section level2">
<h2>Intervalos de confianza</h2>
<p>Existen distintas formas de calcular los intervalos de confianza para una media en R. Uno de ellos es utilizando la función <code>t.test</code>, el cual utiliza la distribución T-Student para el cálculo. De su salida vemos que nos da el valor del estadístico de prueba (valor crítico), los grados de libertad y un valor de p. Estos elementos los ignoraremos por el momento. Lo que sí nos interesa es la información que aparece por debajo; es decir, los límites de los intervalos de confianza y el valor de la media.</p>
<pre class="r"><code>t.test(norm.var$var, conf.level = 0.95)</code></pre>
<pre><code>## 
##  One Sample t-test
## 
## data:  norm.var$var
## t = 962.68, df = 9999, p-value &lt; 2.2e-16
## alternative hypothesis: true mean is not equal to 0
## 95 percent confidence interval:
##  66.76864 67.04110
## sample estimates:
## mean of x 
##  66.90487</code></pre>
<p>Otra forma de calcularlos es utilizando la librería <code>Rmisc</code>:</p>
<pre class="r"><code>#install.packages(&quot;Rmisc&quot;, dependencies = T)
library(Rmisc)</code></pre>
<pre><code>## Loading required package: plyr</code></pre>
<p>Una vez instalada y cargada, podemos utilizar la función <code>CI(x, ci = a)</code>, donde <code>x</code> es el vector que contiene los datos y <code>a</code> representa el nivel de “confianza” de la estimación. Utilicemos los mismos datos de altura que generamos hace unos momentos:</p>
<pre class="r"><code>CI(norm.var$var, ci = 0.95)</code></pre>
<pre><code>##    upper     mean    lower 
## 67.04110 66.90487 66.76864</code></pre>
<p>Como vemos, la función calcula los intervalos de confianza utilizando la distribución T. Esto se debe a que es el modo más común de realizar la estimación de intervalos para variables continuas. ¿La razón? Eso es tema para una clase posterior, en la que explicaré las características que hacen que la distribución T sea uno de los principales “caballitos de batalla” en la estadística.</p>
<p>Una última opción es utilizar la librería <code>Rcompanion</code>, la cual tiene un método de la estimación de intervalos basado en “remuestreos” Bootstrap. Al igual que en el resto de librerías, habrá que instalarla:</p>
<pre class="r"><code>#install.packages(&quot;Rcompanion&quot;, dependencies = T)
library(rcompanion)</code></pre>
<p>Una de las funciones que podemos utilizar es <code>groupwiseMean(formula, data, conf, R)</code>, donde <code>formula</code> indica al mismo tiempo las columnas de la variable continua y la variable de agrupamiento, tal que: <code>var ~ grupo</code>; <code>data</code> indica el <code>data.frame</code> que contiene la información, <code>conf</code> que indica la amplitud de los intervalos y finalmente <code>R</code> que indica el número de replicas bootstrap a realizar. Partiendo de lo anterior:</p>
<pre class="r"><code>groupwiseMean(var~1, data = norm.var, conf = 0.95, R = 500)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[".id"],"name":[1],"type":["chr"],"align":["left"]},{"label":["n"],"name":[2],"type":["int"],"align":["right"]},{"label":["Mean"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Conf.level"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Trad.lower"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Trad.upper"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"NA","2":"10000","3":"66.9","4":"0.95","5":"66.8","6":"67"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Vemos que la salida es un poco más compleja; sin embargo, lo más relevante es que los intervalos son sumamente cercanos a los que calculamos anteriormente. ¿Esto quiere decir que no tiene caso realizar las réplicas bootstrap? No, simplemente que sus beneficios los veremos aplicándolas a la situación para la que fueron pensadas; es decir, distribuciones sesgadas y no normales a diferencia de la variable que analizamos aquí.</p>
<p>Recursos recomendados para esta sección: <a href="https://rcompanion.org/handbook/C_03.html">Rcompanion</a> y <a href="http://www.biostathandbook.com/confidence.html">Handbook of Biological Statistics</a></p>
</div>
<div id="ejercicio" class="section level2">
<h2>Ejercicio</h2>
<p>Para la tarea de esta semana cargarás el archivo <code>Datos1.csv</code> con el código aquí incluído y, de manera similar a como se vio durante la clase, realizarás la estimación de la media, la desviación estándar y los intervalos de confianza (utilizando cualquiera de las formas aquí vistas) para diferentes tamaños de muestra (ojo a la función <code>sample()</code>). El objetivo es ver cómo cambian tanto la estimación puntual como la amplitud de los intervalos al incrementar el tamaño de muestra.</p>
<p>Parte <strong>OPCIONAL</strong>:Si quieres desafiarte un poco más, considera alguna de las variables Dieta o Periodo como un grupos dentro de la población y realiza las estimaciones con esa consideración. Puedes también intentar presentar los resultados de manera gráfica (agrupados o no). Una alternativa es usar un gráfico KDE y mostrar los límites como líneas verticales, otra alternativa es un gráfico similar al que se presentó en clase, con el número de muestras en el eje x y un gráfico con líneas de error para el eje y. Este apartado OPCIONAL no tiene una “respuesta correcta”, así que puedes experimentar y presentar (o no) los resultados de la manera en que tú consideres se resuelven los objetivos.</p>
<pre class="r"><code>df &lt;- read.table(file.choose(), header = F, skip = 1, sep = &quot;,&quot;)
colnames(df) &lt;- c(&quot;Dieta&quot;, &quot;Periodo&quot;, &quot;Rep&quot;, &quot;LT&quot;, &quot;PT&quot;)
head(df)</code></pre>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiUHJvYmFiaWxpZGFkIgphdXRob3I6ICJNLiBlbiBDLiBBcnR1cm8gQmVsbCBFbnLDrXF1ZXogR2FyY8OtYSIKb3V0cHV0OgogICAgaHRtbF9kb2N1bWVudDoKICAgICAgZGZfcHJpbnQ6IHBhZ2VkCiAgICAgIHRoZW1lOiBjb3NtbwogICAgICB0b2M6IFRSVUUKICAgICAgdG9jX2Zsb2F0OiBUUlVFCiAgICAgIGNvZGVfZG93bmxvYWQ6IFRSVUUKLS0tCioqW1ZJREVPXShodHRwczovL3lvdXR1LmJlL09KYkdLNlFfUHNnKSoqCgojIyBGcmVjdWVuY2lhIGEgbGFyZ28gcGxhem8KClN1cG9uZ2Ftb3MgcXVlIHF1ZXJlbW9zIGNvbm9jZXIgbGEgZnJlY3VlbmNpYSByZWxhdGl2YSBhIGxhcmdvIHBsYXpvIGRlIG9idGVuZXIgImNhcmEiIChIKSBhbCBsYW56YXIgdW5hIG1vbmVkYS4gTGEgaW50dWljacOzbiBub3MgZGljZSBxdWUgZGViZXLDoSBkZSBzZXIgMC41LCBwZXJvIHByZXRlbmRhbW9zIHF1ZSBubyBlcyB0YW4gb2J2aW8uIFRvZG8gbG8gcXVlIHNhYmVtb3MgZXMgcXVlIGV4aXN0ZSBhbGfDum4gcHJvY2VzbyBzdWJ5YWNlbnRlIHF1ZSBnZW5lcmEgIkgiIG8gIlQiIChjcnV6KSBjdWFuZG8gb2J0ZW1lbW9zIHVuYSBtdWVzdHJhLiBFc3RlIHByb2Nlc28gdGllbmUgdW4gcGFyw6FtZXRybyAkXHRoZXRhJCwgY3V5byB2YWxvciBlcyAkXHRoZXRhID0gMC41JC4gU2kgZXMgdG9kbyBsbyBxdWUgY29ub2NlbW9zLCBwb2RlbW9zICoqYXByb3hpbWFyKiogbGEgcHJvYmFiaWxpZGFkIGRlIEggcmVhbGl6YW5kbyBlbCBleHBlcmltZW50byBOIHZlY2VzLiBQYXJhIGVsbG8gcHJpbWVybyByZWFsaWNlbW9zIDUwMCBleHBlcmltZW50b3MgeSBjYWxjdWxlbW9zIGxhIHByb3BvcmNpw7NuIGFjdW11bGFkYSBoYXN0YSBlbCBpLWVzaW1vIGV4cGVyaW1lbnRvOgoKYGBge3J9CnZvbGFkbyA8LSBmdW5jdGlvbihOKXsKICAjIE4gZXMgZWwgbsO6bWVybyBkZSBsYW56YW1pZW50b3MgbyBleHBlcmltZW50b3MgcXVlIHJlYWxpemFyZW1vcwogIAogICMgRGVzcHXDqXMgcmVhbGl6YXJlbW9zIGxvcyBtdWVzdHJlb3M6CiAgc2VjIDwtIHNhbXBsZSh4ICAgICAgID0gYygwLCAxKSwKICAgICAgICAgICAgICAgIHByb2IgICAgPSBjKC41ICwuNSksCiAgICAgICAgICAgICAgICBzaXplICAgID0gTiwKICAgICAgICAgICAgICAgIHJlcGxhY2UgPSBUUlVFKQogICMgQ2FsY3VsYW1vcyBsYSBzdW1hIGFjdW11bGF0aXZhLiBTaSBzb2xvIG9idGVuZW1vcyAxcyBlbCByZXN1bHRhZG8gZmluYWwgc2Vyw6EgNTAwLCBzaSBzb2xvIG9idGVuZW1vcyAwcyBlbCByZXN1bHRhZG8gZmluYWwgc2Vyw6EgMC4KICByIDwtIGN1bXN1bShzZWMpCiAgCiAgIyBHZW5lcmFtb3MgdW4gaWRlbnRpZmljYWRvciBwYXJhIGNhZGEgbXVlc3RyZW8gCiAgbiA8LSAxOk4KICAjIENhbGN1bGFtb3MgbGEgcHJvcG9yY2nDs24gSDpUIGFjdW11bGFkYSBhIGNhZGEgbXVlc3RyZW8KICBwcm9wLmFjdW0gPC0gci9uCiAgIyBHZW5lcmFtb3MgZWwgZGF0YS5mcmFtZSBjb24gbG9zIHJlc3VsdGFkb3MKICByZXN1bHRhZG9zIDwtIGRhdGEuZnJhbWUobiwgcHJvcC5hY3VtKSAKICAKICByZXR1cm4obGlzdChOLCBzZWMsIHByb3AuYWN1bSwgcmVzdWx0YWRvcykpCn0KYGBgCgpgYGB7cn0KcmVzLmxpc3QgPC0gdm9sYWRvKE4gPSA1MDApCk4gPC0gcmVzLmxpc3RbWzFdXQpzZWMgPC0gcmVzLmxpc3RbWzJdXQpwcm9wLmFjdW0gPC0gcmVzLmxpc3RbWzNdXQpyZXN1bHRhZG9zIDwtIHJlcy5saXN0W1s0XV0KYGBgCgpQb2Ryw61hbW9zIHZlciBsb3MgcmVzdWx0YWRvcyBudW3DqXJpY2FtZW50ZTsgc2luIGVtYmFyZ28sIHVuYSBtZWpvciBhcHJveGltYWNpw7NuIHBhcmEgY29tcHJlbmRlciBlbCBjYW1iaW8gZW4gbGFzIHByb3BvcmNpb25lcyBlcyB1dGlsaXphciB1biBncsOhZmljbyBkZSBsw61uZWFzOgpgYGB7cn0KbGlicmFyeShnZ3Bsb3QyKQpwcm9wLnBsb3QgPC0gZ2dwbG90KGRhdGEgPSByZXN1bHRhZG9zLCBhZXMoeCA9IG4sIHkgPSBwcm9wLmFjdW0pKSArCiAgICAgICAgICAgICBnZW9tX2xpbmUoY29sb3VyID0gImRlZXBza3libHVlNCIsIGxpbmV0eXBlID0gInNvbGlkIiwgc2l6ZSA9IDAuNykgKwogICAgICAgICAgICAgZ2VvbV9wb2ludChjb2xvdXIgPSAiZGVlcHNreWJsdWU0IiwgYWxwaGEgPSAwLjEsIGZpbGwgPSBOQSwgCiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlID0gImNpcmNsZSIsIHN0cm9rZSA9IDEsIHNpemUgPSA0KSArCiAgICAgICAgICAgICBsYWJzKHggPSAiIyBkZSBleHBlcmltZW50byIsCiAgICAgICAgICAgICAgICAgIHkgPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICAgICAgICAgICAgIHRpdGxlID0gIkFwcm94aW1hY2nDs24gZGUgUChIKSBjb24gNTAwIGV4cGVyaW1lbnRvcyIsCiAgICAgICAgICAgICAgICAgIHN1YnRpdGxlID0gIlByb3BvcmNpw7NuIEg6VCBhY3VtdWxhdGl2YSIsCiAgICAgICAgICAgICAgICAgIGNhcHRpb24gPSAiRGF0b3Mgc2ltdWxhZG9zIikgKwogICAgICAgICAgICAgdGhlbWUocGFuZWwuZ3JpZC5taW5vciA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICAgIHBhbmVsLmdyaWQubWFqb3IgPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICAgICAgICAgICAgICBwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgICAgYXNwZWN0LnJhdGlvID0gMS8xLjYxLAogICAgICAgICAgICAgICAgICAgYXhpcy50aWNrcyA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICAgIHRleHQgPSBlbGVtZW50X3RleHQoY29sb3VyID0gImdyYXk1MCIpCiAgICAgICAgICAgICAgICAgICApICsKICAgICAgICAgICAgIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBjKDAuMCwwLjUsMSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzID0gYygiVCIsICIwLjUiLCAiSCIpKSArCiAgICAgICAgICAgICBzY2FsZV94X2NvbnRpbnVvdXMobi5icmVha3MgPSA1KSArCiAgICAgICAgICAgICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSAxLCBjb2xvdXIgPSByZ2IoMTE4LDc4LDE0NCwgbWF4Q29sb3JWYWx1ZSA9IDI1NSksCiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gMC45LCBsaW5ldHlwZSA9ICJkYXNoZWQiKSArCiAgICAgICAgICAgICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSAwLjUsIGNvbG91ciA9ICJsaWdodHNsYXRlZ3JheSIsCiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gMC45LCBsaW5ldHlwZSA9ICJkYXNoZWQiKSArCiAgICAgICAgICAgICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSAwLCBjb2xvdXIgPSByZ2IoMTA2LDE2LDE2NiwgbWF4Q29sb3JWYWx1ZSA9IDI1NSksCiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gMC45LCBsaW5ldHlwZSA9ICJkYXNoZWQiKSArCiAgICAgICAgICAgICBhbm5vdGF0ZSgidGV4dCIsIHggPSA0NTAsIHkgPSAwLjc1LCAKICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gcGFzdGUoIkZpbmFsID0gIiwgcm91bmQocHJvcC5hY3VtW05dLDIpKSwKICAgICAgICAgICAgICAgICAgICAgIGNvbG91ciA9ICJncmF5NTAiKSArCiAgICAgICAgICAgICBhbm5vdGF0ZSgidGV4dCIsIHggPSA2NSwgeSA9IDAuMjUsCiAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHBhc3RlKCJUaXJvczogIiwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3RlKGMoIlQiLCJIIilbc2VjWzE6MTBdKzFdLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZSA9ICIiKSwgIi4uLiIpLCBjb2xvdXIgPSAiZ3JheTUwIikKCnByb3AucGxvdApgYGAKCiMjIERpc3RyaWJ1Y2nDs24gZGUgcHJvYmFiaWxpZGFkZXMKClZlYW1vcyBhaG9yYSBsYSBkaXN0cmlidWNpw7NuIGRlIHByb2JhYmlsaWRhZGVzIGRlIGxhIHByb3BvcmNpw7NuIEg6VCBvLCBlbiBvdHJhcyBwYWxhYnJhcywgbGEgZGlzdHJpYnVjacOzbiBkZSBwcm9iYWJpbGlkYWRlcyBkZSBsYSBwcm9iYWJpbGlkYWQgZGUgcXVlIG9idGVuZ2Ftb3MgSC4gUGFyYSBoYWNlciBlc3RvIGRlYmVtb3MgZGUgdGVuZXIgYWxndW5hcyBjb25zaWRlcmFjaW9uZXMsIGxhIHByaW5jaXBhbCBlcyBxdWUgbGEgaW5mb3JtYWNpw7NuICJjcnVkYSIgbm8gbm9zIGZ1bmNpb25hIHBhcmEgZXN0ZSBwcm9ww7NzaXRvLCB0ZW5lbW9zIHF1ZSBwcm9jZXNhcmxhIHkgcG9uZXJsYSBlbiB0w6lybWlub3MgZGUgZnJlY3VlbmNpYXM6CgpgYGB7ciwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0KIyBQcmltZXJvIGdlbmVyYW1vcyBsb3MgaW50ZXJ2YWxvcyBxdWUgbm9zIGludGVyZXNhbjoKYW1wbGl0dWQgPC0gMC4xCmludGVydmFsbiA8LSBzZXEoMCwgMSwgYW1wbGl0dWQpICMgVW5hIHNlY3VlbmNpYSBkZSAwIGEgMSwgY2FkYSAiYW1wbGl0dWQiCgojIEFob3JhIGNhbGN1bGFtb3MgbGFzIGZyZWN1ZW5jaWFzIHBhcmEgY2FkYSBpbnRlcnZhbG86CgpmcmVxLnRhYmxlIDwtIHRyYW5zZm9ybSh0YWJsZShjdXQocmVzdWx0YWRvcyRwcm9wLmFjdW0sIGludGVydmFsbikpKQoKIyBDYW1iaWVtb3MgZWwgbm9tYnJlIGRlIGxhcyBjb2x1bW5hcwpjb2xuYW1lcyhmcmVxLnRhYmxlKSA8LSBjKCJJbnRlcnZhbG8iLCAiRnJlY3VlbmNpYSIpCgojIEdlbmVyYW1vcyB1bmEgbnVldmEgY29sdW1uYSBxdWUgY29udGVuZ2Egw7puaWNhbWVudGUgbG9zIGzDrW1pdGVzIHV0aWxpemFuZG8gbGEgZnVuY2nDs24gc2FwcGx5LCAKIyBDcmVhbW9zIHByaW1lcm8gdW5hIGZ1bmNpw7NuIHBlcnNvbmFsaXphZGE6CgppbnRlcnZhbHMgPC0gZnVuY3Rpb24oeCl7CiAgaWYoIXJlcXVpcmUoInN0cmluZ3IiKSkgaW5zdGFsbC5wYWNrYWdlcygic3RyaW5nciIsIGRlcGVuZGVuY2llcyA9IFQpICMgRW4gY2FzbyBkZSBxdWUgbm8gZXN0w6kgaW5zdGFsYWRhIGxhIGxpYnJlcsOtYSBzdHJpbmdyLCBSIGxhIGluc3RhbGFyw6EKICAKICBpZmVsc2UobmNoYXIoYXMuY2hhcmFjdGVyKHgpKT43LCAjIFNpIGVsIG7Dum1lcm8gZGUgY2FyYWN0ZXJlcyBlcyBtYXlvciBhIDc6CiAgICAgICAgIHN0cl9yZXBsYWNlKHN1YnN0cih4LCAyLCA4KSwgIiwiLCAiOiIpLCAjIEV4dHJhZSBsb3MgY2FyYWN0ZXJlcyAyOjggeSByZWVtcGxhemEgbGFzICIsIiBjb24gIjoiCiAgICAgICAgIHN0cl9yZXBsYWNlKHN1YnN0cih4LCAyLCA2KSwgIiwiLCAiOiIpKSAjIFNpIG5vLCBleHRyYWUgc29sYW1lbnRlIGxvcyBjYXJhY3RlcmVzIDI6OCB5IHJlZW1wbGF6YSBsYXMgIiwiIGNvbiAiOiIKfQojIEFwbGljYW1vcyBsYSBmdW5jacOzbiBwZXJzb25hbGl6YWRhIHkgZ2VuZXJhbW9zIHVuYSBjb2x1bW5hIG51ZXZhOgpmcmVxLnRhYmxlWyJMaW1zIl0gPC0gc2FwcGx5KGZyZXEudGFibGUkSW50ZXJ2YWxvLCBpbnRlcnZhbHMpCgojIFRyYW5zZm9ybWFtb3MgbG9zIDBzIGVuIE5BcyBwYXJhIHF1ZSBubyBzZWFuIGNvbnNpZGVyYWRvcyBhbCBncmFmaWNhcgpmcmVxLnRhYmxlJEZyZWN1ZW5jaWFbZnJlcS50YWJsZSRGcmVjdWVuY2lhID09IDBdIDwtIE5BCgpmcmVxLnRhYmxlCmBgYAoKQWhvcmEgcXVlIHRlbmVtb3MgZWwgcmVzdWx0YWRvIGVuIHVuIGRhdGEuZnJhbWUsIHBvZGVtb3MgZ3JhZmljYXJsbyAoTk9UQTogTGFzIGFkdmVydGVuY2lhcyBubyBzb24gZXJyb3Jlcywgc29uIHNvbG8gcG9yIGxvcyBOQXMgcXVlIGluY2x1aW1vcyBhbnRlcmlvcm1lbnRlKTogCgpgYGB7cn0KZnJlcS5wbG90IDwtIGdncGxvdChkYXRhID0gZnJlcS50YWJsZSwgYWVzKHggPSBMaW1zLCB5ID0gRnJlY3VlbmNpYSkpICsgCiAgICAgICAgICAgICBnZW9tX2JhcihzdGF0ID0gImlkZW50aXR5IiwgY29sb3VyID0gTkEsIGZpbGwgPSAiZGVlcHNreWJsdWU0IiwgYWxwaGEgPSAwLjUpICsKICAgICAgICAgICAgIGdlb21fdGV4dChhZXMobGFiZWwgPSBGcmVjdWVuY2lhKSwKICAgICAgICAgICAgICAgICAgICAgICBzdGF0ID0gImlkZW50aXR5IiwKICAgICAgICAgICAgICAgICAgICAgICBudWRnZV95ID0gMTUsIGNvbG91ciA9ICJncmF5NTAiKSArCiAgICAgICAgICAgICBsYWJzKHggPSAiSW50ZXJ2YWxvcyIsCiAgICAgICAgICAgICAgICAgIHkgPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICAgICAgICAgICAgIHRpdGxlID0gIkRpc3RyaWJ1Y2nDs24gZGUgZnJlY3VlbmNpYXMgZGUgbGFuemFtaWVudG9zIGRlIG1vbmVkYXMiLAogICAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IHBhc3RlKE4sICIgbGFuemFtaWVudG9zIiksCiAgICAgICAgICAgICAgICAgIGNhcHRpb24gPSAiRGF0b3Mgc2ltdWxhZG9zIikgKwogICAgICAgICAgICAgdGhlbWUocGFuZWwuZ3JpZC5taW5vciA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICAgIHBhbmVsLmdyaWQubWFqb3IgPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICAgICAgICAgICAgICBwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgICAgYXNwZWN0LnJhdGlvID0gMS8xLjYxLAogICAgICAgICAgICAgICAgICAgYXhpcy50aWNrcyA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICAgIHRleHQgPSBlbGVtZW50X3RleHQoY29sb3VyID0gImdyYXk1MCIpCiAgICAgICAgICAgICAgICAgICApICsKICAgICAgICAgICAgIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBOVUxMKQpmcmVxLnBsb3QKYGBgCgoKQWhvcmEgcXVlIHRlbmVtb3MgY2xhcmEgbGEgZGVmaW5pY2nDs24gZGUgcHJvYmFiaWxpZGFkLCB5IHRvbWFuZG8gZW4gY29uc2lkZXJhY2nDs24gZWwgZ3LDoWZpY28gYW50ZXJpb3IsIHBhc2FyZW1vcyBhIGhhYmxhciBkZSAqKkRpc3RyaWJ1Y2lvbmVzIGRlIHByb2JhYmlsaWRhZCoqLgoKUGFyYSBoYWNlciBtw6FzIGVmaWNpZW50ZSBlbCB0cmFiYWpvIGVuIGNsYXNlLCBlbiBsYSBzaWd1aWVudGUgY2VsZGEgw7puaWNhbWVudGUgZXN0b3kgImVudm9sdmllbmRvIiBlbCBjw7NkaWdvIGRlIGxhcyBjZWxkYXMgYW50ZXJpb3JlcyBlbiBmdW5jaW9uZXM6CgpgYGB7cn0KIyBGdW5jacOzbiBwYXJhIGVsIGPDoWxjdWxvIGRlIGxhcyBkaXN0cmlidWNpb25lcyBkZSBmcmVjdWVuY2lhcwp0YWJsYS5mcmVjIDwtIGZ1bmN0aW9uKGRmLCB2YXIuY29sLCBpbnRlciA9IDAuMSwgbWluID0gMCwgbWF4ID0gMSwgLi4uKXsKICAjIGRmIGVzIGVsIGRhdGEuZnJhbWUgcXVlIGNvbnRpZW5lIGxvcyByZXN1bHRhZG9zIGRlIG51ZXN0cm9zIGV4cGVyaW1lbnRvcwogICMgdmFyLmNvbCBlcyB1bmEgY2FkZW5hIGRlIGNhcmFjdGVyIHF1ZSBjb250aWVuZSBlbCBub21icmUgZGUgbGEgY29sdW1uYSBjb24gbGEgdmFyaWFibGUgZGUgaW50ZXLDqXMKICAjIGludGVyIGluZGljYSBsYSBhbXBsaXR1ZCBkZSBsb3MgaW50ZXJ2YWxvcywgcG9yIGRlZmVjdG8gPSAwLjEKICAjIG1pbiBpbmRpY2EgZWwgdmFsb3IgbcOtbmltbyBkZSBudWVzdHJhIHZhcmlhYmxlCiAgIyBtYXggaW5kaWNhIGVsIHZhbG9yIG3DoXhpbW8gZGUgbnVlc3RyYSB2YXJpYWJsZQogIAogICMgUHJpbWVybyBnZW5lcmFtb3MgbG9zIGludGVydmFsb3MgcXVlIG5vcyBpbnRlcmVzYW46CiAgaW50ZXJ2YWxuIDwtIHNlcShtaW4taW50ZXIsIG1heCtpbnRlciwgaW50ZXIpICMgVW5hIHNlY3VlbmNpYSBkZSAwIGEgMSwgY2FkYSAiaW50ZXIiCiAgCiAgIyBBaG9yYSBjYWxjdWxhbW9zIGxhcyBmcmVjdWVuY2lhcyBwYXJhIGNhZGEgaW50ZXJ2YWxvOgogICMgTm90YTogU2UgcHVlZGUgcmVhbGl6YXIgY29uIGxhIGZ1bmNpw7NuIGhpc3Q7IGZ1ZSBkZWNpc2nDs24gcGVyc29uYWwgaGFjZXJsbyBkZSBlc3RlIG1vZG8KICAKICBmcmVxLnRhYmxlIDwtIHRyYW5zZm9ybSh0YWJsZShjdXQoYXMubWF0cml4KGRmW3Zhci5jb2xdKSwgaW50ZXJ2YWxuKSkpCiAgCiAgIyBDYW1iaWVtb3MgZWwgbm9tYnJlIGRlIGxhcyBjb2x1bW5hcwogIGNvbG5hbWVzKGZyZXEudGFibGUpIDwtIGMoIkludGVydmFsbyIsICJGcmVjdWVuY2lhIikKICAKICAjIEdlbmVyYW1vcyB1bmEgbnVldmEgY29sdW1uYSBxdWUgY29udGVuZ2Egw7puaWNhbWVudGUgbG9zIGzDrW1pdGVzIHV0aWxpemFuZG8gbGEgZnVuY2nDs24gc2FwcGx5LCAKICAjIENyZWFtb3MgcHJpbWVybyB1bmEgZnVuY2nDs24gcGVyc29uYWxpemFkYToKICAKICBpbnRlcnZhbHMgPC0gZnVuY3Rpb24oeCl7CiAgICBpZighcmVxdWlyZSgic3RyaW5nciIpKSBpbnN0YWxsLnBhY2thZ2VzKCJzdHJpbmdyIiwgZGVwZW5kZW5jaWVzID0gVCkgIyBFbiBjYXNvIGRlIHF1ZSBubyBlc3TDqSBpbnN0YWxhZGEgbGEgbGlicmVyw61hIHN0cmluZ3IsIFIgbGEgaW5zdGFsYXLDoQogICAgCiAgICBzdHJfcmVwbGFjZShzdHJfZXh0cmFjdCh4LCIoPzw9XFwoKS4rPyg/PVxcXSkiKSwgIiwiLCAiOiIpCiAgICAKICB9CiAgIyBBcGxpY2Ftb3MgbGEgZnVuY2nDs24gcGVyc29uYWxpemFkYSB5IGdlbmVyYW1vcyB1bmEgY29sdW1uYSBudWV2YToKICBmcmVxLnRhYmxlWyJMaW1zIl0gPC0gc2FwcGx5KGZyZXEudGFibGUkSW50ZXJ2YWxvLCBpbnRlcnZhbHMpCiAgCiAgIyBUcmFuc2Zvcm1hbW9zIGxvcyAwcyBlbiBOQXMgcGFyYSBxdWUgbm8gc2VhbiBjb25zaWRlcmFkb3MgYWwgZ3JhZmljYXIKICAjZnJlcS50YWJsZSRGcmVjdWVuY2lhW2ZyZXEudGFibGUkRnJlY3VlbmNpYSA9PSAwXSA8LSBOQQogIAogIHJldHVybihmcmVxLnRhYmxlKQp9CgpmcmVjLmdyYWYgPC0gZnVuY3Rpb24oZGYsIGxpbXMuY29sID0gMywgZnJlcS5jb2wgPSAyKXsKICAjIGRmIGVzIGVsIGRhdGEuZnJhbWUgY29uIG51ZXN0cmEgdGFibGEgZGUgZnJlY3VlbmNpYXMKICAjIGxpbXMuY29sIGVzIGVsIG7Dum1lcm8gZGUgbGEgY29sdW1uYSBxdWUgY29udGllbmUgbG9zIGludGVydmFsb3MgKHZhbG9yZXMgZGUgeCkKICAjIGZyZXEuY29sIGVzIGVsIG7Dum1lcm8gZGUgbGEgY29sdW1uYSBxdWUgY29udGllbmUgZWwgbsO6bWVybyBkZSBmcmVjdWVuY2lhcwogIE4gPSBzdW0oZGZbLGZyZXEuY29sXSkKICBmcmVxLnBsb3QgPC0gZ2dwbG90KGRhdGEgPSBkZiwgYWVzKHggPSBkZlssbGltcy5jb2xdLCB5ID0gZGZbLGZyZXEuY29sXSkpICsgCiAgICAgICAgICAgICBnZW9tX2JhcihzdGF0ID0gImlkZW50aXR5IiwgY29sb3VyID0gTkEsIGZpbGwgPSAiZGVlcHNreWJsdWU0IiwgYWxwaGEgPSAwLjUpICsKICAgICAgICAgICAgIGdlb21fdGV4dChhZXMobGFiZWwgPSBkZlssZnJlcS5jb2xdKSwKICAgICAgICAgICAgICAgICAgICAgICBzdGF0ID0gImlkZW50aXR5IiwKICAgICAgICAgICAgICAgICAgICAgICBudWRnZV95ID0gMjAsIGNvbG91ciA9ICJncmF5NTAiKSArCiAgICAgICAgICAgICBsYWJzKHggPSAiSW50ZXJ2YWxvcyIsCiAgICAgICAgICAgICAgICAgIHkgPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICAgICAgICAgICAgIHRpdGxlID0gIkRpc3RyaWJ1Y2nDs24gZGUgZnJlY3VlbmNpYXMgZGUgbGFuemFtaWVudG9zIGRlIG1vbmVkYXMiLAogICAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IHBhc3RlKCJFeHBlcmltZW50b3M6ICIsTiksCiAgICAgICAgICAgICAgICAgIGNhcHRpb24gPSAiRGF0b3Mgc2ltdWxhZG9zIikgKwogICAgICAgICAgICAgdGhlbWUocGFuZWwuZ3JpZC5taW5vciA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICAgIHBhbmVsLmdyaWQubWFqb3IgPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICAgICAgICAgICAgICBwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgICAgYXNwZWN0LnJhdGlvID0gMS8xLjYxLAogICAgICAgICAgICAgICAgICAgYXhpcy50aWNrcyA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICAgIHRleHQgPSBlbGVtZW50X3RleHQoY29sb3VyID0gImdyYXk1MCIpCiAgICAgICAgICAgICAgICAgICApICsKICAgICAgICAgICAgIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBOVUxMKQogIHJldHVybihmcmVxLnBsb3QpCn0KYGBgCgpBbmFsaWNlbW9zIGxhIGRpc3RyaWJ1Y2nDs24gZGUgdW5hIHZhcmlhYmxlIGNvbnRpbnVhIGRpc3RyaWJ1w61kYSBub3JtYWxtZW50ZSwgcHJpbWVybyBjYWRhIDUgdW5pZGFkZXM6CgpgYGB7cn0Kbm9ybS52YXIgPC0gZGF0YS5mcmFtZSh2YXIgPSBybm9ybSgxMDAwMCwgbWVhbiA9IDY3LCBzZCA9IDcpKQpub3JtLnJlcy41IDwtIHRhYmxhLmZyZWMobm9ybS52YXIsIHZhci5jb2wgPSAidmFyIiwgaW50ZXIgPSA1LCBtaW4gPSBtaW4obm9ybS52YXIpLCBtYXggPSBtYXgobm9ybS52YXIpKQpmcmVjLmdyYWYobm9ybS5yZXMuNSkKYGBgCgpBaG9yYSB2ZcOhbW9zbGEgY29uIHVuYSBhbXBsaXR1ZCBkZSAxOgoKYGBge3J9Cm5vcm0ucmVzLjEgPC0gdGFibGEuZnJlYyhub3JtLnZhciwgdmFyLmNvbCA9ICJ2YXIiLCBpbnRlciA9IDEsIG1pbiA9IG1pbihub3JtLnZhciksIG1heCA9IG1heChub3JtLnZhcikpCmZyZWMuZ3JhZihub3JtLnJlcy4xKQpgYGAKCkVuIGVzdGUgcHVudG8sIGluY2x1c28gZGVzZGUgbGEgZ3LDoWZpY2EgYW50ZXJpb3IsIGVsIGdyw6FmaWNvIHNlIGNvbWVuesOzIGEgY2FyZ2FyIGRlIGRlbWFzaWFkYSBpbmZvcm1hY2nDs24uIEVzdG8gZXJhIGRlIGVzcGVyYXJzZSwgdG9tYW5kbyBlbiBjdWVudGEgcXVlIGVuIGNhZGEgb2Nhc2nDs24gYWNoaWNhbW9zIGxvcyBpbnRlcnZhbG9zLiBQYXJhIGhhY2VybG9zIGluZmluaXRlc2ltYWxtZW50ZSBwZXF1ZcOxb3MgcG9kZW1vcyB1dGlsaXphciB1biB0aXBvIGRlIGdyw6FmaWNvIHF1ZSBzZSBjb25vY2UgY29tbyBLREUsIGJhc2FkbyBlbiBsYSB0w6ljbmljYSAiS2VybmVsIERlbnNpdHkgRXN0aW1hdGlvbiIgcXVlLCBlbiBwb2NhcyBwYWxhYnJhcywgbm9zIHBlcm1pdGUgbW9zdHJhciBsYSBmdW5jacOzbiBkZSBkZW5zaWRhZCBkZSB1biBjb25qdW50byBkZSBkYXRvczoKCmBgYHtyfQpwcm9tLm5vcm0udmFyIDwtIG1lYW4obm9ybS52YXIkdmFyKQpkZS5wbG90IDwtIGdncGxvdChkYXRhID0gbm9ybS52YXIsIGFlcyh2YXIpKSArIAogICAgICAgICAgIGdlb21fZGVuc2l0eShrZXJuZWwgPSAiZ2F1c3NpYW4iLCBjb2xvdXIgPSAiZGVlcHNreWJsdWU0IiwgZmlsbCA9ICJkZWVwc2t5Ymx1ZTQiLCBhbHBoYSA9IDAuNSkgKwogICAgICAgICAgIGxhYnMoeCA9ICJBbHR1cmEiLAogICAgICAgICAgICAgICAgeSA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgIHRpdGxlID0gIkdyw6FmaWNvIGRlIGRlbnNpZGFkIGRlIGFsdHVyYXMgZW4gcHVsZ2FkYXMiLAogICAgICAgICAgICAgICAgc3VidGl0bGUgPSBwYXN0ZSgiRXhwZXJpbWVudG9zOiAiLGxlbmd0aChub3JtLnZhciR2YXIpLCAiOyBNZWRpYSByZWFsID0gNjciKSwKICAgICAgICAgICAgICAgIGNhcHRpb24gPSAiRGF0b3Mgc2ltdWxhZG9zIikgKwogICAgICAgICAgIHRoZW1lKHBhbmVsLmdyaWQubWlub3IgPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICAgICAgICAgICAgcGFuZWwuZ3JpZC5tYWpvciA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICBwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgICAgICAgICAgIGF4aXMubGluZSA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICBhc3BlY3QucmF0aW8gPSAxLzEuNjEsCiAgICAgICAgICAgICAgICAgYXhpcy50aWNrcyA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICB0ZXh0ID0gZWxlbWVudF90ZXh0KGNvbG91ciA9ICJncmF5NTAiKQogICAgICAgICAgICAgICAgICkgKwogICAgICAgICAgIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBOVUxMKSArCiAgICAgICAgICAgZ2VvbV92bGluZSh4aW50ZXJjZXB0ID0gcHJvbS5ub3JtLnZhciwgY29sb3VyID0gcmdiKDExOCw3OCwxNDQsIG1heENvbG9yVmFsdWUgPSAyNTUpKSArCiAgICAgICAgICAgYW5ub3RhdGUoInRleHQiLCB4ID0gcHJvbS5ub3JtLnZhciwgeSA9IDAuMDYsIGxhYmVsID0gcGFzdGUoIk1lZGlhID0gIiwgcm91bmQocHJvbS5ub3JtLnZhciwgMSkpKQpkZS5wbG90CmBgYAoKClBvZGVtb3MgdmVyIHRhbWJpw6luIGxhIGltcG9ydGFuY2lhIGRlIGxhIHJlcHJlc2VudGF0aXZpZGFkIGNvbiB1bmEgYW5pbWFjacOzbi4gUHJpbWVybyBnZW5lcmVtb3MgdW4gZGF0YS5mcmFtZSBxdWUgY29udGVuZ2EgdG9kb3MgbG9zIGVzdGFkb3MgcXVlIG5vcyBpbnRlcmVzYW4sIGVuIGVzdGUgY2FzbyBkZXNkZSAxMCBtdWVzdHJhcyBoYXN0YSAxMDEwLCBlbiBpbmNyZW1lbnRvcyBkZSAxMCBtdWVzdHJhczoKCmBgYHtyfQpmb3IgKGkgaW4gc2VxKDEwLDEwMTAsMTApKSB7CiAgaWZlbHNlKGkgPT0gMTAsCiAgICAgICAgIG5vcm0udmFyMiA8LSBkYXRhLmZyYW1lKHZhciA9IG5vcm0udmFyJHZhclsxOmldLCBpdGVyID0gaSwgcHJvbWVkaW8gPSBtZWFuKG5vcm0udmFyJHZhclsxOmldKSksCiAgICAgICAgIG5vcm0udmFyMiA8LSByYmluZChub3JtLnZhcjIsIGRhdGEuZnJhbWUodmFyID0gbm9ybS52YXIkdmFyWzE6aV0sIGl0ZXIgPSBpLCBwcm9tZWRpbyA9IG1lYW4obm9ybS52YXIkdmFyWzE6aV0pKSkKICAgICAgICAgKQp9CmBgYAoKQWhvcmEgdXRpbGljZW1vcyBsYSBsaWJyZXLDrWEgYGdnYW5pbWF0ZWAgcGFyYSBnZW5lcmFyIGxhIGFuaW1hY2nDs24gZGUgbnVlc3RybyBpbnRlcsOpcy4gCk9KTzogRXN0YSBhbmltYWNpw7NuIG5vIHNlIG1vc3RyYXLDoSBlbiBsYSBsaWJyZXRhLCBzaW5vIGVuIGVsIHZpc29yIGRlIFJTdHVkaW8KT0pPIDI6IERlcGVuZGllbmRvIGRlIGxhIGNvbXBsZWppZGFkIGRlIGxhIGFuaW1hY2nDs24sIGVsIHByb2Nlc28gZGUgcmVuZGVyaXphZG8gcHVlZGUgdG9tYXIgZGVzZGUgdW5vcyBjdWFudG9zIHNlZ3VuZG9zIGhhc3RhIHZhcmlvcyBtaW51dG9zIG8sIGluY2x1c28sIG3DoXMgZGUgdW5hIGhvcmEuIEVzdGUgZWplbXBsbyBlcyBlbCBzZWd1bmRvIGNhc28uIE5PIGNvcnJlciBhbCBtZW5vcyBkZSBxdWUgdGVuZ2FzIGJhc3RhbnRlIHRpZW1wbyBkaXNwb25pYmxlIG8gdW5hIGNvbXB1dGFkb3JhIGNvbiBiYXN0YW50ZSBmdWVyemEgYnJ1dGEuCgpgYGB7cn0KIyBsaWJyYXJ5KGdnYW5pbWF0ZSkKIyBkZS5wbG90IDwtIGdncGxvdChkYXRhID0gbm9ybS52YXIyLCBhZXModmFyKSkgKwojICAgICAgICAgICBnZW9tX2RlbnNpdHkoa2VybmVsID0gImdhdXNzaWFuIiwgY29sb3VyID0gImRlZXBza3libHVlNCIsIGZpbGwgPSAiZGVlcHNreWJsdWU0IiwgYWxwaGEgPSAwLjUpICsKIyAgICAgICAgICAgbGFicyh4ID0gIkFsdHVyYSIsCiMgICAgICAgICAgICAgICAgeSA9IGVsZW1lbnRfYmxhbmsoKSwKIyAgICAgICAgICAgICAgICB0aXRsZSA9ICJHcsOhZmljbyBkZSBkZW5zaWRhZCBkZSBhbHR1cmFzIChwdWxnYWRhcykiLAojICAgICAgICAgICAgICAgIHN1YnRpdGxlID0gcGFzdGUoIkV4cGVyaW1lbnRvczogIixsZW5ndGgobm9ybS52YXIkdmFyKSwgIjsgTWVkaWEgcmVhbCA9IDY3IiksCiMgICAgICAgICAgICAgICAgY2FwdGlvbiA9ICJEYXRvcyBzaW11bGFkb3MiKSArCiMgICAgICAgICAgIHRoZW1lKHBhbmVsLmdyaWQubWlub3IgPSBlbGVtZW50X2JsYW5rKCksCiMgICAgICAgICAgICAgICAgIHBhbmVsLmdyaWQubWFqb3IgPSBlbGVtZW50X2JsYW5rKCksCiMgICAgICAgICAgICAgICAgIHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X2JsYW5rKCksCiMgICAgICAgICAgICAgICAgIGF4aXMubGluZSA9IGVsZW1lbnRfYmxhbmsoKSwKIyAgICAgICAgICAgICAgICAgYXNwZWN0LnJhdGlvID0gMS8xLjYxLAojICAgICAgICAgICAgICAgICBheGlzLnRpY2tzID0gZWxlbWVudF9ibGFuaygpLAojICAgICAgICAgICAgICAgICB0ZXh0ID0gZWxlbWVudF90ZXh0KGNvbG91ciA9ICJncmF5NTAiKQojICAgICAgICAgICAgICAgICApICsKIyAgICAgICAgICAgc2NhbGVfeV9jb250aW51b3VzKGJyZWFrcyA9IE5VTEwpICsKIyAgICAgICAgICAgZ2VvbV92bGluZSh4aW50ZXJjZXB0ID0gbm9ybS52YXIyJHByb21lZGlvLCBjb2xvdXIgPSByZ2IoMTE4LDc4LDE0NCwgbWF4Q29sb3JWYWx1ZSA9IDI1NSkpICsKIyAgICAgICAgICAgYW5ub3RhdGUoInRleHQiLCB4ID0gbm9ybS52YXIyJHByb21lZGlvLCB5ID0gMC4wNiwgbGFiZWwgPSBwYXN0ZSgiTWVkaWEgPSAiLCByb3VuZChub3JtLnZhcjIkcHJvbWVkaW8sIDIpKSkgKwojICAgICAgICAgICB0cmFuc2l0aW9uX3N0YXRlcyhpdGVyKSArIGxhYnMoc3VidGl0bGUgPSBwYXN0ZSgiRXhwZXJpbWVudG9zOiB7Y2xvc2VzdF9zdGF0ZX07IE1lZGlhIHJlYWwgPSA2NyIpKQojIGRlLnBsb3QKYGBgCgojIyBJbnRlcnZhbG9zIGRlIGNvbmZpYW56YQpFeGlzdGVuIGRpc3RpbnRhcyBmb3JtYXMgZGUgY2FsY3VsYXIgbG9zIGludGVydmFsb3MgZGUgY29uZmlhbnphIHBhcmEgdW5hIG1lZGlhIGVuIFIuIFVubyBkZSBlbGxvcyBlcyB1dGlsaXphbmRvIGxhIGZ1bmNpw7NuIGB0LnRlc3RgLCBlbCBjdWFsIHV0aWxpemEgbGEgZGlzdHJpYnVjacOzbiBULVN0dWRlbnQgcGFyYSBlbCBjw6FsY3Vsby4gRGUgc3Ugc2FsaWRhIHZlbW9zIHF1ZSBub3MgZGEgZWwgdmFsb3IgZGVsIGVzdGFkw61zdGljbyBkZSBwcnVlYmEgKHZhbG9yIGNyw610aWNvKSwgbG9zIGdyYWRvcyBkZSBsaWJlcnRhZCB5IHVuIHZhbG9yIGRlIHAuIEVzdG9zIGVsZW1lbnRvcyBsb3MgaWdub3JhcmVtb3MgcG9yIGVsIG1vbWVudG8uIExvIHF1ZSBzw60gbm9zIGludGVyZXNhIGVzIGxhIGluZm9ybWFjacOzbiBxdWUgYXBhcmVjZSBwb3IgZGViYWpvOyBlcyBkZWNpciwgbG9zIGzDrW1pdGVzIGRlIGxvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSB5IGVsIHZhbG9yIGRlIGxhIG1lZGlhLgoKYGBge3J9CnQudGVzdChub3JtLnZhciR2YXIsIGNvbmYubGV2ZWwgPSAwLjk1KQpgYGAKCk90cmEgZm9ybWEgZGUgY2FsY3VsYXJsb3MgZXMgdXRpbGl6YW5kbyBsYSBsaWJyZXLDrWEgYFJtaXNjYDoKCmBgYHtyfQojaW5zdGFsbC5wYWNrYWdlcygiUm1pc2MiLCBkZXBlbmRlbmNpZXMgPSBUKQpsaWJyYXJ5KFJtaXNjKQpgYGAKClVuYSB2ZXogaW5zdGFsYWRhIHkgY2FyZ2FkYSwgcG9kZW1vcyB1dGlsaXphciBsYSBmdW5jacOzbiBgQ0koeCwgY2kgPSBhKWAsIGRvbmRlIGB4YCBlcyBlbCB2ZWN0b3IgcXVlIGNvbnRpZW5lIGxvcyBkYXRvcyB5IGBhYCByZXByZXNlbnRhIGVsIG5pdmVsIGRlICJjb25maWFuemEiIGRlIGxhIGVzdGltYWNpw7NuLiBVdGlsaWNlbW9zIGxvcyBtaXNtb3MgZGF0b3MgZGUgYWx0dXJhIHF1ZSBnZW5lcmFtb3MgaGFjZSB1bm9zIG1vbWVudG9zOgoKYGBge3J9CkNJKG5vcm0udmFyJHZhciwgY2kgPSAwLjk1KQpgYGAKCkNvbW8gdmVtb3MsIGxhIGZ1bmNpw7NuIGNhbGN1bGEgbG9zIGludGVydmFsb3MgZGUgY29uZmlhbnphIHV0aWxpemFuZG8gbGEgZGlzdHJpYnVjacOzbiBULiBFc3RvIHNlIGRlYmUgYSBxdWUgZXMgZWwgbW9kbyBtw6FzIGNvbcO6biBkZSByZWFsaXphciBsYSBlc3RpbWFjacOzbiBkZSBpbnRlcnZhbG9zIHBhcmEgdmFyaWFibGVzIGNvbnRpbnVhcy4gwr9MYSByYXrDs24/IEVzbyBlcyB0ZW1hIHBhcmEgdW5hIGNsYXNlIHBvc3RlcmlvciwgZW4gbGEgcXVlIGV4cGxpY2Fyw6kgbGFzIGNhcmFjdGVyw61zdGljYXMgcXVlIGhhY2VuIHF1ZSBsYSBkaXN0cmlidWNpw7NuIFQgc2VhIHVubyBkZSBsb3MgcHJpbmNpcGFsZXMgImNhYmFsbGl0b3MgZGUgYmF0YWxsYSIgZW4gbGEgZXN0YWTDrXN0aWNhLgoKVW5hIMO6bHRpbWEgb3BjacOzbiBlcyB1dGlsaXphciBsYSBsaWJyZXLDrWEgYFJjb21wYW5pb25gLCBsYSBjdWFsIHRpZW5lIHVuIG3DqXRvZG8gZGUgbGEgZXN0aW1hY2nDs24gZGUgaW50ZXJ2YWxvcyBiYXNhZG8gZW4gInJlbXVlc3RyZW9zIiBCb290c3RyYXAuIEFsIGlndWFsIHF1ZSBlbiBlbCByZXN0byBkZSBsaWJyZXLDrWFzLCBoYWJyw6EgcXVlIGluc3RhbGFybGE6CgpgYGB7cn0KI2luc3RhbGwucGFja2FnZXMoIlJjb21wYW5pb24iLCBkZXBlbmRlbmNpZXMgPSBUKQpsaWJyYXJ5KHJjb21wYW5pb24pCmBgYAoKVW5hIGRlIGxhcyBmdW5jaW9uZXMgcXVlIHBvZGVtb3MgdXRpbGl6YXIgZXMgYGdyb3Vwd2lzZU1lYW4oZm9ybXVsYSwgZGF0YSwgY29uZiwgUilgLCBkb25kZSBgZm9ybXVsYWAgaW5kaWNhIGFsIG1pc21vIHRpZW1wbyBsYXMgY29sdW1uYXMgZGUgbGEgdmFyaWFibGUgY29udGludWEgeSBsYSB2YXJpYWJsZSBkZSBhZ3J1cGFtaWVudG8sIHRhbCBxdWU6IGB2YXIgfiBncnVwb2A7IGBkYXRhYCBpbmRpY2EgZWwgYGRhdGEuZnJhbWVgIHF1ZSBjb250aWVuZSBsYSBpbmZvcm1hY2nDs24sIGBjb25mYCBxdWUgaW5kaWNhIGxhIGFtcGxpdHVkIGRlIGxvcyBpbnRlcnZhbG9zIHkgZmluYWxtZW50ZSBgUmAgcXVlIGluZGljYSBlbCBuw7ptZXJvIGRlIHJlcGxpY2FzIGJvb3RzdHJhcCBhIHJlYWxpemFyLiBQYXJ0aWVuZG8gZGUgbG8gYW50ZXJpb3I6CgpgYGB7cn0KZ3JvdXB3aXNlTWVhbih2YXJ+MSwgZGF0YSA9IG5vcm0udmFyLCBjb25mID0gMC45NSwgUiA9IDUwMCkKYGBgCgpWZW1vcyBxdWUgbGEgc2FsaWRhIGVzIHVuIHBvY28gbcOhcyBjb21wbGVqYTsgc2luIGVtYmFyZ28sIGxvIG3DoXMgcmVsZXZhbnRlIGVzIHF1ZSBsb3MgaW50ZXJ2YWxvcyBzb24gc3VtYW1lbnRlIGNlcmNhbm9zIGEgbG9zIHF1ZSBjYWxjdWxhbW9zIGFudGVyaW9ybWVudGUuIMK/RXN0byBxdWllcmUgZGVjaXIgcXVlIG5vIHRpZW5lIGNhc28gcmVhbGl6YXIgbGFzIHLDqXBsaWNhcyBib290c3RyYXA/IE5vLCBzaW1wbGVtZW50ZSBxdWUgc3VzIGJlbmVmaWNpb3MgbG9zIHZlcmVtb3MgYXBsaWPDoW5kb2xhcyBhIGxhIHNpdHVhY2nDs24gcGFyYSBsYSBxdWUgZnVlcm9uIHBlbnNhZGFzOyBlcyBkZWNpciwgZGlzdHJpYnVjaW9uZXMgc2VzZ2FkYXMgeSBubyBub3JtYWxlcyBhIGRpZmVyZW5jaWEgZGUgbGEgdmFyaWFibGUgcXVlIGFuYWxpemFtb3MgYXF1w60uIAoKUmVjdXJzb3MgcmVjb21lbmRhZG9zIHBhcmEgZXN0YSBzZWNjacOzbjogW1Jjb21wYW5pb25dKGh0dHBzOi8vcmNvbXBhbmlvbi5vcmcvaGFuZGJvb2svQ18wMy5odG1sKSB5IFtIYW5kYm9vayBvZiBCaW9sb2dpY2FsIFN0YXRpc3RpY3NdKGh0dHA6Ly93d3cuYmlvc3RhdGhhbmRib29rLmNvbS9jb25maWRlbmNlLmh0bWwpCgojIyBFamVyY2ljaW8KUGFyYSBsYSB0YXJlYSBkZSBlc3RhIHNlbWFuYSBjYXJnYXLDoXMgZWwgYXJjaGl2byBgRGF0b3MxLmNzdmAgY29uIGVsIGPDs2RpZ28gYXF1w60gaW5jbHXDrWRvIHksIGRlIG1hbmVyYSBzaW1pbGFyIGEgY29tbyBzZSB2aW8gZHVyYW50ZSBsYSBjbGFzZSwgcmVhbGl6YXLDoXMgbGEgZXN0aW1hY2nDs24gZGUgbGEgbWVkaWEsIGxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciB5IGxvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSAodXRpbGl6YW5kbyBjdWFscXVpZXJhIGRlIGxhcyBmb3JtYXMgYXF1w60gdmlzdGFzKSBwYXJhIGRpZmVyZW50ZXMgdGFtYcOxb3MgZGUgbXVlc3RyYSAob2pvIGEgbGEgZnVuY2nDs24gYHNhbXBsZSgpYCkuIEVsIG9iamV0aXZvIGVzIHZlciBjw7NtbyBjYW1iaWFuIHRhbnRvIGxhIGVzdGltYWNpw7NuIHB1bnR1YWwgY29tbyBsYSBhbXBsaXR1ZCBkZSBsb3MgaW50ZXJ2YWxvcyBhbCBpbmNyZW1lbnRhciBlbCB0YW1hw7FvIGRlIG11ZXN0cmEuCgpQYXJ0ZSAqKk9QQ0lPTkFMKio6U2kgcXVpZXJlcyBkZXNhZmlhcnRlIHVuIHBvY28gbcOhcywgY29uc2lkZXJhIGFsZ3VuYSBkZSBsYXMgdmFyaWFibGVzIERpZXRhIG8gUGVyaW9kbyBjb21vIHVuIGdydXBvcyBkZW50cm8gZGUgbGEgcG9ibGFjacOzbiB5IHJlYWxpemEgbGFzIGVzdGltYWNpb25lcyBjb24gZXNhIGNvbnNpZGVyYWNpw7NuLiBQdWVkZXMgdGFtYmnDqW4gaW50ZW50YXIgcHJlc2VudGFyIGxvcyByZXN1bHRhZG9zIGRlIG1hbmVyYSBncsOhZmljYSAoYWdydXBhZG9zIG8gbm8pLiBVbmEgYWx0ZXJuYXRpdmEgZXMgdXNhciB1biBncsOhZmljbyBLREUgeSBtb3N0cmFyIGxvcyBsw61taXRlcyBjb21vIGzDrW5lYXMgdmVydGljYWxlcywgb3RyYSBhbHRlcm5hdGl2YSBlcyB1biBncsOhZmljbyBzaW1pbGFyIGFsIHF1ZSBzZSBwcmVzZW50w7MgZW4gY2xhc2UsIGNvbiBlbCBuw7ptZXJvIGRlIG11ZXN0cmFzIGVuIGVsIGVqZSB4IHkgdW4gZ3LDoWZpY28gY29uIGzDrW5lYXMgZGUgZXJyb3IgcGFyYSBlbCBlamUgeS4gRXN0ZSBhcGFydGFkbyBPUENJT05BTCBubyB0aWVuZSB1bmEgInJlc3B1ZXN0YSBjb3JyZWN0YSIsIGFzw60gcXVlIHB1ZWRlcyBleHBlcmltZW50YXIgeSBwcmVzZW50YXIgKG8gbm8pIGxvcyByZXN1bHRhZG9zIGRlIGxhIG1hbmVyYSBlbiBxdWUgdMO6IGNvbnNpZGVyZXMgc2UgcmVzdWVsdmVuIGxvcyBvYmpldGl2b3MuCgpgYGB7ciwgZXZhbD1GQUxTRX0KZGYgPC0gcmVhZC50YWJsZShmaWxlLmNob29zZSgpLCBoZWFkZXIgPSBGLCBza2lwID0gMSwgc2VwID0gIiwiKQpjb2xuYW1lcyhkZikgPC0gYygiRGlldGEiLCAiUGVyaW9kbyIsICJSZXAiLCAiTFQiLCAiUFQiKQpoZWFkKGRmKQpgYGAKCgoKCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("c3_probabilidad.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
