<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="M. en C. Arturo Bell Enríquez García" />


<title>Correlación y Regresión Lineal Simple</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Bioestadística con R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Temas
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Biología como Ciencia de Datos</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c1_Intro_R.html">Introducción a R</a>
        </li>
        <li>
          <a href="c2_ggplot2.html">ggplot2</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Herramientas Básicas</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c3_probabilidad.html">Probabilidad</a>
        </li>
        <li>
          <a href="c4_muestreo.html">Teoría del Muestreo</a>
        </li>
        <li>
          <a href="c5_descriptiva.html">Estadística Descriptiva</a>
        </li>
        <li>
          <a href="c6_ph0.html">Pruebas de hipótesis</a>
        </li>
        <li>
          <a href="c7_param.html">Técnicas Paramétricas</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Relaciones Lineales</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c8_rls.html">Modelo Lineal Simple</a>
        </li>
        <li>
          <a href="c9_glm.html">Modelos Lineales Generalizados</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">No Paramétrico y No Lineal</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c10_no_par.html">Técnicas No Paramétricas</a>
        </li>
        <li>
          <a href="c11_no_lineal.html">Modelos No Lineales</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Técnicas Multivariadas</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="c11_intro_mv.html">Introducción</a>
        </li>
        <li>
          <a href="c12_no_sup.html">No supervisadas</a>
        </li>
        <li>
          <a href="c13_comps_mv.html">Comparaciones Multivariadas</a>
        </li>
        <li>
          <a href="c14_clasificacion.html">Clasificaciones</a>
        </li>
        <li>
          <a href="c15_regs_mv.html">Regresiones Múltiples</a>
        </li>
      </ul>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Correlación y Regresión Lineal Simple</h1>
<h4 class="author">M. en C. Arturo Bell Enríquez García</h4>

</div>


<p><strong><a href="https://youtu.be/Sh8oUfIpOnA">VIDEO</a></strong></p>
<div id="instalación-de-librerías" class="section level2">
<h2>Instalación de librerías</h2>
<pre class="r"><code>if(!require(gap)) install.packages(&quot;gap&quot;, dependencies = T)</code></pre>
<pre><code>## Loading required package: gap</code></pre>
<pre><code>## gap version 1.2.2</code></pre>
<pre><code>## 
## Attaching package: &#39;gap&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:car&#39;:
## 
##     logit</code></pre>
</div>
<div id="funciones-personalizadas" class="section level2">
<h2>Funciones personalizadas</h2>
<pre class="r"><code># Tema personalizado
blank_theme &lt;- function(){
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        panel.background = element_blank(),
        axis.line = element_blank(),
        aspect.ratio = 1/1.61,
        axis.ticks = element_blank(),
        text = element_text(colour = &quot;gray50&quot;),
        legend.position = &quot;none&quot;
        )
}

# Función para graficar la relación entre dos variables; i.e., 
# una forma elegante de llamarle a un gráfico de dispersión con valores por defecto...
rel.plot &lt;- function(data, aest, 
                     medidas = TRUE, 
                     corre = NA, covar = NA, 
                     eq = &quot;&quot;, ...){
  # Construcción del gráfico sin anotaciones
  plot &lt;- ggplot(data = data, aest) + 
          labs(title = &quot;Relación entre dos variables&quot;,
               caption = paste(&quot;Datos simulados: &quot;, eq)) +
          geom_point(color = &quot;deepskyblue4&quot;, alpha = 0.5, size = 2) +
          expand_limits(y = c(5, -3)) +
          blank_theme()
  # Si medidas es TRUE, agregar las medidas al gráfico
  if(isTRUE(medidas)){plot &lt;- plot + annotate(&quot;text&quot;, x = 15, y = -2,
                                 label = paste(&quot;Cor. = &quot;, round(corre, 2), 
                                 &quot;\n Cov. = &quot;, round(covar,2)),
                                 color = &quot;gray50&quot;)}
  return(plot)
}</code></pre>
</div>
<div id="covarianza-vs.-correlación" class="section level2">
<h2>Covarianza vs. Correlación</h2>
<p>Generemos un par de variables donde la segunda sea una función lineal de la primera:</p>
<pre class="r"><code>df1 &lt;- data.frame(v1 = -20:20)
df1[&quot;v2&quot;] &lt;- (10+2*df1$v1)
df1</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["v1"],"name":[1],"type":["int"],"align":["right"]},{"label":["v2"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"-20","2":"-30"},{"1":"-19","2":"-28"},{"1":"-18","2":"-26"},{"1":"-17","2":"-24"},{"1":"-16","2":"-22"},{"1":"-15","2":"-20"},{"1":"-14","2":"-18"},{"1":"-13","2":"-16"},{"1":"-12","2":"-14"},{"1":"-11","2":"-12"},{"1":"-10","2":"-10"},{"1":"-9","2":"-8"},{"1":"-8","2":"-6"},{"1":"-7","2":"-4"},{"1":"-6","2":"-2"},{"1":"-5","2":"0"},{"1":"-4","2":"2"},{"1":"-3","2":"4"},{"1":"-2","2":"6"},{"1":"-1","2":"8"},{"1":"0","2":"10"},{"1":"1","2":"12"},{"1":"2","2":"14"},{"1":"3","2":"16"},{"1":"4","2":"18"},{"1":"5","2":"20"},{"1":"6","2":"22"},{"1":"7","2":"24"},{"1":"8","2":"26"},{"1":"9","2":"28"},{"1":"10","2":"30"},{"1":"11","2":"32"},{"1":"12","2":"34"},{"1":"13","2":"36"},{"1":"14","2":"38"},{"1":"15","2":"40"},{"1":"16","2":"42"},{"1":"17","2":"44"},{"1":"18","2":"46"},{"1":"19","2":"48"},{"1":"20","2":"50"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Obtengamos la covarianza:</p>
<pre class="r"><code>covar &lt;- cov(df1$v1, df1$v2)
covar</code></pre>
<pre><code>## [1] 287</code></pre>
<p>Ahora calculemos el índice de correlación</p>
<pre class="r"><code>corre &lt;- cor(df1$v1, df1$v2)
corre</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Por último, grafiquemos los resultados e incluyamos el valor de ambas medidas:</p>
<pre class="r"><code>library(ggplot2)
lin.plot1 &lt;- rel.plot(data = df1, aest = aes(v1, v2),
                      eq = &quot;v2 = 10 + 2*v1&quot;,
                      covar = covar, corre = corre)

lin.plot1</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>Ambos resultados nos dicen que existe una relación directamente proporcional entre ambas variables (conforme incrementa una incrementa la otra); sin embargo, debido a que la correlación se encuentra contenida entre [-1,1] podemos comprobar que es una relación LINEAL perfecta. Debido a esta diferencia en interpretabilidad normalmente trabajaremos con el índice de correlación, pero es importante recordar que estamos trabajando con un análisis paramétrico que supone una relación del tipo <span class="math inline">\(Y = \beta_0 + \beta_1\cdot X + \epsilon\)</span> y que por tanto puede NO ser una forma adecuada para describir los datos, veamos un ejemplo:</p>
<pre class="r"><code>df1[&quot;v3&quot;] &lt;- (-df1$v1^2)

pot.plot &lt;- rel.plot(data = df1, aest = aes(v1, v3),
                     eq = &quot;v3 = -v1^2&quot;,
                     covar = cov(df1$v2, df1$v3),
                     corre = cor(df1$v2, df1$v3)
                     )
pot.plot</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>Otro ejemplo:</p>
<pre class="r"><code>df1[&quot;v4&quot;] &lt;- sin(df1$v1)

sin.plot &lt;- rel.plot(data = df1, aest = aes(v1, v4),
                     eq = &quot;v4 = sin(v1)&quot;,
                     covar = cov(df1$v1, df1$v4),
                     corre = cor(df1$v1, df1$v4))
sin.plot</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<div id="correlación-de-pearson-vs.-correlación-de-spearman" class="section level3">
<h3>Correlación de Pearson vs. Correlación de Spearman</h3>
<p>A diferencia de la correlación de Pearson la correlación de Spearman nos permite calcular la correlación entre variables ordinales o continuas, siempre y cuando la relación sea monótona:</p>
<pre class="r"><code>df2 &lt;- data.frame(v1 = df1$v1[df1$v1 &gt; 0], 
                  v2 = df1$v1[df1$v1 &gt; 0]^2,
                  mono = &quot;monótona&quot;)

df2 &lt;- rbind(df2, data.frame(v1= df1$v1, 
                             v2 = df1$v3, 
                             mono = &quot;no monótona&quot;))

mono.plot &lt;- rel.plot(data = df2, aest = aes(v1, v2),
                      eq = &quot;v2 = 10 + 2*v1 | v2 = -v1^2&quot;,
                      medidas = FALSE) + 
             facet_wrap(~mono, nrow = 2, scales = &quot;free_y&quot;) +
             theme(aspect.ratio = 1/1.61)

mono.plot</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>Utilicemos el primer caso para calcular las correlaciones de Pearson y Spearman y ver las diferencias</p>
<pre class="r"><code>paste(&quot;Pearson = &quot;,
      round((cor(df2$v1[df2$mono == &quot;monótona&quot;],
                 df2$v2[df2$mono == &quot;monótona&quot;], 
                 method = &quot;pearson&quot;)), 2)
      )</code></pre>
<pre><code>## [1] &quot;Pearson =  0.97&quot;</code></pre>
<pre class="r"><code>paste(&quot;Spearman = &quot;,
      round((cor(df2$v1[df2$mono == &quot;monótona&quot;],
                 df2$v2[df2$mono == &quot;monótona&quot;], 
                 method = &quot;spearman&quot;)), 2)
      )</code></pre>
<pre><code>## [1] &quot;Spearman =  1&quot;</code></pre>
</div>
</div>
<div id="regresión-lineal-simple" class="section level2">
<h2>Regresión Lineal Simple</h2>
<p>Un modelo de regresión es un modelo predictivo de <strong>aprendizaje automatizado</strong> en el cual, a partir de los datos disponibles al momento, podemos intentar predecir resultados futuros (extrapolación) o resultados con los que no contamos (interpolación); es decir, resultados que el modelo no haya visto. Si las predicciones son adecuadas, el modelo nos puede servir para describir la naturaleza de la relación de ambas variables, al menos en términos matemáticos/numéricos. En esta sesión revisaremos algunos criterios para evaluar la bondad de ajuste de nuestro modelo (lit. qué tan bueno es), aunque nos limitaremos, por el momento, a hablar únicamente en términos de nuestros datos. Cuando lleguemos a la sección de multivariado hablaremos sobre el problema de la memorización/sobre-ajuste y una forma más objetiva de evaluar nuestros modelos.</p>
<p>El modelo de Regresión más sencillo es la regresión lineal simple, en la cual describimos la relación entre dos variables continuas utilizando la ecuación de la recta. Es decir, asumimos una relación del tipo <span class="math inline">\(y = \beta_0 \pm \beta_1*x + \epsilon\)</span>, en el cual <span class="math inline">\(\beta_0\)</span> representa la ordenada al origen (x = 0) y <span class="math inline">\(\beta_1\)</span> la pendiente de la recta o, en otras palabras, cuántas unidades nos movemos en el eje y por cada unidad en el eje x. Recordemos que la <strong>función de pérdida</strong> para este análisis es la distancia cuadrática entre valores observados y predichos; es decir, el método de <strong>mínimos cuadrados</strong>.</p>
<p>Para ejemplificarlo, carguemos los datos contenidos en <code>example_data.csv</code>:</p>
<pre class="r"><code>df.reg1 &lt;- read.csv(&quot;data/example_data.csv&quot;)
data.reg1 &lt;- rel.plot(data = df.reg1, aest = aes(v1, v2), 
                      medidas = T,
                      corre = cor(df.reg1$v1, df.reg1$v2),
                      covar = cov(df.reg1$v1, df.reg1$v2))
data.reg1</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<div id="ajuste-y-bondad-de-ajuste" class="section level3">
<h3>Ajuste y Bondad de ajuste</h3>
<p>Ajustemos el modelo de mínimos cuadrados a los datos y veamos los resultados de la regresión. Observemos que en los resultados se incluyen 3 pruebas de hipótesis: una prueba de t para cada parámetro y una prueba de ANOVA (que ignoraremos por el momento). De estas priebas es posible concluir que los parámetros son diferentes de un modelo nulo; es decir, de un modelo en el que <span class="math inline">\(\beta_0 = 0; \beta_1 = 0\)</span>. El valor de <span class="math inline">\(R^2\)</span> sugiere que el modelo únicamente explica alrededor del 70% de la varianza de los datos, lo cual sugiere que el modelo no está capturando aproximadamente una tercera parte de la información contenida en ellos. Finalmente, el valor de RSE dividido entre el valor promedio de la variable predicha nos da la tasa de error del modelo. El RSE también nos indica en cuántas unidades se desvía la predicción de los datos observados, que en este caso son 3.095.</p>
<pre class="r"><code>reg1 &lt;- lm(v2~v1, data = df.reg1)
summary(reg1)</code></pre>
<pre><code>## 
## Call:
## lm(formula = v2 ~ v1, data = df.reg1)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -5.8956 -1.9924 -0.5525  1.5351 15.3006 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -3.72654    0.73213   -5.09 1.81e-06 ***
## v1           1.17765    0.08141   14.47  &lt; 2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 3.095 on 95 degrees of freedom
## Multiple R-squared:  0.6878, Adjusted R-squared:  0.6845 
## F-statistic: 209.3 on 1 and 95 DF,  p-value: &lt; 2.2e-16</code></pre>
<pre class="r"><code>sum_res &lt;- summary(reg1)
paste(&quot;Tasa de error = &quot;, as.character(round(sum_res$sigma/mean(df.reg1$v2), 2)*100), &quot;%&quot;)</code></pre>
<pre><code>## [1] &quot;Tasa de error =  53 %&quot;</code></pre>
<p>Ahora grafiquemos la recta ajustada. Para ello primero extraeremos los valores ajustados y después los utilizaremos para construir la linea recta</p>
<pre class="r"><code>df.reg1[&quot;ajustados&quot;] &lt;-reg1$fitted.values

lin.plot2 &lt;- data.reg1 + 
             geom_line(data = df.reg1, 
                       aes(x = v1, y = ajustados),
                       colour = rgb(118,78,144, maxColorValue = 255),
                       size = 1) +
             labs(subtitle = paste(&quot;Modelo ajustado: v2 = &quot;, 
                                   round(reg1$coefficients[1],2), 
                                   &quot; + &quot;,
                                   round(reg1$coefficients[2],2),
                                   &quot;*v1 + e&quot;))
             
lin.plot2</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
</div>
<div id="intervalos-de-confianza-para-los-parámetros-y-la-regresión" class="section level3">
<h3>Intervalos de confianza para los parámetros y la regresión</h3>
<p>Ahora podemos calcular y graficar los intervalos de confianza para la predicción de la regresión:</p>
<pre class="r"><code>confint.reg1 &lt;- confint(reg1)
confint.reg1</code></pre>
<pre><code>##                 2.5 %    97.5 %
## (Intercept) -5.179989 -2.273085
## v1           1.016035  1.339263</code></pre>
<pre class="r"><code>df.reg1[&quot;inf.int&quot;] &lt;- confint.reg1[1,1] + confint.reg1[2,1]*df.reg1$v1 
df.reg1[&quot;sup.int&quot;] &lt;- confint.reg1[1,2] + confint.reg1[2,2]*df.reg1$v1

lin.plot3 &lt;- lin.plot2 + 
             geom_ribbon(data = df.reg1, aes(ymin = inf.int, ymax = sup.int), 
                         fill = &quot;gray70&quot;,
                         alpha = 0.3) +
             labs(caption = &quot;Datos simulados. El área gris representa los intervalos de confianza al 95% \n
                             de la estimación de ambos parámetros&quot;)
lin.plot3</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<pre class="r"><code>conf.plot.reg1 &lt;- data.reg1 + geom_smooth(method = lm, 
                                          colour = rgb(118,78,144, maxColorValue = 255)) +
                  labs(caption = &quot;Datos simulados. El área gris representa el intervalo de confianza de la regresión al 95%&quot;,
                       subtitle = paste(&quot;Modelo ajustado: v2 = &quot;, 
                                   round(reg1$coefficients[1],2), 
                                   &quot; + &quot;,
                                   round(reg1$coefficients[2],2),
                                   &quot;*v1 + e&quot;))
conf.plot.reg1</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
</div>
<div id="gráficos-diagnósticos-de-la-regresión" class="section level3">
<h3>Gráficos diagnósticos de la regresión</h3>
<p>Ahora evaluemos gráficamente la calidad del modelo ajustado.</p>
<p>####Gráfico cuantil-cuantil Es posible observar que los datos presentan una gran cantidad de desviaciones con respecto a una distribución normal:</p>
<pre class="r"><code>w &lt;- shapiro.test(df.reg1$v2)

qqplot1 &lt;- ggplot(data = df.reg1, aes(sample = v2)) + 
           geom_qq(colour = &quot;deepskyblue4&quot;, size = 3, alpha = 0.5) + 
           geom_qq_line(colour = rgb(118,78,144, maxColorValue = 255), size = 1) + 
           annotate(&quot;text&quot;, x = 1, y = 0, 
                    label = paste(&quot;W = &quot;, round(w[[&quot;statistic&quot;]],2), &quot;; p &quot;, 
                                  ifelse(w[[&quot;p.value&quot;]] &lt; 0.001,
                                         &quot;&lt; 0.001&quot;,
                                         round(w[[&quot;p.value&quot;]],2))),
                    colour = &quot;gray 50&quot;
                    ) +
           blank_theme() +
           labs(title = &quot;Gráfico QQ&quot;,
                x = &quot;Cuantiles teóricos para la muestra&quot;,
                y = &quot;Datos observados&quot;)
qqplot1</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<pre class="r"><code>w1 &lt;- shapiro.test(rstandard(reg1))
qqplot2 &lt;- ggplot(reg1) + stat_qq(aes(sample = .stdresid), colour = &quot;deepskyblue4&quot;, size = 3, alpha = 0.5) + 
           geom_abline(colour =  rgb(118,78,144, maxColorValue = 255), size = 1) + 
           labs(x = &quot;Cuantiles teóricos&quot;,
                y = &quot;Residuales estandarizados&quot;,
                title = &quot;Gráfico QQ&quot;,
                subtitle = paste(&quot;W = &quot;, round(w1[[&quot;statistic&quot;]],2), &quot;; p &quot;, 
                                  ifelse(w1[[&quot;p.value&quot;]] &lt; 0.001,
                                         &quot;&lt; 0.001&quot;,
                                         round(w[[&quot;p.value&quot;]],2)))) +
           blank_theme()
qqplot2</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<div id="gráfico-de-escala-locación" class="section level4">
<h4>Gráfico de Escala-Locación</h4>
<p>En este gráfico es posible observar que los datos no están distribuídos de manera homogénea; es decir, no son datos heterocedásticos</p>
<pre class="r"><code>scale.loc.plot &lt;- ggplot(reg1, aes(.fitted, sqrt(abs(.stdresid)))) + 
                  geom_point(na.rm=TRUE, colour = &quot;deepskyblue4&quot;, size = 3, alpha = 0.5) + 
                  stat_smooth(method=&quot;loess&quot;, na.rm = TRUE, colour = rgb(118,78,144, maxColorValue = 255)) +
                  labs(x = &quot;Valores ajustados&quot;,
                       y = expression(sqrt(&quot;|Residuales estandarizados|&quot;)),
                       title = &quot;Escala-Locación&quot;
                       ) +
                  blank_theme()
                  
scale.loc.plot</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
</div>
<div id="gráfico-de-residuales" class="section level4">
<h4>Gráfico de Residuales</h4>
<p>Es posible observar que existe una cantidad importande de datos extremos (fuera de <span class="math inline">\(\pm\)</span> 2 desviaciones estándar)</p>
<pre class="r"><code>df.reg1[&quot;std.resids&quot;] &lt;- rstandard(reg1)
resid.plot &lt;- ggplot(data = df.reg1, aes(x = ajustados, y = std.resids, colour = std.resids)) + 
              geom_point(size = 3, alpha = 0.5) +
              stat_smooth(method = &quot;loess&quot;, colour = rgb(118,78,144, maxColorValue = 255)) + 
              geom_hline(yintercept = 0, col = &quot;red&quot;, linetype = &quot;dashed&quot;) +
              labs(title = &quot;Gráfico de Residuales&quot;,
                   x = &quot;Valores ajustados&quot;,
                   y = &quot;Residuales estandarizados&quot;) +
              blank_theme() +
              scale_color_gradient2(low = &quot;firebrick&quot;, 
                                    midpoint = 0, 
                                    mid = &quot;deepskyblue4&quot;, 
                                    high = &quot;firebrick&quot;,
                                    breaks = c(-2, 0, 2),
                                    limits = c(-2, 2),
                                    oob = scales::squish)
resid.plot</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<pre class="r"><code>resid.plot2 &lt;- ggplot(reg1, aes(x = .fitted, y = .stdresid, colour = .stdresid)) + 
               geom_point(size = 3, alpha = 0.5) +
               geom_hline(yintercept = 0, col = &quot;red&quot;, linetype = &quot;dashed&quot;) +
               geom_smooth(method = &quot;loess&quot;, colour = rgb(118,78,144, maxColorValue = 255)) +
               labs(title = &quot;Gráfico de Residuales&quot;,
                   x = &quot;Valores ajustados&quot;,
                   y = &quot;Residuales estandarizados&quot;) +
               blank_theme() +
               scale_color_gradient2(low = &quot;firebrick&quot;, 
                                     midpoint = 0, 
                                     mid = &quot;deepskyblue4&quot;, 
                                     high = &quot;firebrick&quot;,
                                     breaks = c(-2, 0, 2),
                                     limits = c(-2, 2),
                                     oob = scales::squish)
resid.plot2</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<pre class="r"><code>shapiro.test(df.reg1$std.resids)</code></pre>
<pre><code>## 
##  Shapiro-Wilk normality test
## 
## data:  df.reg1$std.resids
## W = 0.89933, p-value = 1.797e-06</code></pre>
</div>
</div>
</div>
<div id="ajuste-por-máxima-verosimilitud" class="section level2">
<h2>Ajuste por máxima verosimilitud</h2>
<p>Recordemos que al realizar el ajuste por máxima verosimilitud estamos encontrando los valores de los parámetros que MAXIMICEN la probabilidad de haber encontrado los datos (verosimilitud); es decir, es método probabilístico. En el caso de la RLS, nuestro modelo encuentra la máxima expectativa de y (forma elegante de llamarle a la media), siguiendo una distribución normal. En la clase de GLM Roberto explicará cómo ajustar modelos lineales en los que el error NO se modela bajo una distribución normal y los criterios para su formación.</p>
<p>A diferencia de la implementación de una regresión por mínimos cuadrados, ajustar el modelo mediante máxima verosimilitud no es tan intuitivo. El primer paso es establecer manualmente nuestra función de verosimilitud, ajustando una distribución normal a los residuales:</p>
<pre class="r"><code>data &lt;- df.reg1[c(&quot;v1&quot;, &quot;v2&quot;)]
LL &lt;- function(b0, b1, mu, sigma){
  # Encontrar los residuales. Modelo a ajustar
  R = data$v2 - data$v1 * b1 - b0
  
  # Calcular la verosimilitud. Residuales con distribución normal.
  
  R = suppressWarnings(dnorm(R, mu, sigma))
  
  # Sumar el logaritmo de las verosimilitudes para todos los puntos de datos.
  -sum(log(R))
}</code></pre>
<p>Ahora ajustamos el modelo que acabamos de crear, utilizando la función <code>mle(fun, start = list())</code> (maximum likelihood estimation), donde <code>fun</code> es la función a ajustar y <code>start</code> son los valores iniciales de los parámetros. En este paso lo que estamos haciendo es estimar los dos parámetros (media y desviación estándar) que mejor describen los datos:</p>
<pre class="r"><code>library(stats4)
mle.fit &lt;- mle(LL, start = list(b0 = 1, b1 = 1, sigma = 1), 
               fixed = list(mu = 0), 
               nobs = length(data$v2))

summary(mle.fit)</code></pre>
<pre><code>## Maximum likelihood estimation
## 
## Call:
## mle(minuslogl = LL, start = list(b0 = 1, b1 = 1, sigma = 1), 
##     fixed = list(mu = 0), nobs = length(data$v2))
## 
## Coefficients:
##        Estimate Std. Error
## b0    -3.726537 0.72453828
## b1     1.177649 0.08056368
## sigma  3.063056 0.21991454
## 
## -2 log L: 492.4402</code></pre>
<p>Si nos interesa comparar el ajuste entre modelos podemos utilizar el RMSE. Para ello primero generaremos los valores predichos (ajustados) por el modelo y después los contrastaremos contra los datos originales</p>
<pre class="r"><code>library(Metrics)</code></pre>
<pre><code>## 
## Attaching package: &#39;Metrics&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:pROC&#39;:
## 
##     auc</code></pre>
<pre><code>## The following objects are masked from &#39;package:caret&#39;:
## 
##     precision, recall</code></pre>
<pre><code>## The following object is masked from &#39;package:FSA&#39;:
## 
##     se</code></pre>
<pre><code>## The following object is masked from &#39;package:rcompanion&#39;:
## 
##     accuracy</code></pre>
<pre class="r"><code>data[&quot;v2adj&quot;] &lt;- coef(mle.fit)[&quot;b0&quot;] + coef(mle.fit)[&quot;b1&quot;]*data$v1
rmse(data$v2adj, data$v2)</code></pre>
<pre><code>## [1] 3.063056</code></pre>
<p>Veamos ahora los resultados de la RLS por mínimos cuadrados:</p>
<pre class="r"><code>data[&quot;v2adjols&quot;] &lt;- coef(reg1)[&quot;(Intercept)&quot;] + coef(reg1)[&quot;v1&quot;]*data$v1
coef(reg1)</code></pre>
<pre><code>## (Intercept)          v1 
##   -3.726537    1.177649</code></pre>
<pre class="r"><code>rmse(data$v2adjols, data$v2)</code></pre>
<pre><code>## [1] 3.063056</code></pre>
<p>Tanto los coeficientes como los valores de RMSE ¡son iguales! ¿Razón? Un modelo lineal ajustado por máxima verosimilitud utilizando un término de residuales con un error normalmente distribuido es equivalente a un modelo ajustado por mínimos cuadrados. Veamos qué pasa si ajustamos los residuales utilizando otra distribución, seleccionada “a ojo” (solo para fines del ejemplo) por la “forma” de la distribución de los datos:</p>
<pre class="r"><code>density &lt;- ggplot(data = data, aes(x = v2)) + 
           geom_density(colour = &quot;deepskyblue4&quot;, fill = &quot;deepskyblue4&quot;, alpha = 0.5) + 
           blank_theme() +
           labs(y = element_blank(),
                title = &quot;Gráfico de densidad de la variable a predecir&quot;) +
           scale_y_continuous(breaks = NULL)
density</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-27-1.png" width="672" /> Esta distribución “se parece” a una distribución gamma.</p>
<pre class="r"><code>LLg &lt;- function(b0, b1, shape, rate){
  # Encontrar los residuales. Modelo a ajustar (lineal)
  R = data$v2 - data$v1 * b1 - b0
  
  # Calcular la verosimilitud. Residuales con distribución gamma
  
  R = suppressWarnings(dgamma(R, shape = shape, rate = rate))
  
  # Sumar el logaritmo de las verosimilitudes para todos los puntos de datos.
  -sum(R, log = TRUE)
}

mleg.fit &lt;- mle(LLg, 
                start = list(b0 = 1, b1 = 1,
                             shape = 1, rate = 1),
                nobs = length(data$v2))
summary(mleg.fit)</code></pre>
<pre><code>## Warning in sqrt(diag(object@vcov)): NaNs produced</code></pre>
<pre><code>## Maximum likelihood estimation
## 
## Call:
## mle(minuslogl = LLg, start = list(b0 = 1, b1 = 1, shape = 1, 
##     rate = 1), nobs = length(data$v2))
## 
## Coefficients:
##         Estimate  Std. Error
## b0    3.02693623 0.001123079
## b1    0.03918585 0.001123853
## shape 0.86971294         NaN
## rate  1.08598904 0.577224471
## 
## -2 log L: -28.91377</code></pre>
<p>Para comparar el ajuste con respecto al caso anterior podemos utilizar el Criterio de Información de Akaike. Vemos que, tomando en cuenta este criterio, el segundo modelo se encuentra mucho mejor ajustado que el primero (valor mínimo de AIC):</p>
<pre class="r"><code>aics &lt;- AIC(mle.fit, mleg.fit)
aics[&quot;Delta&quot;] &lt;- abs(abs(aics$AIC) - abs(min(aics$AIC)))
aics</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["df"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["AIC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Delta"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"3","2":"498.44022","3":"477.5265","_rn_":"mle.fit"},{"1":"4","2":"-20.91377","3":"0.0000","_rn_":"mleg.fit"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Tarea opcional: Generar un gráfico con ambas líneas de ajuste y los intervalos de confianza para la recta.</p>
</div>
<div id="datos-biológicos-morfometrías" class="section level2">
<h2>Datos biológicos: Morfometrías</h2>
<p>En este ejemplo analizaremos datos de morfometerías</p>
<pre class="r"><code>df_haem &lt;- read.csv(&quot;data/Haem.csv&quot;)
ggplot(data = df_haem, aes(x = LT, y = AM)) + 
  geom_point(color = &quot;dodgerblue4&quot;) + 
  blank_theme() +
  geom_smooth(method = &quot;lm&quot;, colour = rgb(118,78,144, maxColorValue = 255)) +
  labs(title = &quot;Relación Altura Máxima ~ Longitud Total&quot;,
       x = element_blank(),
       y = element_blank(),
       caption = &quot;datos: Haem.csv&quot;)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<pre class="r"><code>reg_haem &lt;- lm(AM~LT, data = df_haem)
summary(reg_haem)</code></pre>
<pre><code>## 
## Call:
## lm(formula = AM ~ LT, data = df_haem)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -1.8016 -0.2692 -0.0249  0.2655  2.7445 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) 0.379258   0.160430   2.364   0.0188 *  
## LT          0.273059   0.006202  44.027   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.4422 on 281 degrees of freedom
## Multiple R-squared:  0.8734, Adjusted R-squared:  0.8729 
## F-statistic:  1938 on 1 and 281 DF,  p-value: &lt; 2.2e-16</code></pre>
<pre class="r"><code>qqplot2 &lt;- ggplot(reg_haem) + stat_qq(aes(sample = .stdresid), colour = &quot;deepskyblue4&quot;, size = 3, alpha = 0.5) + 
           geom_abline(colour =  rgb(118,78,144, maxColorValue = 255), size = 1) + 
           labs(x = &quot;Cuantiles teóricos&quot;,
                y = &quot;Residuales estandarizados&quot;,
                title = &quot;Gráfico QQ&quot;) +
           blank_theme()
qqplot2</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
<pre class="r"><code>scale.loc.plot &lt;- ggplot(reg_haem, aes(.fitted, sqrt(abs(.stdresid)))) + 
                  geom_point(na.rm = TRUE, colour = &quot;deepskyblue4&quot;, size = 3, alpha = 0.5) + 
                  stat_smooth(method=&quot;loess&quot;, na.rm = TRUE, colour = rgb(118,78,144, maxColorValue = 255)) +
                  labs(x = &quot;Valores ajustados&quot;,
                       y = expression(sqrt(&quot;|Residuales estandarizados|&quot;)),
                       title = &quot;Escala-Locación&quot;
                       ) +
                  blank_theme()
                  
scale.loc.plot</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<pre class="r"><code>resid.plot2 &lt;- ggplot(reg_haem, aes(x = .fitted, y = .stdresid, colour = .stdresid)) + 
               geom_point(size = 3, alpha = 0.5) +
               geom_hline(yintercept = 0, col = &quot;red&quot;, linetype = &quot;dashed&quot;) +
               geom_smooth(method = &quot;loess&quot;, colour = rgb(118,78,144, maxColorValue = 255)) +
               labs(title = &quot;Gráfico de Residuales&quot;,
                   x = &quot;Valores ajustados&quot;,
                   y = &quot;Residuales estandarizados&quot;) +
               blank_theme() +
               scale_color_gradient2(low = &quot;firebrick&quot;, 
                                     midpoint = 0, 
                                     mid = &quot;deepskyblue4&quot;, 
                                     high = &quot;firebrick&quot;,
                                     breaks = c(-2, 0, 2),
                                     limits = c(-2, 2),
                                     oob = scales::squish)
resid.plot2</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
<pre class="r"><code>library(brms)</code></pre>
<pre><code>## Loading required package: Rcpp</code></pre>
<pre><code>## Registered S3 methods overwritten by &#39;lme4&#39;:
##   method                          from
##   cooks.distance.influence.merMod car 
##   influence.merMod                car 
##   dfbeta.influence.merMod         car 
##   dfbetas.influence.merMod        car</code></pre>
<pre><code>## Loading &#39;brms&#39; package (version 2.14.4). Useful instructions
## can be found by typing help(&#39;brms&#39;). A more detailed introduction
## to the package is available through vignette(&#39;brms_overview&#39;).</code></pre>
<pre><code>## 
## Attaching package: &#39;brms&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:gap&#39;:
## 
##     cs</code></pre>
<pre><code>## The following object is masked from &#39;package:stats&#39;:
## 
##     ar</code></pre>
<pre class="r"><code>LLt &lt;- function(b0, b1, df, sigma){
  # Encontrar los residuales. Modelo a ajustar (lineal)
  R = df_haem$AM - df_haem$LT * b1 - b0
  
  # Calcular la verosimilitud. Residuales con distribución t de student
  
  R = suppressWarnings(brms::dstudent_t(R, df = df, mu = 0, sigma = sigma))
  
  # Sumar el logaritmo de las verosimilitudes para todos los puntos de datos.
  -sum(R, log = TRUE)
}

mlet_fit &lt;- mle(LLt, 
                start = list(b0 = 0, b1 = 0, df = 2, sigma = 10),
                nobs = length(df_haem$AM),
                lower = c(b0 = -20, b1 = -12, df = 1, sigma = 0.01),
                upper = c(b0 = 20, b1 = 12, df = 30, sigma = 10))

summary(mlet_fit)</code></pre>
<pre><code>## Warning in sqrt(diag(object@vcov)): NaNs produced</code></pre>
<pre><code>## Maximum likelihood estimation
## 
## Call:
## mle(minuslogl = LLt, start = list(b0 = 0, b1 = 0, df = 2, sigma = 10), 
##     nobs = length(df_haem$AM), lower = c(b0 = -20, b1 = -12, 
##         df = 1, sigma = 0.01), upper = c(b0 = 20, b1 = 12, df = 30, 
##         sigma = 10))
## 
## Coefficients:
##         Estimate   Std. Error
## b0    0.03138976 0.0007736521
## b1    0.28139558 0.0000956608
## df    7.54037566 1.9191746025
## sigma 0.01000000          NaN
## 
## -2 log L: -768.4337</code></pre>
<pre class="r"><code>coef(reg_haem)</code></pre>
<pre><code>## (Intercept)          LT 
##   0.3792585   0.2730588</code></pre>
<pre class="r"><code>aics &lt;- AIC(mlet_fit, reg_haem)
aics[&quot;Delta&quot;] &lt;- abs(abs(aics$AIC) - abs(min(aics$AIC)))
aics</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["df"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["AIC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Delta"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"4","2":"-760.4337","3":"0.0000","_rn_":"mlet_fit"},{"1":"3","2":"345.2813","3":"415.1524","_rn_":"reg_haem"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="bonus-librería-performance" class="section level2">
<h2>Bonus: Librería <code>performance</code></h2>
<p>Podemos generar los gráficos diagnósticos de distintos modelos utilizando una sola línea de código. Veamos el caso del primer modelo lineal que elaboramos:</p>
<pre class="r"><code>if (!require(performance)) {install.packages(c(&quot;performance&quot;, &quot;qqplotr&quot;), dependencies = T)}</code></pre>
<pre><code>## Loading required package: performance</code></pre>
<pre><code>## 
## Attaching package: &#39;performance&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:brms&#39;:
## 
##     pp_check</code></pre>
<pre><code>## The following objects are masked from &#39;package:Metrics&#39;:
## 
##     mae, mse, rmse</code></pre>
<pre class="r"><code>check_model(reg1)</code></pre>
<pre><code>## Loading required namespace: qqplotr</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-39-1.png" width="921.6" /> Ahora sobre los datos <code>Haem.csv</code>:</p>
<pre class="r"><code>check_model(reg_haem)</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-40-1.png" width="921.6" /></p>
</div>
<div id="comparación-de-regresiones" class="section level2">
<h2>Comparación de regresiones</h2>
<p>Supongamos ahora que la base de datos 1 en realidad consta de dos “grupos”. Una preguna razonable sería el saber si podemos agruparlos para realizar una RLS, y esto lo podemos resolver fácilmente con la prueba de Chow (1960). Primero, partamos los datos por aproximadamente la mitad:</p>
<pre class="r"><code>df.reg2 &lt;- df.reg1[,1:2]
df.reg2[&quot;grupo&quot;] &lt;- c(rep(&quot;A&quot;, 48), rep(&quot;B&quot;, 49))</code></pre>
<p>Ahora apliquemos la prueba de Chow, utilizando la función <code>chow.test(y1, x1, y2, x2)</code>:</p>
<pre class="r"><code>library(gap)
comp.reg &lt;- chow.test(y1 = df.reg2$v2[df.reg2$grupo == &quot;A&quot;],
                      x1 = df.reg2$v1[df.reg2$grupo == &quot;A&quot;],
                      y2 = df.reg2$v2[df.reg2$grupo == &quot;B&quot;],
                      x2 = df.reg2$v1[df.reg2$grupo == &quot;B&quot;])
print(comp.reg)</code></pre>
<pre><code>##      F value        d.f.1        d.f.2      P value 
## 1.154458e+01 2.000000e+00 9.300000e+01 3.323879e-05</code></pre>
<p>Veamos las regresiones gráficamente::</p>
<pre class="r"><code>ggplot(data = df.reg2, aes(x = v1, y = v2, colour = grupo, shape = grupo)) +
geom_point(alpha = 0.5, size = 3) +
geom_smooth(method = lm) +
blank_theme() +
labs(title = &quot;Regresión lineal con dos grupos&quot;,
     subtitle = paste(&quot;F (&quot;, comp.reg[&quot;d.f.1&quot;], &quot;, &quot;, comp.reg[&quot;d.f.2&quot;], &quot;) = &quot;, 
                      round(comp.reg[&quot;F value&quot;],2), &quot;, &quot;, &quot;p = &quot;, ifelse(comp.reg[&quot;P value&quot;] &lt; 0.001,
                                                                         &quot; &lt; 0.001&quot;,
                                                                         paste(&quot; = &quot;, comp.reg[&quot;P value&quot;]))),
     caption = &quot;Datos simulados&quot;)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="c8_rls_files/figure-html/unnamed-chunk-43-1.png" width="672" /></p>
</div>
<div id="ejercicio" class="section level2">
<h2>Ejercicio</h2>
<p>Aplicar la prueba de Chow a la base de datos <code>Haem.csv</code>, considerando los dos grupos en la columna <code>Loc</code>.</p>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiQ29ycmVsYWNpw7NuIHkgUmVncmVzacOzbiBMaW5lYWwgU2ltcGxlIgphdXRob3I6ICJNLiBlbiBDLiBBcnR1cm8gQmVsbCBFbnLDrXF1ZXogR2FyY8OtYSIKb3V0cHV0OgogICAgaHRtbF9kb2N1bWVudDoKICAgICAgZGZfcHJpbnQ6IHBhZ2VkCiAgICAgIHRoZW1lOiBjb3NtbwogICAgICB0b2M6IFRSVUUKICAgICAgdG9jX2Zsb2F0OiBUUlVFCiAgICAgIGNvZGVfZG93bmxvYWQ6IFRSVUUKLS0tCgoqKltWSURFT10oaHR0cHM6Ly95b3V0dS5iZS9TaDhvVWZJcE9uQSkqKgoKIyMgSW5zdGFsYWNpw7NuIGRlIGxpYnJlcsOtYXMKYGBge3J9CmlmKCFyZXF1aXJlKGdhcCkpIGluc3RhbGwucGFja2FnZXMoImdhcCIsIGRlcGVuZGVuY2llcyA9IFQpCmBgYAoKIyMgRnVuY2lvbmVzIHBlcnNvbmFsaXphZGFzCmBgYHtyfQojIFRlbWEgcGVyc29uYWxpemFkbwpibGFua190aGVtZSA8LSBmdW5jdGlvbigpewogIHRoZW1lKHBhbmVsLmdyaWQubWlub3IgPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICAgcGFuZWwuZ3JpZC5tYWpvciA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICBwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgIGF4aXMubGluZSA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICBhc3BlY3QucmF0aW8gPSAxLzEuNjEsCiAgICAgICAgYXhpcy50aWNrcyA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICB0ZXh0ID0gZWxlbWVudF90ZXh0KGNvbG91ciA9ICJncmF5NTAiKSwKICAgICAgICBsZWdlbmQucG9zaXRpb24gPSAibm9uZSIKICAgICAgICApCn0KCiMgRnVuY2nDs24gcGFyYSBncmFmaWNhciBsYSByZWxhY2nDs24gZW50cmUgZG9zIHZhcmlhYmxlczsgaS5lLiwgCiMgdW5hIGZvcm1hIGVsZWdhbnRlIGRlIGxsYW1hcmxlIGEgdW4gZ3LDoWZpY28gZGUgZGlzcGVyc2nDs24gY29uIHZhbG9yZXMgcG9yIGRlZmVjdG8uLi4KcmVsLnBsb3QgPC0gZnVuY3Rpb24oZGF0YSwgYWVzdCwgCiAgICAgICAgICAgICAgICAgICAgIG1lZGlkYXMgPSBUUlVFLCAKICAgICAgICAgICAgICAgICAgICAgY29ycmUgPSBOQSwgY292YXIgPSBOQSwgCiAgICAgICAgICAgICAgICAgICAgIGVxID0gIiIsIC4uLil7CiAgIyBDb25zdHJ1Y2Npw7NuIGRlbCBncsOhZmljbyBzaW4gYW5vdGFjaW9uZXMKICBwbG90IDwtIGdncGxvdChkYXRhID0gZGF0YSwgYWVzdCkgKyAKICAgICAgICAgIGxhYnModGl0bGUgPSAiUmVsYWNpw7NuIGVudHJlIGRvcyB2YXJpYWJsZXMiLAogICAgICAgICAgICAgICBjYXB0aW9uID0gcGFzdGUoIkRhdG9zIHNpbXVsYWRvczogIiwgZXEpKSArCiAgICAgICAgICBnZW9tX3BvaW50KGNvbG9yID0gImRlZXBza3libHVlNCIsIGFscGhhID0gMC41LCBzaXplID0gMikgKwogICAgICAgICAgZXhwYW5kX2xpbWl0cyh5ID0gYyg1LCAtMykpICsKICAgICAgICAgIGJsYW5rX3RoZW1lKCkKICAjIFNpIG1lZGlkYXMgZXMgVFJVRSwgYWdyZWdhciBsYXMgbWVkaWRhcyBhbCBncsOhZmljbwogIGlmKGlzVFJVRShtZWRpZGFzKSl7cGxvdCA8LSBwbG90ICsgYW5ub3RhdGUoInRleHQiLCB4ID0gMTUsIHkgPSAtMiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBwYXN0ZSgiQ29yLiA9ICIsIHJvdW5kKGNvcnJlLCAyKSwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJcbiBDb3YuID0gIiwgcm91bmQoY292YXIsMikpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9ICJncmF5NTAiKX0KICByZXR1cm4ocGxvdCkKfQpgYGAKCiMjIENvdmFyaWFuemEgdnMuIENvcnJlbGFjacOzbgpHZW5lcmVtb3MgdW4gcGFyIGRlIHZhcmlhYmxlcyBkb25kZSBsYSBzZWd1bmRhIHNlYSB1bmEgZnVuY2nDs24gbGluZWFsIGRlIGxhIHByaW1lcmE6CgpgYGB7cn0KZGYxIDwtIGRhdGEuZnJhbWUodjEgPSAtMjA6MjApCmRmMVsidjIiXSA8LSAoMTArMipkZjEkdjEpCmRmMQpgYGAKCk9idGVuZ2Ftb3MgbGEgY292YXJpYW56YToKYGBge3J9CmNvdmFyIDwtIGNvdihkZjEkdjEsIGRmMSR2MikKY292YXIKYGBgCgpBaG9yYSBjYWxjdWxlbW9zIGVsIMOtbmRpY2UgZGUgY29ycmVsYWNpw7NuCmBgYHtyfQpjb3JyZSA8LSBjb3IoZGYxJHYxLCBkZjEkdjIpCmNvcnJlCmBgYAoKUG9yIMO6bHRpbW8sIGdyYWZpcXVlbW9zIGxvcyByZXN1bHRhZG9zIGUgaW5jbHV5YW1vcyBlbCB2YWxvciBkZSBhbWJhcyBtZWRpZGFzOgpgYGB7cn0KbGlicmFyeShnZ3Bsb3QyKQpsaW4ucGxvdDEgPC0gcmVsLnBsb3QoZGF0YSA9IGRmMSwgYWVzdCA9IGFlcyh2MSwgdjIpLAogICAgICAgICAgICAgICAgICAgICAgZXEgPSAidjIgPSAxMCArIDIqdjEiLAogICAgICAgICAgICAgICAgICAgICAgY292YXIgPSBjb3ZhciwgY29ycmUgPSBjb3JyZSkKCmxpbi5wbG90MQpgYGAKCkFtYm9zIHJlc3VsdGFkb3Mgbm9zIGRpY2VuIHF1ZSBleGlzdGUgdW5hIHJlbGFjacOzbiBkaXJlY3RhbWVudGUgcHJvcG9yY2lvbmFsIGVudHJlIGFtYmFzIHZhcmlhYmxlcyAoY29uZm9ybWUgaW5jcmVtZW50YSB1bmEgaW5jcmVtZW50YSBsYSBvdHJhKTsgc2luIGVtYmFyZ28sIGRlYmlkbyBhIHF1ZSBsYSBjb3JyZWxhY2nDs24gc2UgZW5jdWVudHJhIGNvbnRlbmlkYSBlbnRyZSBbLTEsMV0gcG9kZW1vcyBjb21wcm9iYXIgcXVlIGVzIHVuYSByZWxhY2nDs24gTElORUFMIHBlcmZlY3RhLiBEZWJpZG8gYSBlc3RhIGRpZmVyZW5jaWEgZW4gaW50ZXJwcmV0YWJpbGlkYWQgbm9ybWFsbWVudGUgdHJhYmFqYXJlbW9zIGNvbiBlbCDDrW5kaWNlIGRlIGNvcnJlbGFjacOzbiwgcGVybyBlcyBpbXBvcnRhbnRlIHJlY29yZGFyIHF1ZSBlc3RhbW9zIHRyYWJhamFuZG8gY29uIHVuIGFuw6FsaXNpcyBwYXJhbcOpdHJpY28gcXVlIHN1cG9uZSB1bmEgcmVsYWNpw7NuIGRlbCB0aXBvICRZID0gXGJldGFfMCArIFxiZXRhXzFcY2RvdCBYICsgXGVwc2lsb24kIHkgcXVlIHBvciB0YW50byBwdWVkZSBOTyBzZXIgdW5hIGZvcm1hIGFkZWN1YWRhIHBhcmEgZGVzY3JpYmlyIGxvcyBkYXRvcywgdmVhbW9zIHVuIGVqZW1wbG86CgpgYGB7cn0KZGYxWyJ2MyJdIDwtICgtZGYxJHYxXjIpCgpwb3QucGxvdCA8LSByZWwucGxvdChkYXRhID0gZGYxLCBhZXN0ID0gYWVzKHYxLCB2MyksCiAgICAgICAgICAgICAgICAgICAgIGVxID0gInYzID0gLXYxXjIiLAogICAgICAgICAgICAgICAgICAgICBjb3ZhciA9IGNvdihkZjEkdjIsIGRmMSR2MyksCiAgICAgICAgICAgICAgICAgICAgIGNvcnJlID0gY29yKGRmMSR2MiwgZGYxJHYzKQogICAgICAgICAgICAgICAgICAgICApCnBvdC5wbG90CmBgYAoKT3RybyBlamVtcGxvOgpgYGB7cn0KZGYxWyJ2NCJdIDwtIHNpbihkZjEkdjEpCgpzaW4ucGxvdCA8LSByZWwucGxvdChkYXRhID0gZGYxLCBhZXN0ID0gYWVzKHYxLCB2NCksCiAgICAgICAgICAgICAgICAgICAgIGVxID0gInY0ID0gc2luKHYxKSIsCiAgICAgICAgICAgICAgICAgICAgIGNvdmFyID0gY292KGRmMSR2MSwgZGYxJHY0KSwKICAgICAgICAgICAgICAgICAgICAgY29ycmUgPSBjb3IoZGYxJHYxLCBkZjEkdjQpKQpzaW4ucGxvdApgYGAKCiMjIyBDb3JyZWxhY2nDs24gZGUgUGVhcnNvbiB2cy4gQ29ycmVsYWNpw7NuIGRlIFNwZWFybWFuCkEgZGlmZXJlbmNpYSBkZSBsYSBjb3JyZWxhY2nDs24gZGUgUGVhcnNvbiBsYSBjb3JyZWxhY2nDs24gZGUgU3BlYXJtYW4gbm9zIHBlcm1pdGUgY2FsY3VsYXIgbGEgY29ycmVsYWNpw7NuIGVudHJlIHZhcmlhYmxlcyBvcmRpbmFsZXMgbyBjb250aW51YXMsIHNpZW1wcmUgeSBjdWFuZG8gbGEgcmVsYWNpw7NuIHNlYSBtb27Ds3RvbmE6CmBgYHtyfQpkZjIgPC0gZGF0YS5mcmFtZSh2MSA9IGRmMSR2MVtkZjEkdjEgPiAwXSwgCiAgICAgICAgICAgICAgICAgIHYyID0gZGYxJHYxW2RmMSR2MSA+IDBdXjIsCiAgICAgICAgICAgICAgICAgIG1vbm8gPSAibW9uw7N0b25hIikKCmRmMiA8LSByYmluZChkZjIsIGRhdGEuZnJhbWUodjE9IGRmMSR2MSwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBkZjEkdjMsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbm8gPSAibm8gbW9uw7N0b25hIikpCgptb25vLnBsb3QgPC0gcmVsLnBsb3QoZGF0YSA9IGRmMiwgYWVzdCA9IGFlcyh2MSwgdjIpLAogICAgICAgICAgICAgICAgICAgICAgZXEgPSAidjIgPSAxMCArIDIqdjEgfCB2MiA9IC12MV4yIiwKICAgICAgICAgICAgICAgICAgICAgIG1lZGlkYXMgPSBGQUxTRSkgKyAKICAgICAgICAgICAgIGZhY2V0X3dyYXAofm1vbm8sIG5yb3cgPSAyLCBzY2FsZXMgPSAiZnJlZV95IikgKwogICAgICAgICAgICAgdGhlbWUoYXNwZWN0LnJhdGlvID0gMS8xLjYxKQoKbW9uby5wbG90CmBgYAoKVXRpbGljZW1vcyBlbCBwcmltZXIgY2FzbyBwYXJhIGNhbGN1bGFyIGxhcyBjb3JyZWxhY2lvbmVzIGRlIFBlYXJzb24geSBTcGVhcm1hbiB5IHZlciBsYXMgZGlmZXJlbmNpYXMKYGBge3J9CnBhc3RlKCJQZWFyc29uID0gIiwKICAgICAgcm91bmQoKGNvcihkZjIkdjFbZGYyJG1vbm8gPT0gIm1vbsOzdG9uYSJdLAogICAgICAgICAgICAgICAgIGRmMiR2MltkZjIkbW9ubyA9PSAibW9uw7N0b25hIl0sIAogICAgICAgICAgICAgICAgIG1ldGhvZCA9ICJwZWFyc29uIikpLCAyKQogICAgICApCgoKcGFzdGUoIlNwZWFybWFuID0gIiwKICAgICAgcm91bmQoKGNvcihkZjIkdjFbZGYyJG1vbm8gPT0gIm1vbsOzdG9uYSJdLAogICAgICAgICAgICAgICAgIGRmMiR2MltkZjIkbW9ubyA9PSAibW9uw7N0b25hIl0sIAogICAgICAgICAgICAgICAgIG1ldGhvZCA9ICJzcGVhcm1hbiIpKSwgMikKICAgICAgKQpgYGAKCiMjIFJlZ3Jlc2nDs24gTGluZWFsIFNpbXBsZQoKVW4gbW9kZWxvIGRlIHJlZ3Jlc2nDs24gZXMgdW4gbW9kZWxvIHByZWRpY3Rpdm8gZGUgKiphcHJlbmRpemFqZSBhdXRvbWF0aXphZG8qKiBlbiBlbCBjdWFsLCBhIHBhcnRpciBkZSBsb3MgZGF0b3MgZGlzcG9uaWJsZXMgYWwgbW9tZW50bywgcG9kZW1vcyBpbnRlbnRhciBwcmVkZWNpciByZXN1bHRhZG9zIGZ1dHVyb3MgKGV4dHJhcG9sYWNpw7NuKSBvIHJlc3VsdGFkb3MgY29uIGxvcyBxdWUgbm8gY29udGFtb3MgKGludGVycG9sYWNpw7NuKTsgZXMgZGVjaXIsIHJlc3VsdGFkb3MgcXVlIGVsIG1vZGVsbyBubyBoYXlhIHZpc3RvLiBTaSBsYXMgcHJlZGljY2lvbmVzIHNvbiBhZGVjdWFkYXMsIGVsIG1vZGVsbyBub3MgcHVlZGUgc2VydmlyIHBhcmEgZGVzY3JpYmlyIGxhIG5hdHVyYWxlemEgZGUgbGEgcmVsYWNpw7NuIGRlIGFtYmFzIHZhcmlhYmxlcywgYWwgbWVub3MgZW4gdMOpcm1pbm9zIG1hdGVtw6F0aWNvcy9udW3DqXJpY29zLiBFbiBlc3RhIHNlc2nDs24gcmV2aXNhcmVtb3MgYWxndW5vcyBjcml0ZXJpb3MgcGFyYSBldmFsdWFyIGxhIGJvbmRhZCBkZSBhanVzdGUgZGUgbnVlc3RybyBtb2RlbG8gKGxpdC4gcXXDqSB0YW4gYnVlbm8gZXMpLCBhdW5xdWUgbm9zIGxpbWl0YXJlbW9zLCBwb3IgZWwgbW9tZW50bywgYSBoYWJsYXIgw7puaWNhbWVudGUgZW4gdMOpcm1pbm9zIGRlIG51ZXN0cm9zIGRhdG9zLiBDdWFuZG8gbGxlZ3VlbW9zIGEgbGEgc2VjY2nDs24gZGUgbXVsdGl2YXJpYWRvIGhhYmxhcmVtb3Mgc29icmUgZWwgcHJvYmxlbWEgZGUgbGEgbWVtb3JpemFjacOzbi9zb2JyZS1hanVzdGUgeSB1bmEgZm9ybWEgbcOhcyBvYmpldGl2YSBkZSBldmFsdWFyIG51ZXN0cm9zIG1vZGVsb3MuCgpFbCBtb2RlbG8gZGUgUmVncmVzacOzbiBtw6FzIHNlbmNpbGxvIGVzIGxhIHJlZ3Jlc2nDs24gbGluZWFsIHNpbXBsZSwgZW4gbGEgY3VhbCBkZXNjcmliaW1vcyBsYSByZWxhY2nDs24gZW50cmUgZG9zIHZhcmlhYmxlcyBjb250aW51YXMgdXRpbGl6YW5kbyBsYSBlY3VhY2nDs24gZGUgbGEgcmVjdGEuIEVzIGRlY2lyLCBhc3VtaW1vcyB1bmEgcmVsYWNpw7NuIGRlbCB0aXBvICR5ID0gXGJldGFfMCBccG0gXGJldGFfMSp4ICsgXGVwc2lsb24kLCBlbiBlbCBjdWFsICRcYmV0YV8wJCByZXByZXNlbnRhIGxhIG9yZGVuYWRhIGFsIG9yaWdlbiAoeCA9IDApIHkgJFxiZXRhXzEkIGxhIHBlbmRpZW50ZSBkZSBsYSByZWN0YSBvLCBlbiBvdHJhcyBwYWxhYnJhcywgY3XDoW50YXMgdW5pZGFkZXMgbm9zIG1vdmVtb3MgZW4gZWwgZWplIHkgcG9yIGNhZGEgdW5pZGFkIGVuIGVsIGVqZSB4LiBSZWNvcmRlbW9zIHF1ZSBsYSAqKmZ1bmNpw7NuIGRlIHDDqXJkaWRhKiogcGFyYSBlc3RlIGFuw6FsaXNpcyBlcyBsYSBkaXN0YW5jaWEgY3VhZHLDoXRpY2EgZW50cmUgdmFsb3JlcyBvYnNlcnZhZG9zIHkgcHJlZGljaG9zOyBlcyBkZWNpciwgZWwgbcOpdG9kbyBkZSAqKm3DrW5pbW9zIGN1YWRyYWRvcyoqLgoKUGFyYSBlamVtcGxpZmljYXJsbywgY2FyZ3VlbW9zIGxvcyBkYXRvcyBjb250ZW5pZG9zIGVuIGBleGFtcGxlX2RhdGEuY3N2YDoKCmBgYHtyfQpkZi5yZWcxIDwtIHJlYWQuY3N2KCJkYXRhL2V4YW1wbGVfZGF0YS5jc3YiKQpkYXRhLnJlZzEgPC0gcmVsLnBsb3QoZGF0YSA9IGRmLnJlZzEsIGFlc3QgPSBhZXModjEsIHYyKSwgCiAgICAgICAgICAgICAgICAgICAgICBtZWRpZGFzID0gVCwKICAgICAgICAgICAgICAgICAgICAgIGNvcnJlID0gY29yKGRmLnJlZzEkdjEsIGRmLnJlZzEkdjIpLAogICAgICAgICAgICAgICAgICAgICAgY292YXIgPSBjb3YoZGYucmVnMSR2MSwgZGYucmVnMSR2MikpCmRhdGEucmVnMQpgYGAKCiMjIyBBanVzdGUgeSBCb25kYWQgZGUgYWp1c3RlCkFqdXN0ZW1vcyBlbCBtb2RlbG8gZGUgbcOtbmltb3MgY3VhZHJhZG9zIGEgbG9zIGRhdG9zIHkgdmVhbW9zIGxvcyByZXN1bHRhZG9zIGRlIGxhIHJlZ3Jlc2nDs24uIE9ic2VydmVtb3MgcXVlIGVuIGxvcyByZXN1bHRhZG9zIHNlIGluY2x1eWVuIDMgcHJ1ZWJhcyBkZSBoaXDDs3Rlc2lzOiB1bmEgcHJ1ZWJhIGRlIHQgcGFyYSBjYWRhIHBhcsOhbWV0cm8geSB1bmEgcHJ1ZWJhIGRlIEFOT1ZBIChxdWUgaWdub3JhcmVtb3MgcG9yIGVsIG1vbWVudG8pLiBEZSBlc3RhcyBwcmllYmFzIGVzIHBvc2libGUgY29uY2x1aXIgcXVlIGxvcyBwYXLDoW1ldHJvcyBzb24gZGlmZXJlbnRlcyBkZSB1biBtb2RlbG8gbnVsbzsgZXMgZGVjaXIsIGRlIHVuIG1vZGVsbyBlbiBlbCBxdWUgJFxiZXRhXzAgPSAwOyBcYmV0YV8xID0gMCQuIEVsIHZhbG9yIGRlICRSXjIkIHN1Z2llcmUgcXVlIGVsIG1vZGVsbyDDum5pY2FtZW50ZSBleHBsaWNhIGFscmVkZWRvciBkZWwgNzAlIGRlIGxhIHZhcmlhbnphIGRlIGxvcyBkYXRvcywgbG8gY3VhbCBzdWdpZXJlIHF1ZSBlbCBtb2RlbG8gbm8gZXN0w6EgY2FwdHVyYW5kbyBhcHJveGltYWRhbWVudGUgdW5hIHRlcmNlcmEgcGFydGUgZGUgbGEgaW5mb3JtYWNpw7NuIGNvbnRlbmlkYSBlbiBlbGxvcy4gRmluYWxtZW50ZSwgZWwgdmFsb3IgZGUgUlNFIGRpdmlkaWRvIGVudHJlIGVsIHZhbG9yIHByb21lZGlvIGRlIGxhIHZhcmlhYmxlIHByZWRpY2hhIG5vcyBkYSBsYSB0YXNhIGRlIGVycm9yIGRlbCBtb2RlbG8uIEVsIFJTRSB0YW1iacOpbiBub3MgaW5kaWNhIGVuIGN1w6FudGFzIHVuaWRhZGVzIHNlIGRlc3bDrWEgbGEgcHJlZGljY2nDs24gZGUgbG9zIGRhdG9zIG9ic2VydmFkb3MsIHF1ZSBlbiBlc3RlIGNhc28gc29uIDMuMDk1LgoKYGBge3J9CnJlZzEgPC0gbG0odjJ+djEsIGRhdGEgPSBkZi5yZWcxKQpzdW1tYXJ5KHJlZzEpCnN1bV9yZXMgPC0gc3VtbWFyeShyZWcxKQpwYXN0ZSgiVGFzYSBkZSBlcnJvciA9ICIsIGFzLmNoYXJhY3Rlcihyb3VuZChzdW1fcmVzJHNpZ21hL21lYW4oZGYucmVnMSR2MiksIDIpKjEwMCksICIlIikKYGBgCgpBaG9yYSBncmFmaXF1ZW1vcyBsYSByZWN0YSBhanVzdGFkYS4gUGFyYSBlbGxvIHByaW1lcm8gZXh0cmFlcmVtb3MgbG9zIHZhbG9yZXMgYWp1c3RhZG9zIHkgZGVzcHXDqXMgbG9zIHV0aWxpemFyZW1vcyBwYXJhIGNvbnN0cnVpciBsYSBsaW5lYSByZWN0YQpgYGB7cn0KZGYucmVnMVsiYWp1c3RhZG9zIl0gPC1yZWcxJGZpdHRlZC52YWx1ZXMKCmxpbi5wbG90MiA8LSBkYXRhLnJlZzEgKyAKICAgICAgICAgICAgIGdlb21fbGluZShkYXRhID0gZGYucmVnMSwgCiAgICAgICAgICAgICAgICAgICAgICAgYWVzKHggPSB2MSwgeSA9IGFqdXN0YWRvcyksCiAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyID0gcmdiKDExOCw3OCwxNDQsIG1heENvbG9yVmFsdWUgPSAyNTUpLAogICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSAxKSArCiAgICAgICAgICAgICBsYWJzKHN1YnRpdGxlID0gcGFzdGUoIk1vZGVsbyBhanVzdGFkbzogdjIgPSAiLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZChyZWcxJGNvZWZmaWNpZW50c1sxXSwyKSwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIiArICIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQocmVnMSRjb2VmZmljaWVudHNbMl0sMiksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIip2MSArIGUiKSkKICAgICAgICAgICAgIApsaW4ucGxvdDIKYGBgCgojIyMgSW50ZXJ2YWxvcyBkZSBjb25maWFuemEgcGFyYSBsb3MgcGFyw6FtZXRyb3MgeSBsYSByZWdyZXNpw7NuCkFob3JhIHBvZGVtb3MgY2FsY3VsYXIgeSBncmFmaWNhciBsb3MgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEgcGFyYSBsYSBwcmVkaWNjacOzbiBkZSBsYSByZWdyZXNpw7NuOgoKYGBge3J9CmNvbmZpbnQucmVnMSA8LSBjb25maW50KHJlZzEpCmNvbmZpbnQucmVnMQpgYGAKYGBge3J9CmRmLnJlZzFbImluZi5pbnQiXSA8LSBjb25maW50LnJlZzFbMSwxXSArIGNvbmZpbnQucmVnMVsyLDFdKmRmLnJlZzEkdjEgCmRmLnJlZzFbInN1cC5pbnQiXSA8LSBjb25maW50LnJlZzFbMSwyXSArIGNvbmZpbnQucmVnMVsyLDJdKmRmLnJlZzEkdjEKCmxpbi5wbG90MyA8LSBsaW4ucGxvdDIgKyAKICAgICAgICAgICAgIGdlb21fcmliYm9uKGRhdGEgPSBkZi5yZWcxLCBhZXMoeW1pbiA9IGluZi5pbnQsIHltYXggPSBzdXAuaW50KSwgCiAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsID0gImdyYXk3MCIsCiAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IDAuMykgKwogICAgICAgICAgICAgbGFicyhjYXB0aW9uID0gIkRhdG9zIHNpbXVsYWRvcy4gRWwgw6FyZWEgZ3JpcyByZXByZXNlbnRhIGxvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSBhbCA5NSUgXG4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZSBsYSBlc3RpbWFjacOzbiBkZSBhbWJvcyBwYXLDoW1ldHJvcyIpCmxpbi5wbG90MwpgYGAKCmBgYHtyfQpjb25mLnBsb3QucmVnMSA8LSBkYXRhLnJlZzEgKyBnZW9tX3Ntb290aChtZXRob2QgPSBsbSwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91ciA9IHJnYigxMTgsNzgsMTQ0LCBtYXhDb2xvclZhbHVlID0gMjU1KSkgKwogICAgICAgICAgICAgICAgICBsYWJzKGNhcHRpb24gPSAiRGF0b3Mgc2ltdWxhZG9zLiBFbCDDoXJlYSBncmlzIHJlcHJlc2VudGEgZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSBkZSBsYSByZWdyZXNpw7NuIGFsIDk1JSIsCiAgICAgICAgICAgICAgICAgICAgICAgc3VidGl0bGUgPSBwYXN0ZSgiTW9kZWxvIGFqdXN0YWRvOiB2MiA9ICIsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKHJlZzEkY29lZmZpY2llbnRzWzFdLDIpLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiICsgIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZChyZWcxJGNvZWZmaWNpZW50c1syXSwyKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiKnYxICsgZSIpKQpjb25mLnBsb3QucmVnMQpgYGAKCiMjIyBHcsOhZmljb3MgZGlhZ27Ds3N0aWNvcyBkZSBsYSByZWdyZXNpw7NuCkFob3JhIGV2YWx1ZW1vcyBncsOhZmljYW1lbnRlIGxhIGNhbGlkYWQgZGVsIG1vZGVsbyBhanVzdGFkby4KCiMjIyNHcsOhZmljbyBjdWFudGlsLWN1YW50aWwKRXMgcG9zaWJsZSBvYnNlcnZhciBxdWUgbG9zIGRhdG9zIHByZXNlbnRhbiB1bmEgZ3JhbiBjYW50aWRhZCBkZSBkZXN2aWFjaW9uZXMgY29uIHJlc3BlY3RvIGEgdW5hIGRpc3RyaWJ1Y2nDs24gbm9ybWFsOgpgYGB7cn0KdyA8LSBzaGFwaXJvLnRlc3QoZGYucmVnMSR2MikKCnFxcGxvdDEgPC0gZ2dwbG90KGRhdGEgPSBkZi5yZWcxLCBhZXMoc2FtcGxlID0gdjIpKSArIAogICAgICAgICAgIGdlb21fcXEoY29sb3VyID0gImRlZXBza3libHVlNCIsIHNpemUgPSAzLCBhbHBoYSA9IDAuNSkgKyAKICAgICAgICAgICBnZW9tX3FxX2xpbmUoY29sb3VyID0gcmdiKDExOCw3OCwxNDQsIG1heENvbG9yVmFsdWUgPSAyNTUpLCBzaXplID0gMSkgKyAKICAgICAgICAgICBhbm5vdGF0ZSgidGV4dCIsIHggPSAxLCB5ID0gMCwgCiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBwYXN0ZSgiVyA9ICIsIHJvdW5kKHdbWyJzdGF0aXN0aWMiXV0sMiksICI7IHAgIiwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2Uod1tbInAudmFsdWUiXV0gPCAwLjAwMSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiPCAwLjAwMSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQod1tbInAudmFsdWUiXV0sMikpKSwKICAgICAgICAgICAgICAgICAgICBjb2xvdXIgPSAiZ3JheSA1MCIKICAgICAgICAgICAgICAgICAgICApICsKICAgICAgICAgICBibGFua190aGVtZSgpICsKICAgICAgICAgICBsYWJzKHRpdGxlID0gIkdyw6FmaWNvIFFRIiwKICAgICAgICAgICAgICAgIHggPSAiQ3VhbnRpbGVzIHRlw7NyaWNvcyBwYXJhIGxhIG11ZXN0cmEiLAogICAgICAgICAgICAgICAgeSA9ICJEYXRvcyBvYnNlcnZhZG9zIikKcXFwbG90MQpgYGAKYGBge3J9CncxIDwtIHNoYXBpcm8udGVzdChyc3RhbmRhcmQocmVnMSkpCnFxcGxvdDIgPC0gZ2dwbG90KHJlZzEpICsgc3RhdF9xcShhZXMoc2FtcGxlID0gLnN0ZHJlc2lkKSwgY29sb3VyID0gImRlZXBza3libHVlNCIsIHNpemUgPSAzLCBhbHBoYSA9IDAuNSkgKyAKICAgICAgICAgICBnZW9tX2FibGluZShjb2xvdXIgPSAgcmdiKDExOCw3OCwxNDQsIG1heENvbG9yVmFsdWUgPSAyNTUpLCBzaXplID0gMSkgKyAKICAgICAgICAgICBsYWJzKHggPSAiQ3VhbnRpbGVzIHRlw7NyaWNvcyIsCiAgICAgICAgICAgICAgICB5ID0gIlJlc2lkdWFsZXMgZXN0YW5kYXJpemFkb3MiLAogICAgICAgICAgICAgICAgdGl0bGUgPSAiR3LDoWZpY28gUVEiLAogICAgICAgICAgICAgICAgc3VidGl0bGUgPSBwYXN0ZSgiVyA9ICIsIHJvdW5kKHcxW1sic3RhdGlzdGljIl1dLDIpLCAiOyBwICIsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKHcxW1sicC52YWx1ZSJdXSA8IDAuMDAxLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICI8IDAuMDAxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZCh3W1sicC52YWx1ZSJdXSwyKSkpKSArCiAgICAgICAgICAgYmxhbmtfdGhlbWUoKQpxcXBsb3QyCgoKYGBgCgojIyMjIEdyw6FmaWNvIGRlIEVzY2FsYS1Mb2NhY2nDs24KRW4gZXN0ZSBncsOhZmljbyBlcyBwb3NpYmxlIG9ic2VydmFyIHF1ZSBsb3MgZGF0b3Mgbm8gZXN0w6FuIGRpc3RyaWJ1w61kb3MgZGUgbWFuZXJhIGhvbW9nw6luZWE7IGVzIGRlY2lyLCBubyBzb24gZGF0b3MgaGV0ZXJvY2Vkw6FzdGljb3MKYGBge3J9CnNjYWxlLmxvYy5wbG90IDwtIGdncGxvdChyZWcxLCBhZXMoLmZpdHRlZCwgc3FydChhYnMoLnN0ZHJlc2lkKSkpKSArIAogICAgICAgICAgICAgICAgICBnZW9tX3BvaW50KG5hLnJtPVRSVUUsIGNvbG91ciA9ICJkZWVwc2t5Ymx1ZTQiLCBzaXplID0gMywgYWxwaGEgPSAwLjUpICsgCiAgICAgICAgICAgICAgICAgIHN0YXRfc21vb3RoKG1ldGhvZD0ibG9lc3MiLCBuYS5ybSA9IFRSVUUsIGNvbG91ciA9IHJnYigxMTgsNzgsMTQ0LCBtYXhDb2xvclZhbHVlID0gMjU1KSkgKwogICAgICAgICAgICAgICAgICBsYWJzKHggPSAiVmFsb3JlcyBhanVzdGFkb3MiLAogICAgICAgICAgICAgICAgICAgICAgIHkgPSBleHByZXNzaW9uKHNxcnQoInxSZXNpZHVhbGVzIGVzdGFuZGFyaXphZG9zfCIpKSwKICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICJFc2NhbGEtTG9jYWNpw7NuIgogICAgICAgICAgICAgICAgICAgICAgICkgKwogICAgICAgICAgICAgICAgICBibGFua190aGVtZSgpCiAgICAgICAgICAgICAgICAgIApzY2FsZS5sb2MucGxvdApgYGAKCgojIyMjIEdyw6FmaWNvIGRlIFJlc2lkdWFsZXMKRXMgcG9zaWJsZSBvYnNlcnZhciBxdWUgZXhpc3RlIHVuYSBjYW50aWRhZCBpbXBvcnRhbmRlIGRlIGRhdG9zIGV4dHJlbW9zIChmdWVyYSBkZSAkXHBtJCAyIGRlc3ZpYWNpb25lcyBlc3TDoW5kYXIpCmBgYHtyfQpkZi5yZWcxWyJzdGQucmVzaWRzIl0gPC0gcnN0YW5kYXJkKHJlZzEpCnJlc2lkLnBsb3QgPC0gZ2dwbG90KGRhdGEgPSBkZi5yZWcxLCBhZXMoeCA9IGFqdXN0YWRvcywgeSA9IHN0ZC5yZXNpZHMsIGNvbG91ciA9IHN0ZC5yZXNpZHMpKSArIAogICAgICAgICAgICAgIGdlb21fcG9pbnQoc2l6ZSA9IDMsIGFscGhhID0gMC41KSArCiAgICAgICAgICAgICAgc3RhdF9zbW9vdGgobWV0aG9kID0gImxvZXNzIiwgY29sb3VyID0gcmdiKDExOCw3OCwxNDQsIG1heENvbG9yVmFsdWUgPSAyNTUpKSArIAogICAgICAgICAgICAgIGdlb21faGxpbmUoeWludGVyY2VwdCA9IDAsIGNvbCA9ICJyZWQiLCBsaW5ldHlwZSA9ICJkYXNoZWQiKSArCiAgICAgICAgICAgICAgbGFicyh0aXRsZSA9ICJHcsOhZmljbyBkZSBSZXNpZHVhbGVzIiwKICAgICAgICAgICAgICAgICAgIHggPSAiVmFsb3JlcyBhanVzdGFkb3MiLAogICAgICAgICAgICAgICAgICAgeSA9ICJSZXNpZHVhbGVzIGVzdGFuZGFyaXphZG9zIikgKwogICAgICAgICAgICAgIGJsYW5rX3RoZW1lKCkgKwogICAgICAgICAgICAgIHNjYWxlX2NvbG9yX2dyYWRpZW50Mihsb3cgPSAiZmlyZWJyaWNrIiwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZHBvaW50ID0gMCwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZCA9ICJkZWVwc2t5Ymx1ZTQiLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaCA9ICJmaXJlYnJpY2siLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha3MgPSBjKC0yLCAwLCAyKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXRzID0gYygtMiwgMiksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9vYiA9IHNjYWxlczo6c3F1aXNoKQpyZXNpZC5wbG90CmBgYAoKYGBge3J9CnJlc2lkLnBsb3QyIDwtIGdncGxvdChyZWcxLCBhZXMoeCA9IC5maXR0ZWQsIHkgPSAuc3RkcmVzaWQsIGNvbG91ciA9IC5zdGRyZXNpZCkpICsgCiAgICAgICAgICAgICAgIGdlb21fcG9pbnQoc2l6ZSA9IDMsIGFscGhhID0gMC41KSArCiAgICAgICAgICAgICAgIGdlb21faGxpbmUoeWludGVyY2VwdCA9IDAsIGNvbCA9ICJyZWQiLCBsaW5ldHlwZSA9ICJkYXNoZWQiKSArCiAgICAgICAgICAgICAgIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsb2VzcyIsIGNvbG91ciA9IHJnYigxMTgsNzgsMTQ0LCBtYXhDb2xvclZhbHVlID0gMjU1KSkgKwogICAgICAgICAgICAgICBsYWJzKHRpdGxlID0gIkdyw6FmaWNvIGRlIFJlc2lkdWFsZXMiLAogICAgICAgICAgICAgICAgICAgeCA9ICJWYWxvcmVzIGFqdXN0YWRvcyIsCiAgICAgICAgICAgICAgICAgICB5ID0gIlJlc2lkdWFsZXMgZXN0YW5kYXJpemFkb3MiKSArCiAgICAgICAgICAgICAgIGJsYW5rX3RoZW1lKCkgKwogICAgICAgICAgICAgICBzY2FsZV9jb2xvcl9ncmFkaWVudDIobG93ID0gImZpcmVicmljayIsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlkcG9pbnQgPSAwLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZCA9ICJkZWVwc2t5Ymx1ZTQiLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2ggPSAiZmlyZWJyaWNrIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrcyA9IGMoLTIsIDAsIDIpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXRzID0gYygtMiwgMiksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvb2IgPSBzY2FsZXM6OnNxdWlzaCkKcmVzaWQucGxvdDIKYGBgCmBgYHtyfQpzaGFwaXJvLnRlc3QoZGYucmVnMSRzdGQucmVzaWRzKQpgYGAKCiMjIEFqdXN0ZSBwb3IgbcOheGltYSB2ZXJvc2ltaWxpdHVkCgpSZWNvcmRlbW9zIHF1ZSBhbCByZWFsaXphciBlbCBhanVzdGUgcG9yIG3DoXhpbWEgdmVyb3NpbWlsaXR1ZCBlc3RhbW9zIGVuY29udHJhbmRvIGxvcyB2YWxvcmVzIGRlIGxvcyBwYXLDoW1ldHJvcyBxdWUgTUFYSU1JQ0VOIGxhIHByb2JhYmlsaWRhZCBkZSBoYWJlciBlbmNvbnRyYWRvIGxvcyBkYXRvcyAodmVyb3NpbWlsaXR1ZCk7IGVzIGRlY2lyLCBlcyBtw6l0b2RvIHByb2JhYmlsw61zdGljby4gRW4gZWwgY2FzbyBkZSBsYSBSTFMsIG51ZXN0cm8gbW9kZWxvIGVuY3VlbnRyYSBsYSBtw6F4aW1hIGV4cGVjdGF0aXZhIGRlIHkgKGZvcm1hIGVsZWdhbnRlIGRlIGxsYW1hcmxlIGEgbGEgbWVkaWEpLCBzaWd1aWVuZG8gdW5hIGRpc3RyaWJ1Y2nDs24gbm9ybWFsLiBFbiBsYSBjbGFzZSBkZSBHTE0gUm9iZXJ0byBleHBsaWNhcsOhIGPDs21vIGFqdXN0YXIgbW9kZWxvcyBsaW5lYWxlcyBlbiBsb3MgcXVlIGVsIGVycm9yIE5PIHNlIG1vZGVsYSBiYWpvIHVuYSBkaXN0cmlidWNpw7NuIG5vcm1hbCB5IGxvcyBjcml0ZXJpb3MgcGFyYSBzdSBmb3JtYWNpw7NuLgoKQSBkaWZlcmVuY2lhIGRlIGxhIGltcGxlbWVudGFjacOzbiBkZSB1bmEgcmVncmVzacOzbiBwb3IgbcOtbmltb3MgY3VhZHJhZG9zLCBhanVzdGFyIGVsIG1vZGVsbyBtZWRpYW50ZSBtw6F4aW1hIHZlcm9zaW1pbGl0dWQgbm8gZXMgdGFuIGludHVpdGl2by4gRWwgcHJpbWVyIHBhc28gZXMgZXN0YWJsZWNlciBtYW51YWxtZW50ZSBudWVzdHJhIGZ1bmNpw7NuIGRlIHZlcm9zaW1pbGl0dWQsIGFqdXN0YW5kbyB1bmEgZGlzdHJpYnVjacOzbiBub3JtYWwgYSBsb3MgcmVzaWR1YWxlczoKCmBgYHtyfQpkYXRhIDwtIGRmLnJlZzFbYygidjEiLCAidjIiKV0KTEwgPC0gZnVuY3Rpb24oYjAsIGIxLCBtdSwgc2lnbWEpewogICMgRW5jb250cmFyIGxvcyByZXNpZHVhbGVzLiBNb2RlbG8gYSBhanVzdGFyCiAgUiA9IGRhdGEkdjIgLSBkYXRhJHYxICogYjEgLSBiMAogIAogICMgQ2FsY3VsYXIgbGEgdmVyb3NpbWlsaXR1ZC4gUmVzaWR1YWxlcyBjb24gZGlzdHJpYnVjacOzbiBub3JtYWwuCiAgCiAgUiA9IHN1cHByZXNzV2FybmluZ3MoZG5vcm0oUiwgbXUsIHNpZ21hKSkKICAKICAjIFN1bWFyIGVsIGxvZ2FyaXRtbyBkZSBsYXMgdmVyb3NpbWlsaXR1ZGVzIHBhcmEgdG9kb3MgbG9zIHB1bnRvcyBkZSBkYXRvcy4KICAtc3VtKGxvZyhSKSkKfQpgYGAKCkFob3JhIGFqdXN0YW1vcyBlbCBtb2RlbG8gcXVlIGFjYWJhbW9zIGRlIGNyZWFyLCB1dGlsaXphbmRvIGxhIGZ1bmNpw7NuIGBtbGUoZnVuLCBzdGFydCA9IGxpc3QoKSlgIChtYXhpbXVtIGxpa2VsaWhvb2QgZXN0aW1hdGlvbiksIGRvbmRlIGBmdW5gIGVzIGxhIGZ1bmNpw7NuIGEgYWp1c3RhciB5IGBzdGFydGAgc29uIGxvcyB2YWxvcmVzIGluaWNpYWxlcyBkZSBsb3MgcGFyw6FtZXRyb3MuIEVuIGVzdGUgcGFzbyBsbyBxdWUgZXN0YW1vcyBoYWNpZW5kbyBlcyBlc3RpbWFyIGxvcyBkb3MgcGFyw6FtZXRyb3MgKG1lZGlhIHkgZGVzdmlhY2nDs24gZXN0w6FuZGFyKSBxdWUgbWVqb3IgZGVzY3JpYmVuIGxvcyBkYXRvczoKYGBge3J9CmxpYnJhcnkoc3RhdHM0KQptbGUuZml0IDwtIG1sZShMTCwgc3RhcnQgPSBsaXN0KGIwID0gMSwgYjEgPSAxLCBzaWdtYSA9IDEpLCAKICAgICAgICAgICAgICAgZml4ZWQgPSBsaXN0KG11ID0gMCksIAogICAgICAgICAgICAgICBub2JzID0gbGVuZ3RoKGRhdGEkdjIpKQoKc3VtbWFyeShtbGUuZml0KQpgYGAKClNpIG5vcyBpbnRlcmVzYSBjb21wYXJhciBlbCBhanVzdGUgZW50cmUgbW9kZWxvcyBwb2RlbW9zIHV0aWxpemFyIGVsIFJNU0UuIFBhcmEgZWxsbyBwcmltZXJvIGdlbmVyYXJlbW9zIGxvcyB2YWxvcmVzIHByZWRpY2hvcyAoYWp1c3RhZG9zKSBwb3IgZWwgbW9kZWxvIHkgZGVzcHXDqXMgbG9zIGNvbnRyYXN0YXJlbW9zIGNvbnRyYSBsb3MgZGF0b3Mgb3JpZ2luYWxlcwoKYGBge3J9CmxpYnJhcnkoTWV0cmljcykKZGF0YVsidjJhZGoiXSA8LSBjb2VmKG1sZS5maXQpWyJiMCJdICsgY29lZihtbGUuZml0KVsiYjEiXSpkYXRhJHYxCnJtc2UoZGF0YSR2MmFkaiwgZGF0YSR2MikKYGBgCgpWZWFtb3MgYWhvcmEgbG9zIHJlc3VsdGFkb3MgZGUgbGEgUkxTIHBvciBtw61uaW1vcyBjdWFkcmFkb3M6CmBgYHtyfQpkYXRhWyJ2MmFkam9scyJdIDwtIGNvZWYocmVnMSlbIihJbnRlcmNlcHQpIl0gKyBjb2VmKHJlZzEpWyJ2MSJdKmRhdGEkdjEKY29lZihyZWcxKQpybXNlKGRhdGEkdjJhZGpvbHMsIGRhdGEkdjIpCmBgYAoKVGFudG8gbG9zIGNvZWZpY2llbnRlcyBjb21vIGxvcyB2YWxvcmVzIGRlIFJNU0UgwqFzb24gaWd1YWxlcyEgwr9SYXrDs24/IFVuIG1vZGVsbyBsaW5lYWwgYWp1c3RhZG8gcG9yIG3DoXhpbWEgdmVyb3NpbWlsaXR1ZCB1dGlsaXphbmRvIHVuIHTDqXJtaW5vIGRlIHJlc2lkdWFsZXMgY29uIHVuIGVycm9yIG5vcm1hbG1lbnRlIGRpc3RyaWJ1aWRvIGVzIGVxdWl2YWxlbnRlIGEgdW4gbW9kZWxvIGFqdXN0YWRvIHBvciBtw61uaW1vcyBjdWFkcmFkb3MuIFZlYW1vcyBxdcOpIHBhc2Egc2kgYWp1c3RhbW9zIGxvcyByZXNpZHVhbGVzIHV0aWxpemFuZG8gb3RyYSBkaXN0cmlidWNpw7NuLCBzZWxlY2Npb25hZGEgImEgb2pvIiAoc29sbyBwYXJhIGZpbmVzIGRlbCBlamVtcGxvKSBwb3IgbGEgImZvcm1hIiBkZSBsYSBkaXN0cmlidWNpw7NuIGRlIGxvcyBkYXRvczoKCmBgYHtyfQpkZW5zaXR5IDwtIGdncGxvdChkYXRhID0gZGF0YSwgYWVzKHggPSB2MikpICsgCiAgICAgICAgICAgZ2VvbV9kZW5zaXR5KGNvbG91ciA9ICJkZWVwc2t5Ymx1ZTQiLCBmaWxsID0gImRlZXBza3libHVlNCIsIGFscGhhID0gMC41KSArIAogICAgICAgICAgIGJsYW5rX3RoZW1lKCkgKwogICAgICAgICAgIGxhYnMoeSA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgIHRpdGxlID0gIkdyw6FmaWNvIGRlIGRlbnNpZGFkIGRlIGxhIHZhcmlhYmxlIGEgcHJlZGVjaXIiKSArCiAgICAgICAgICAgc2NhbGVfeV9jb250aW51b3VzKGJyZWFrcyA9IE5VTEwpCmRlbnNpdHkKYGBgCkVzdGEgZGlzdHJpYnVjacOzbiAic2UgcGFyZWNlIiBhIHVuYSBkaXN0cmlidWNpw7NuIGdhbW1hLiAKCmBgYHtyfQpMTGcgPC0gZnVuY3Rpb24oYjAsIGIxLCBzaGFwZSwgcmF0ZSl7CiAgIyBFbmNvbnRyYXIgbG9zIHJlc2lkdWFsZXMuIE1vZGVsbyBhIGFqdXN0YXIgKGxpbmVhbCkKICBSID0gZGF0YSR2MiAtIGRhdGEkdjEgKiBiMSAtIGIwCiAgCiAgIyBDYWxjdWxhciBsYSB2ZXJvc2ltaWxpdHVkLiBSZXNpZHVhbGVzIGNvbiBkaXN0cmlidWNpw7NuIGdhbW1hCiAgCiAgUiA9IHN1cHByZXNzV2FybmluZ3MoZGdhbW1hKFIsIHNoYXBlID0gc2hhcGUsIHJhdGUgPSByYXRlKSkKICAKICAjIFN1bWFyIGVsIGxvZ2FyaXRtbyBkZSBsYXMgdmVyb3NpbWlsaXR1ZGVzIHBhcmEgdG9kb3MgbG9zIHB1bnRvcyBkZSBkYXRvcy4KICAtc3VtKFIsIGxvZyA9IFRSVUUpCn0KCm1sZWcuZml0IDwtIG1sZShMTGcsIAogICAgICAgICAgICAgICAgc3RhcnQgPSBsaXN0KGIwID0gMSwgYjEgPSAxLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlID0gMSwgcmF0ZSA9IDEpLAogICAgICAgICAgICAgICAgbm9icyA9IGxlbmd0aChkYXRhJHYyKSkKc3VtbWFyeShtbGVnLmZpdCkKYGBgClBhcmEgY29tcGFyYXIgZWwgYWp1c3RlIGNvbiByZXNwZWN0byBhbCBjYXNvIGFudGVyaW9yIHBvZGVtb3MgdXRpbGl6YXIgZWwgQ3JpdGVyaW8gZGUgSW5mb3JtYWNpw7NuIGRlIEFrYWlrZS4gVmVtb3MgcXVlLCB0b21hbmRvIGVuIGN1ZW50YSBlc3RlIGNyaXRlcmlvLCBlbCBzZWd1bmRvIG1vZGVsbyBzZSBlbmN1ZW50cmEgbXVjaG8gbWVqb3IgYWp1c3RhZG8gcXVlIGVsIHByaW1lcm8gKHZhbG9yIG3DrW5pbW8gZGUgQUlDKToKYGBge3J9CmFpY3MgPC0gQUlDKG1sZS5maXQsIG1sZWcuZml0KQphaWNzWyJEZWx0YSJdIDwtIGFicyhhYnMoYWljcyRBSUMpIC0gYWJzKG1pbihhaWNzJEFJQykpKQphaWNzCmBgYAoKVGFyZWEgb3BjaW9uYWw6IEdlbmVyYXIgdW4gZ3LDoWZpY28gY29uIGFtYmFzIGzDrW5lYXMgZGUgYWp1c3RlIHkgbG9zIGludGVydmFsb3MgZGUgY29uZmlhbnphIHBhcmEgbGEgcmVjdGEuCgojIyBEYXRvcyBiaW9sw7NnaWNvczogTW9yZm9tZXRyw61hcwpFbiBlc3RlIGVqZW1wbG8gYW5hbGl6YXJlbW9zIGRhdG9zIGRlIG1vcmZvbWV0ZXLDrWFzCgpgYGB7cn0KZGZfaGFlbSA8LSByZWFkLmNzdigiZGF0YS9IYWVtLmNzdiIpCmdncGxvdChkYXRhID0gZGZfaGFlbSwgYWVzKHggPSBMVCwgeSA9IEFNKSkgKyAKICBnZW9tX3BvaW50KGNvbG9yID0gImRvZGdlcmJsdWU0IikgKyAKICBibGFua190aGVtZSgpICsKICBnZW9tX3Ntb290aChtZXRob2QgPSAibG0iLCBjb2xvdXIgPSByZ2IoMTE4LDc4LDE0NCwgbWF4Q29sb3JWYWx1ZSA9IDI1NSkpICsKICBsYWJzKHRpdGxlID0gIlJlbGFjacOzbiBBbHR1cmEgTcOheGltYSB+IExvbmdpdHVkIFRvdGFsIiwKICAgICAgIHggPSBlbGVtZW50X2JsYW5rKCksCiAgICAgICB5ID0gZWxlbWVudF9ibGFuaygpLAogICAgICAgY2FwdGlvbiA9ICJkYXRvczogSGFlbS5jc3YiKQpgYGAKYGBge3J9CnJlZ19oYWVtIDwtIGxtKEFNfkxULCBkYXRhID0gZGZfaGFlbSkKc3VtbWFyeShyZWdfaGFlbSkKYGBgCgpgYGB7cn0KcXFwbG90MiA8LSBnZ3Bsb3QocmVnX2hhZW0pICsgc3RhdF9xcShhZXMoc2FtcGxlID0gLnN0ZHJlc2lkKSwgY29sb3VyID0gImRlZXBza3libHVlNCIsIHNpemUgPSAzLCBhbHBoYSA9IDAuNSkgKyAKICAgICAgICAgICBnZW9tX2FibGluZShjb2xvdXIgPSAgcmdiKDExOCw3OCwxNDQsIG1heENvbG9yVmFsdWUgPSAyNTUpLCBzaXplID0gMSkgKyAKICAgICAgICAgICBsYWJzKHggPSAiQ3VhbnRpbGVzIHRlw7NyaWNvcyIsCiAgICAgICAgICAgICAgICB5ID0gIlJlc2lkdWFsZXMgZXN0YW5kYXJpemFkb3MiLAogICAgICAgICAgICAgICAgdGl0bGUgPSAiR3LDoWZpY28gUVEiKSArCiAgICAgICAgICAgYmxhbmtfdGhlbWUoKQpxcXBsb3QyCmBgYAoKYGBge3J9CnNjYWxlLmxvYy5wbG90IDwtIGdncGxvdChyZWdfaGFlbSwgYWVzKC5maXR0ZWQsIHNxcnQoYWJzKC5zdGRyZXNpZCkpKSkgKyAKICAgICAgICAgICAgICAgICAgZ2VvbV9wb2ludChuYS5ybSA9IFRSVUUsIGNvbG91ciA9ICJkZWVwc2t5Ymx1ZTQiLCBzaXplID0gMywgYWxwaGEgPSAwLjUpICsgCiAgICAgICAgICAgICAgICAgIHN0YXRfc21vb3RoKG1ldGhvZD0ibG9lc3MiLCBuYS5ybSA9IFRSVUUsIGNvbG91ciA9IHJnYigxMTgsNzgsMTQ0LCBtYXhDb2xvclZhbHVlID0gMjU1KSkgKwogICAgICAgICAgICAgICAgICBsYWJzKHggPSAiVmFsb3JlcyBhanVzdGFkb3MiLAogICAgICAgICAgICAgICAgICAgICAgIHkgPSBleHByZXNzaW9uKHNxcnQoInxSZXNpZHVhbGVzIGVzdGFuZGFyaXphZG9zfCIpKSwKICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICJFc2NhbGEtTG9jYWNpw7NuIgogICAgICAgICAgICAgICAgICAgICAgICkgKwogICAgICAgICAgICAgICAgICBibGFua190aGVtZSgpCiAgICAgICAgICAgICAgICAgIApzY2FsZS5sb2MucGxvdApgYGAKCmBgYHtyfQpyZXNpZC5wbG90MiA8LSBnZ3Bsb3QocmVnX2hhZW0sIGFlcyh4ID0gLmZpdHRlZCwgeSA9IC5zdGRyZXNpZCwgY29sb3VyID0gLnN0ZHJlc2lkKSkgKyAKICAgICAgICAgICAgICAgZ2VvbV9wb2ludChzaXplID0gMywgYWxwaGEgPSAwLjUpICsKICAgICAgICAgICAgICAgZ2VvbV9obGluZSh5aW50ZXJjZXB0ID0gMCwgY29sID0gInJlZCIsIGxpbmV0eXBlID0gImRhc2hlZCIpICsKICAgICAgICAgICAgICAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxvZXNzIiwgY29sb3VyID0gcmdiKDExOCw3OCwxNDQsIG1heENvbG9yVmFsdWUgPSAyNTUpKSArCiAgICAgICAgICAgICAgIGxhYnModGl0bGUgPSAiR3LDoWZpY28gZGUgUmVzaWR1YWxlcyIsCiAgICAgICAgICAgICAgICAgICB4ID0gIlZhbG9yZXMgYWp1c3RhZG9zIiwKICAgICAgICAgICAgICAgICAgIHkgPSAiUmVzaWR1YWxlcyBlc3RhbmRhcml6YWRvcyIpICsKICAgICAgICAgICAgICAgYmxhbmtfdGhlbWUoKSArCiAgICAgICAgICAgICAgIHNjYWxlX2NvbG9yX2dyYWRpZW50Mihsb3cgPSAiZmlyZWJyaWNrIiwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRwb2ludCA9IDAsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlkID0gImRlZXBza3libHVlNCIsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaCA9ICJmaXJlYnJpY2siLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtzID0gYygtMiwgMCwgMiksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdHMgPSBjKC0yLCAyKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9vYiA9IHNjYWxlczo6c3F1aXNoKQpyZXNpZC5wbG90MgpgYGAKYGBge3J9CmxpYnJhcnkoYnJtcykKYGBgCgpgYGB7cn0KTEx0IDwtIGZ1bmN0aW9uKGIwLCBiMSwgZGYsIHNpZ21hKXsKICAjIEVuY29udHJhciBsb3MgcmVzaWR1YWxlcy4gTW9kZWxvIGEgYWp1c3RhciAobGluZWFsKQogIFIgPSBkZl9oYWVtJEFNIC0gZGZfaGFlbSRMVCAqIGIxIC0gYjAKICAKICAjIENhbGN1bGFyIGxhIHZlcm9zaW1pbGl0dWQuIFJlc2lkdWFsZXMgY29uIGRpc3RyaWJ1Y2nDs24gdCBkZSBzdHVkZW50CiAgCiAgUiA9IHN1cHByZXNzV2FybmluZ3MoYnJtczo6ZHN0dWRlbnRfdChSLCBkZiA9IGRmLCBtdSA9IDAsIHNpZ21hID0gc2lnbWEpKQogIAogICMgU3VtYXIgZWwgbG9nYXJpdG1vIGRlIGxhcyB2ZXJvc2ltaWxpdHVkZXMgcGFyYSB0b2RvcyBsb3MgcHVudG9zIGRlIGRhdG9zLgogIC1zdW0oUiwgbG9nID0gVFJVRSkKfQoKbWxldF9maXQgPC0gbWxlKExMdCwgCiAgICAgICAgICAgICAgICBzdGFydCA9IGxpc3QoYjAgPSAwLCBiMSA9IDAsIGRmID0gMiwgc2lnbWEgPSAxMCksCiAgICAgICAgICAgICAgICBub2JzID0gbGVuZ3RoKGRmX2hhZW0kQU0pLAogICAgICAgICAgICAgICAgbG93ZXIgPSBjKGIwID0gLTIwLCBiMSA9IC0xMiwgZGYgPSAxLCBzaWdtYSA9IDAuMDEpLAogICAgICAgICAgICAgICAgdXBwZXIgPSBjKGIwID0gMjAsIGIxID0gMTIsIGRmID0gMzAsIHNpZ21hID0gMTApKQoKc3VtbWFyeShtbGV0X2ZpdCkKYGBgCmBgYHtyfQpjb2VmKHJlZ19oYWVtKQpgYGAKYGBge3J9CmFpY3MgPC0gQUlDKG1sZXRfZml0LCByZWdfaGFlbSkKYWljc1siRGVsdGEiXSA8LSBhYnMoYWJzKGFpY3MkQUlDKSAtIGFicyhtaW4oYWljcyRBSUMpKSkKYWljcwpgYGAKIyMgQm9udXM6IExpYnJlcsOtYSBgcGVyZm9ybWFuY2VgClBvZGVtb3MgZ2VuZXJhciBsb3MgZ3LDoWZpY29zIGRpYWduw7NzdGljb3MgZGUgZGlzdGludG9zIG1vZGVsb3MgdXRpbGl6YW5kbyB1bmEgc29sYSBsw61uZWEgZGUgY8OzZGlnby4gVmVhbW9zIGVsIGNhc28gZGVsIHByaW1lciBtb2RlbG8gbGluZWFsIHF1ZSBlbGFib3JhbW9zOgpgYGB7ciwgZmlnLndpZHRoPTkuNiwgZmlnLmhlaWdodD05LCB3YXJuaW5nPUZBTFNFfQppZiAoIXJlcXVpcmUocGVyZm9ybWFuY2UpKSB7aW5zdGFsbC5wYWNrYWdlcyhjKCJwZXJmb3JtYW5jZSIsICJxcXBsb3RyIiksIGRlcGVuZGVuY2llcyA9IFQpfQpjaGVja19tb2RlbChyZWcxKQpgYGAKQWhvcmEgc29icmUgbG9zIGRhdG9zIGBIYWVtLmNzdmA6CmBgYHtyLGZpZy53aWR0aD05LjYsIGZpZy5oZWlnaHQ9OX0KY2hlY2tfbW9kZWwocmVnX2hhZW0pCmBgYAoKCiMjIENvbXBhcmFjacOzbiBkZSByZWdyZXNpb25lcwoKU3Vwb25nYW1vcyBhaG9yYSBxdWUgbGEgYmFzZSBkZSBkYXRvcyAxIGVuIHJlYWxpZGFkIGNvbnN0YSBkZSBkb3MgImdydXBvcyIuIFVuYSBwcmVndW5hIHJhem9uYWJsZSBzZXLDrWEgZWwgc2FiZXIgc2kgcG9kZW1vcyBhZ3J1cGFybG9zIHBhcmEgcmVhbGl6YXIgdW5hIFJMUywgeSBlc3RvIGxvIHBvZGVtb3MgcmVzb2x2ZXIgZsOhY2lsbWVudGUgY29uIGxhIHBydWViYSBkZSBDaG93ICgxOTYwKS4gUHJpbWVybywgcGFydGFtb3MgbG9zIGRhdG9zIHBvciBhcHJveGltYWRhbWVudGUgbGEgbWl0YWQ6CmBgYHtyfQpkZi5yZWcyIDwtIGRmLnJlZzFbLDE6Ml0KZGYucmVnMlsiZ3J1cG8iXSA8LSBjKHJlcCgiQSIsIDQ4KSwgcmVwKCJCIiwgNDkpKQpgYGAKCkFob3JhIGFwbGlxdWVtb3MgbGEgcHJ1ZWJhIGRlIENob3csIHV0aWxpemFuZG8gbGEgZnVuY2nDs24gYGNob3cudGVzdCh5MSwgeDEsIHkyLCB4MilgOgpgYGB7ciBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQpsaWJyYXJ5KGdhcCkKY29tcC5yZWcgPC0gY2hvdy50ZXN0KHkxID0gZGYucmVnMiR2MltkZi5yZWcyJGdydXBvID09ICJBIl0sCiAgICAgICAgICAgICAgICAgICAgICB4MSA9IGRmLnJlZzIkdjFbZGYucmVnMiRncnVwbyA9PSAiQSJdLAogICAgICAgICAgICAgICAgICAgICAgeTIgPSBkZi5yZWcyJHYyW2RmLnJlZzIkZ3J1cG8gPT0gIkIiXSwKICAgICAgICAgICAgICAgICAgICAgIHgyID0gZGYucmVnMiR2MVtkZi5yZWcyJGdydXBvID09ICJCIl0pCnByaW50KGNvbXAucmVnKQpgYGAKClZlYW1vcyBsYXMgcmVncmVzaW9uZXMgZ3LDoWZpY2FtZW50ZTo6CmBgYHtyfQpnZ3Bsb3QoZGF0YSA9IGRmLnJlZzIsIGFlcyh4ID0gdjEsIHkgPSB2MiwgY29sb3VyID0gZ3J1cG8sIHNoYXBlID0gZ3J1cG8pKSArCmdlb21fcG9pbnQoYWxwaGEgPSAwLjUsIHNpemUgPSAzKSArCmdlb21fc21vb3RoKG1ldGhvZCA9IGxtKSArCmJsYW5rX3RoZW1lKCkgKwpsYWJzKHRpdGxlID0gIlJlZ3Jlc2nDs24gbGluZWFsIGNvbiBkb3MgZ3J1cG9zIiwKICAgICBzdWJ0aXRsZSA9IHBhc3RlKCJGICgiLCBjb21wLnJlZ1siZC5mLjEiXSwgIiwgIiwgY29tcC5yZWdbImQuZi4yIl0sICIpID0gIiwgCiAgICAgICAgICAgICAgICAgICAgICByb3VuZChjb21wLnJlZ1siRiB2YWx1ZSJdLDIpLCAiLCAiLCAicCA9ICIsIGlmZWxzZShjb21wLnJlZ1siUCB2YWx1ZSJdIDwgMC4wMDEsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiIDwgMC4wMDEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzdGUoIiA9ICIsIGNvbXAucmVnWyJQIHZhbHVlIl0pKSksCiAgICAgY2FwdGlvbiA9ICJEYXRvcyBzaW11bGFkb3MiKQoKYGBgCgoKIyMgRWplcmNpY2lvCgpBcGxpY2FyIGxhIHBydWViYSBkZSBDaG93IGEgbGEgYmFzZSBkZSBkYXRvcyBgSGFlbS5jc3ZgLCBjb25zaWRlcmFuZG8gbG9zIGRvcyBncnVwb3MgZW4gbGEgY29sdW1uYSBgTG9jYC4K</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("c8_rls.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
